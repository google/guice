<?xml version="1.0" encoding="iso-8859-1" standalone="no"?>
<!-- Generated by the JDiff Javadoc doclet -->
<!-- (http://www.jdiff.org) -->
<!-- on Thu Mar 24 21:41:19 EDT 2011 -->

<api
  xmlns:xsi='http://www.w3.org/2001/XMLSchema-instance'
  xsi:noNamespaceSchemaLocation='api.xsd'
  name="3.0"
  jdversion="1.1.1">

<!--  Command line arguments =  -doclet jdiff.JDiff -docletpath C:\Documents and Settings\Sam Berlin\workspace\guice\lib\build\jdiff\jdiff.jar;C:\Documents and Settings\Sam Berlin\workspace\guice\lib\build\jdiff\xerces.jar -classpath C:\Documents and Settings\Sam Berlin\workspace\guice\lib\javax.inject.jar;C:\Documents and Settings\Sam Berlin\workspace\guice\lib\aopalliance.jar -apidir build/docs/latest-api-diffs -apiname 3.0 -->
<package name="com.google.inject">
  <!-- start class com.google.inject.AbstractModule -->
  <class name="AbstractModule" extends="java.lang.Object"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.inject.Module"/>
    <constructor name="AbstractModule"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="configure"
      abstract="false" native="false" synchronized="true"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="builder" type="com.google.inject.Binder"/>
    </method>
    <method name="configure"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Configures a {@link Binder} via the exposed methods.]]>
      </doc>
    </method>
    <method name="binder" return="com.google.inject.Binder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets direct access to the underlying {@code Binder}.]]>
      </doc>
    </method>
    <method name="bindScope"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="scopeAnnotation" type="java.lang.Class&lt;? extends java.lang.annotation.Annotation&gt;"/>
      <param name="scope" type="com.google.inject.Scope"/>
      <doc>
      <![CDATA[@see Binder#bindScope(Class, Scope)]]>
      </doc>
    </method>
    <method name="bind" return="com.google.inject.binder.LinkedBindingBuilder&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="key" type="com.google.inject.Key&lt;T&gt;"/>
      <doc>
      <![CDATA[@see Binder#bind(Key)]]>
      </doc>
    </method>
    <method name="bind" return="com.google.inject.binder.AnnotatedBindingBuilder&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="typeLiteral" type="com.google.inject.TypeLiteral&lt;T&gt;"/>
      <doc>
      <![CDATA[@see Binder#bind(TypeLiteral)]]>
      </doc>
    </method>
    <method name="bind" return="com.google.inject.binder.AnnotatedBindingBuilder&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="clazz" type="java.lang.Class&lt;T&gt;"/>
      <doc>
      <![CDATA[@see Binder#bind(Class)]]>
      </doc>
    </method>
    <method name="bindConstant" return="com.google.inject.binder.AnnotatedConstantBindingBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@see Binder#bindConstant()]]>
      </doc>
    </method>
    <method name="install"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="module" type="com.google.inject.Module"/>
      <doc>
      <![CDATA[@see Binder#install(Module)]]>
      </doc>
    </method>
    <method name="addError"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="message" type="java.lang.String"/>
      <param name="arguments" type="java.lang.Object[]"/>
      <doc>
      <![CDATA[@see Binder#addError(String, Object[])]]>
      </doc>
    </method>
    <method name="addError"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="t" type="java.lang.Throwable"/>
      <doc>
      <![CDATA[@see Binder#addError(Throwable)]]>
      </doc>
    </method>
    <method name="addError"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="message" type="com.google.inject.spi.Message"/>
      <doc>
      <![CDATA[@see Binder#addError(Message)
 @since 2.0]]>
      </doc>
    </method>
    <method name="requestInjection"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="instance" type="java.lang.Object"/>
      <doc>
      <![CDATA[@see Binder#requestInjection(Object)
 @since 2.0]]>
      </doc>
    </method>
    <method name="requestStaticInjection"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="types" type="java.lang.Class[]"/>
      <doc>
      <![CDATA[@see Binder#requestStaticInjection(Class[])]]>
      </doc>
    </method>
    <method name="bindInterceptor"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="classMatcher" type="com.google.inject.matcher.Matcher&lt;? super java.lang.Class&lt;?&gt;&gt;"/>
      <param name="methodMatcher" type="com.google.inject.matcher.Matcher&lt;? super java.lang.reflect.Method&gt;"/>
      <param name="interceptors" type="org.aopalliance.intercept.MethodInterceptor[]"/>
      <doc>
      <![CDATA[@see Binder#bindInterceptor(com.google.inject.matcher.Matcher,
  com.google.inject.matcher.Matcher,
  org.aopalliance.intercept.MethodInterceptor[])]]>
      </doc>
    </method>
    <method name="requireBinding"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="key" type="com.google.inject.Key&lt;?&gt;"/>
      <doc>
      <![CDATA[Adds a dependency from this module to {@code key}. When the injector is
 created, Guice will report an error if {@code key} cannot be injected.
 Note that this requirement may be satisfied by implicit binding, such as
 a public no-arguments constructor.

 @since 2.0]]>
      </doc>
    </method>
    <method name="requireBinding"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="type" type="java.lang.Class&lt;?&gt;"/>
      <doc>
      <![CDATA[Adds a dependency from this module to {@code type}. When the injector is
 created, Guice will report an error if {@code type} cannot be injected.
 Note that this requirement may be satisfied by implicit binding, such as
 a public no-arguments constructor.

 @since 2.0]]>
      </doc>
    </method>
    <method name="getProvider" return="com.google.inject.Provider&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="key" type="com.google.inject.Key&lt;T&gt;"/>
      <doc>
      <![CDATA[@see Binder#getProvider(Key)
 @since 2.0]]>
      </doc>
    </method>
    <method name="getProvider" return="com.google.inject.Provider&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="type" type="java.lang.Class&lt;T&gt;"/>
      <doc>
      <![CDATA[@see Binder#getProvider(Class)
 @since 2.0]]>
      </doc>
    </method>
    <method name="convertToTypes"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="typeMatcher" type="com.google.inject.matcher.Matcher&lt;? super com.google.inject.TypeLiteral&lt;?&gt;&gt;"/>
      <param name="converter" type="com.google.inject.spi.TypeConverter"/>
      <doc>
      <![CDATA[@see Binder#convertToTypes
 @since 2.0]]>
      </doc>
    </method>
    <method name="currentStage" return="com.google.inject.Stage"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@see Binder#currentStage() 
 @since 2.0]]>
      </doc>
    </method>
    <method name="getMembersInjector" return="com.google.inject.MembersInjector&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="type" type="java.lang.Class&lt;T&gt;"/>
      <doc>
      <![CDATA[@see Binder#getMembersInjector(Class)
 @since 2.0]]>
      </doc>
    </method>
    <method name="getMembersInjector" return="com.google.inject.MembersInjector&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="type" type="com.google.inject.TypeLiteral&lt;T&gt;"/>
      <doc>
      <![CDATA[@see Binder#getMembersInjector(TypeLiteral)
 @since 2.0]]>
      </doc>
    </method>
    <method name="bindListener"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="typeMatcher" type="com.google.inject.matcher.Matcher&lt;? super com.google.inject.TypeLiteral&lt;?&gt;&gt;"/>
      <param name="listener" type="com.google.inject.spi.TypeListener"/>
      <doc>
      <![CDATA[@see Binder#bindListener(com.google.inject.matcher.Matcher,
  com.google.inject.spi.TypeListener)
 @since 2.0]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A support class for {@link Module}s which reduces repetition and results in
 a more readable configuration. Simply extend this class, implement {@link
 #configure()}, and call the inherited methods which mirror those found in
 {@link Binder}. For example:

 <pre>
 public class MyModule extends AbstractModule {
   protected void configure() {
     bind(Service.class).to(ServiceImpl.class).in(Singleton.class);
     bind(CreditCardPaymentService.class);
     bind(PaymentService.class).to(CreditCardPaymentService.class);
     bindConstant().annotatedWith(Names.named("port")).to(8080);
   }
 }
 </pre>

 @author crazybob@google.com (Bob Lee)]]>
    </doc>
  </class>
  <!-- end class com.google.inject.AbstractModule -->
  <!-- start interface com.google.inject.Binder -->
  <interface name="Binder"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="bindInterceptor"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="classMatcher" type="com.google.inject.matcher.Matcher&lt;? super java.lang.Class&lt;?&gt;&gt;"/>
      <param name="methodMatcher" type="com.google.inject.matcher.Matcher&lt;? super java.lang.reflect.Method&gt;"/>
      <param name="interceptors" type="org.aopalliance.intercept.MethodInterceptor[]"/>
      <doc>
      <![CDATA[Binds method interceptor[s] to methods matched by class and method matchers. A method is
 eligible for interception if:

 <ul>
  <li>Guice created the instance the method is on</li>
  <li>Neither the enclosing type nor the method is final</li>
  <li>And the method is package-private, protected, or public</li>
 </ul>

 @param classMatcher matches classes the interceptor should apply to. For
     example: {@code only(Runnable.class)}.
 @param methodMatcher matches methods the interceptor should apply to. For
     example: {@code annotatedWith(Transactional.class)}.
 @param interceptors to bind]]>
      </doc>
    </method>
    <method name="bindScope"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="annotationType" type="java.lang.Class&lt;? extends java.lang.annotation.Annotation&gt;"/>
      <param name="scope" type="com.google.inject.Scope"/>
      <doc>
      <![CDATA[Binds a scope to an annotation.]]>
      </doc>
    </method>
    <method name="bind" return="com.google.inject.binder.LinkedBindingBuilder&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="com.google.inject.Key&lt;T&gt;"/>
      <doc>
      <![CDATA[See the EDSL examples at {@link Binder}.]]>
      </doc>
    </method>
    <method name="bind" return="com.google.inject.binder.AnnotatedBindingBuilder&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="typeLiteral" type="com.google.inject.TypeLiteral&lt;T&gt;"/>
      <doc>
      <![CDATA[See the EDSL examples at {@link Binder}.]]>
      </doc>
    </method>
    <method name="bind" return="com.google.inject.binder.AnnotatedBindingBuilder&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="java.lang.Class&lt;T&gt;"/>
      <doc>
      <![CDATA[See the EDSL examples at {@link Binder}.]]>
      </doc>
    </method>
    <method name="bindConstant" return="com.google.inject.binder.AnnotatedConstantBindingBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[See the EDSL examples at {@link Binder}.]]>
      </doc>
    </method>
    <method name="requestInjection"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="com.google.inject.TypeLiteral&lt;T&gt;"/>
      <param name="instance" type="T"/>
      <doc>
      <![CDATA[Upon successful creation, the {@link Injector} will inject instance fields
 and methods of the given object.

 @param type of instance
 @param instance for which members will be injected
 @since 2.0]]>
      </doc>
    </method>
    <method name="requestInjection"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="instance" type="java.lang.Object"/>
      <doc>
      <![CDATA[Upon successful creation, the {@link Injector} will inject instance fields
 and methods of the given object.

 @param instance for which members will be injected
 @since 2.0]]>
      </doc>
    </method>
    <method name="requestStaticInjection"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="types" type="java.lang.Class[]"/>
      <doc>
      <![CDATA[Upon successful creation, the {@link Injector} will inject static fields
 and methods in the given classes.

 @param types for which static members will be injected]]>
      </doc>
    </method>
    <method name="install"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="module" type="com.google.inject.Module"/>
      <doc>
      <![CDATA[Uses the given module to configure more bindings.]]>
      </doc>
    </method>
    <method name="currentStage" return="com.google.inject.Stage"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the current stage.]]>
      </doc>
    </method>
    <method name="addError"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="message" type="java.lang.String"/>
      <param name="arguments" type="java.lang.Object[]"/>
      <doc>
      <![CDATA[Records an error message which will be presented to the user at a later
 time. Unlike throwing an exception, this enable us to continue
 configuring the Injector and discover more errors. Uses {@link
 String#format(String, Object[])} to insert the arguments into the
 message.]]>
      </doc>
    </method>
    <method name="addError"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="t" type="java.lang.Throwable"/>
      <doc>
      <![CDATA[Records an exception, the full details of which will be logged, and the
 message of which will be presented to the user at a later
 time. If your Module calls something that you worry may fail, you should
 catch the exception and pass it into this.]]>
      </doc>
    </method>
    <method name="addError"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="message" type="com.google.inject.spi.Message"/>
      <doc>
      <![CDATA[Records an error message to be presented to the user at a later time.

 @since 2.0]]>
      </doc>
    </method>
    <method name="getProvider" return="com.google.inject.Provider&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="com.google.inject.Key&lt;T&gt;"/>
      <doc>
      <![CDATA[Returns the provider used to obtain instances for the given injection key.
 The returned provider will not be valid until the {@link Injector} has been
 created. The provider will throw an {@code IllegalStateException} if you
 try to use it beforehand.

 @since 2.0]]>
      </doc>
    </method>
    <method name="getProvider" return="com.google.inject.Provider&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="java.lang.Class&lt;T&gt;"/>
      <doc>
      <![CDATA[Returns the provider used to obtain instances for the given injection type.
 The returned provider will not be valid until the {@link Injector} has been
 created. The provider will throw an {@code IllegalStateException} if you
 try to use it beforehand.

 @since 2.0]]>
      </doc>
    </method>
    <method name="getMembersInjector" return="com.google.inject.MembersInjector&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="typeLiteral" type="com.google.inject.TypeLiteral&lt;T&gt;"/>
      <doc>
      <![CDATA[Returns the members injector used to inject dependencies into methods and fields on instances
 of the given type {@code T}. The returned members injector will not be valid until the main
 {@link Injector} has been created. The members injector will throw an {@code
 IllegalStateException} if you try to use it beforehand.

 @param typeLiteral type to get members injector for
 @since 2.0]]>
      </doc>
    </method>
    <method name="getMembersInjector" return="com.google.inject.MembersInjector&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="java.lang.Class&lt;T&gt;"/>
      <doc>
      <![CDATA[Returns the members injector used to inject dependencies into methods and fields on instances
 of the given type {@code T}. The returned members injector will not be valid until the main
 {@link Injector} has been created. The members injector will throw an {@code
 IllegalStateException} if you try to use it beforehand.

 @param type type to get members injector for
 @since 2.0]]>
      </doc>
    </method>
    <method name="convertToTypes"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="typeMatcher" type="com.google.inject.matcher.Matcher&lt;? super com.google.inject.TypeLiteral&lt;?&gt;&gt;"/>
      <param name="converter" type="com.google.inject.spi.TypeConverter"/>
      <doc>
      <![CDATA[Binds a type converter. The injector will use the given converter to
 convert string constants to matching types as needed.

 @param typeMatcher matches types the converter can handle
 @param converter converts values
 @since 2.0]]>
      </doc>
    </method>
    <method name="bindListener"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="typeMatcher" type="com.google.inject.matcher.Matcher&lt;? super com.google.inject.TypeLiteral&lt;?&gt;&gt;"/>
      <param name="listener" type="com.google.inject.spi.TypeListener"/>
      <doc>
      <![CDATA[Registers a listener for injectable types. Guice will notify the listener when it encounters
 injectable types matched by the given type matcher.

 @param typeMatcher that matches injectable types the listener should be notified of
 @param listener for injectable types matched by typeMatcher
 @since 2.0]]>
      </doc>
    </method>
    <method name="withSource" return="com.google.inject.Binder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="source" type="java.lang.Object"/>
      <doc>
      <![CDATA[Returns a binder that uses {@code source} as the reference location for
 configuration errors. This is typically a {@link StackTraceElement}
 for {@code .java} source but it could any binding source, such as the
 path to a {@code .properties} file.

 @param source any object representing the source location and has a
     concise {@link Object#toString() toString()} value
 @return a binder that shares its configuration with this binder
 @since 2.0]]>
      </doc>
    </method>
    <method name="skipSources" return="com.google.inject.Binder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="classesToSkip" type="java.lang.Class[]"/>
      <doc>
      <![CDATA[Returns a binder that skips {@code classesToSkip} when identify the
 calling code. The caller's {@link StackTraceElement} is used to locate
 the source of configuration errors.

 @param classesToSkip library classes that create bindings on behalf of
      their clients.
 @return a binder that shares its configuration with this binder.
 @since 2.0]]>
      </doc>
    </method>
    <method name="newPrivateBinder" return="com.google.inject.PrivateBinder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a new private child environment for bindings and other configuration. The returned
 binder can be used to add and configuration information in this environment. See {@link
 PrivateModule} for details.

 @return a binder that inherits configuration from this binder. Only exposed configuration on
      the returned binder will be visible to this binder.
 @since 2.0]]>
      </doc>
    </method>
    <method name="requireExplicitBindings"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Instructs the Injector that bindings must be listed in a Module in order to
 be injected. Classes that are not explicitly bound in a module cannot be
 injected. Bindings created through a linked binding (
 <code>bind(Foo.class).to(FooImpl.class)</code>) are allowed, but the
 implicit binding (<code>FooImpl</code>) cannot be directly injected unless
 it is also explicitly bound (<code>bind(FooImpl.class)</code>).
 <p>
 Tools can still retrieve bindings for implicit bindings (bindings created
 through a linked binding) if explicit bindings are required, however
 {@link Binding#getProvider} will fail.
 <p>
 By default, explicit bindings are not required.
 <p>
 If a parent injector requires explicit bindings, then all child injectors
 (and private modules within that injector) also require explicit bindings.
 If a parent does not require explicit bindings, a child injector or private
 module may optionally declare itself as requiring explicit bindings. If it
 does, the behavior is limited only to that child or any grandchildren. No
 siblings of the child will require explicit bindings.
 <p>
 If the parent did not require explicit bindings but the child does, it is
 possible that a linked binding in the child may add a JIT binding to the
 parent. The child will not be allowed to reference the target binding
 directly, but the parent and other children of the parent may be able to.
 
 @since 3.0]]>
      </doc>
    </method>
    <method name="disableCircularProxies"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Prevents Guice from constructing a {@link Proxy} when a circular dependency
 is found.  By default, circular proxies are not disabled.
 <p>
 If a parent injector disables circular proxies, then all child injectors
 (and private modules within that injector) also disable circular proxies.
 If a parent does not disable circular proxies, a child injector or private
 module may optionally declare itself as disabling circular proxies. If it
 does, the behavior is limited only to that child or any grandchildren. No
 siblings of the child will disable circular proxies.
 
 @since 3.0]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Collects configuration information (primarily <i>bindings</i>) which will be
 used to create an {@link Injector}. Guice provides this object to your
 application's {@link Module} implementors so they may each contribute
 their own bindings and other registrations.

 <h3>The Guice Binding EDSL</h3>

 Guice uses an <i>embedded domain-specific language</i>, or EDSL, to help you
 create bindings simply and readably.  This approach is great for overall
 usability, but it does come with a small cost: <b>it is difficult to
 learn how to use the Binding EDSL by reading
 method-level javadocs</b>.  Instead, you should consult the series of
 examples below.  To save space, these examples omit the opening
 {@code binder}, just as you will if your module extends
 {@link AbstractModule}.

 <pre>
     bind(ServiceImpl.class);</pre>

 This statement does essentially nothing; it "binds the {@code ServiceImpl}
 class to itself" and does not change Guice's default behavior.  You may still
 want to use this if you prefer your {@link Module} class to serve as an
 explicit <i>manifest</i> for the services it provides.  Also, in rare cases,
 Guice may be unable to validate a binding at injector creation time unless it
 is given explicitly.

 <pre>
     bind(Service.class).to(ServiceImpl.class);</pre>

 Specifies that a request for a {@code Service} instance with no binding
 annotations should be treated as if it were a request for a
 {@code ServiceImpl} instance. This <i>overrides</i> the function of any
 {@link ImplementedBy @ImplementedBy} or {@link ProvidedBy @ProvidedBy}
 annotations found on {@code Service}, since Guice will have already
 "moved on" to {@code ServiceImpl} before it reaches the point when it starts
 looking for these annotations.

 <pre>
     bind(Service.class).toProvider(ServiceProvider.class);</pre>

 In this example, {@code ServiceProvider} must extend or implement
 {@code Provider<Service>}. This binding specifies that Guice should resolve
 an unannotated injection request for {@code Service} by first resolving an
 instance of {@code ServiceProvider} in the regular way, then calling
 {@link Provider#get get()} on the resulting Provider instance to obtain the
 {@code Service} instance.

 <p>The {@link Provider} you use here does not have to be a "factory"; that
 is, a provider which always <i>creates</i> each instance it provides.
 However, this is generally a good practice to follow.  You can then use
 Guice's concept of {@link Scope scopes} to guide when creation should happen
 -- "letting Guice work for you".

 <pre>
     bind(Service.class).annotatedWith(Red.class).to(ServiceImpl.class);</pre>

 Like the previous example, but only applies to injection requests that use
 the binding annotation {@code @Red}.  If your module also includes bindings
 for particular <i>values</i> of the {@code @Red} annotation (see below),
 then this binding will serve as a "catch-all" for any values of {@code @Red}
 that have no exact match in the bindings.
 
 <pre>
     bind(ServiceImpl.class).in(Singleton.class);
     // or, alternatively
     bind(ServiceImpl.class).in(Scopes.SINGLETON);</pre>

 Either of these statements places the {@code ServiceImpl} class into
 singleton scope.  Guice will create only one instance of {@code ServiceImpl}
 and will reuse it for all injection requests of this type.  Note that it is
 still possible to bind another instance of {@code ServiceImpl} if the second
 binding is qualified by an annotation as in the previous example.  Guice is
 not overly concerned with <i>preventing</i> you from creating multiple
 instances of your "singletons", only with <i>enabling</i> your application to
 share only one instance if that's all you tell Guice you need.

 <p><b>Note:</b> a scope specified in this way <i>overrides</i> any scope that
 was specified with an annotation on the {@code ServiceImpl} class.
 
 <p>Besides {@link Singleton}/{@link Scopes#SINGLETON}, there are
 servlet-specific scopes available in
 {@code com.google.inject.servlet.ServletScopes}, and your Modules can
 contribute their own custom scopes for use here as well.

 <pre>
     bind(new TypeLiteral&lt;PaymentService&lt;CreditCard>>() {})
         .to(CreditCardPaymentService.class);</pre>

 This admittedly odd construct is the way to bind a parameterized type. It
 tells Guice how to honor an injection request for an element of type
 {@code PaymentService<CreditCard>}. The class
 {@code CreditCardPaymentService} must implement the
 {@code PaymentService<CreditCard>} interface.  Guice cannot currently bind or
 inject a generic type, such as {@code Set<E>}; all type parameters must be
 fully specified.

 <pre>
     bind(Service.class).toInstance(new ServiceImpl());
     // or, alternatively
     bind(Service.class).toInstance(SomeLegacyRegistry.getService());</pre>

 In this example, your module itself, <i>not Guice</i>, takes responsibility
 for obtaining a {@code ServiceImpl} instance, then asks Guice to always use
 this single instance to fulfill all {@code Service} injection requests.  When
 the {@link Injector} is created, it will automatically perform field
 and method injection for this instance, but any injectable constructor on
 {@code ServiceImpl} is simply ignored.  Note that using this approach results
 in "eager loading" behavior that you can't control.

 <pre>
     bindConstant().annotatedWith(ServerHost.class).to(args[0]);</pre>

 Sets up a constant binding. Constant injections must always be annotated.
 When a constant binding's value is a string, it is eligile for conversion to
 all primitive types, to {@link Enum#valueOf(Class, String) all enums}, and to
 {@link Class#forName class literals}. Conversions for other types can be
 configured using {@link #convertToTypes(Matcher, TypeConverter)
 convertToTypes()}.

 <pre>
   {@literal @}Color("red") Color red; // A member variable (field)
    . . .
     red = MyModule.class.getDeclaredField("red").getAnnotation(Color.class);
     bind(Service.class).annotatedWith(red).to(RedService.class);</pre>

 If your binding annotation has parameters you can apply different bindings to
 different specific values of your annotation.  Getting your hands on the
 right instance of the annotation is a bit of a pain -- one approach, shown
 above, is to apply a prototype annotation to a field in your module class, so
 that you can read this annotation instance and give it to Guice.

 <pre>
     bind(Service.class)
         .annotatedWith(Names.named("blue"))
         .to(BlueService.class);</pre>

 Differentiating by names is a common enough use case that we provided a
 standard annotation, {@link com.google.inject.name.Named @Named}.  Because of
 Guice's library support, binding by name is quite easier than in the
 arbitrary binding annotation case we just saw.  However, remember that these
 names will live in a single flat namespace with all the other names used in
 your application.

 <pre>
     Constructor<T> loneCtor = getLoneCtorFromServiceImplViaReflection();
     bind(ServiceImpl.class)
         .toConstructor(loneCtor);</pre>

 In this example, we directly tell Guice which constructor to use in a concrete
 class implementation. It means that we do not need to place {@literal @}Inject
 on any of the constructors and that Guice treats the provided constructor as though
 it were annotated so. It is useful for cases where you cannot modify existing
 classes and is a bit simpler than using a {@link Provider}.

 <p>The above list of examples is far from exhaustive.  If you can think of
 how the concepts of one example might coexist with the concepts from another,
 you can most likely weave the two together.  If the two concepts make no
 sense with each other, you most likely won't be able to do it.  In a few
 cases Guice will let something bogus slip by, and will then inform you of
 the problems at runtime, as soon as you try to create your Injector.

 <p>The other methods of Binder such as {@link #bindScope},
 {@link #bindInterceptor}, {@link #install}, {@link #requestStaticInjection},
 {@link #addError} and {@link #currentStage} are not part of the Binding EDSL;
 you can learn how to use these in the usual way, from the method
 documentation.

 @author crazybob@google.com (Bob Lee)
 @author jessewilson@google.com (Jesse Wilson)
 @author kevinb@google.com (Kevin Bourrillion)]]>
    </doc>
  </interface>
  <!-- end interface com.google.inject.Binder -->
  <!-- start interface com.google.inject.Binding -->
  <interface name="Binding"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.inject.spi.Element"/>
    <method name="getKey" return="com.google.inject.Key&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the key for this binding.]]>
      </doc>
    </method>
    <method name="getProvider" return="com.google.inject.Provider&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the scoped provider guice uses to fulfill requests for this
 binding.

 @throws UnsupportedOperationException when invoked on a {@link Binding}
      created via {@link com.google.inject.spi.Elements#getElements}. This
      method is only supported on {@link Binding}s returned from an injector.]]>
      </doc>
    </method>
    <method name="acceptTargetVisitor" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="visitor" type="com.google.inject.spi.BindingTargetVisitor&lt;? super T, V&gt;"/>
      <doc>
      <![CDATA[Accepts a target visitor. Invokes the visitor method specific to this binding's target.

 @param visitor to call back on
 @since 2.0]]>
      </doc>
    </method>
    <method name="acceptScopingVisitor" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="visitor" type="com.google.inject.spi.BindingScopingVisitor&lt;V&gt;"/>
      <doc>
      <![CDATA[Accepts a scoping visitor. Invokes the visitor method specific to this binding's scoping.

 @param visitor to call back on
 @since 2.0]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A mapping from a key (type and optional annotation) to the strategy for getting instances of the
 type. This interface is part of the introspection API and is intended primarily for use by 
 tools.

 <p>Bindings are created in several ways:
 <ul>
     <li>Explicitly in a module, via {@code bind()} and {@code bindConstant()}
         statements:
 <pre>
     bind(Service.class).annotatedWith(Red.class).to(ServiceImpl.class);
     bindConstant().annotatedWith(ServerHost.class).to(args[0]);</pre></li>
     <li>Implicitly by the Injector by following a type's {@link ImplementedBy
         pointer} {@link ProvidedBy annotations} or by using its {@link Inject annotated} or
         default constructor.</li>
     <li>By converting a bound instance to a different type.</li>
     <li>For {@link Provider providers}, by delegating to the binding for the provided type.</li>
 </ul>


 <p>They exist on both modules and on injectors, and their behaviour is different for each:
 <ul>
     <li><strong>Module bindings</strong> are incomplete and cannot be used to provide instances.
         This is because the applicable scopes and interceptors may not be known until an injector
         is created. From a tool's perspective, module bindings are like the injector's source
         code. They can be inspected or rewritten, but this analysis must be done statically.</li>
     <li><strong>Injector bindings</strong> are complete and valid and can be used to provide
         instances. From a tools' perspective, injector bindings are like reflection for an
         injector. They have full runtime information, including the complete graph of injections
         necessary to satisfy a binding.</li>
 </ul>

 @param <T> the bound type. The injected is always assignable to this type.

 @author crazybob@google.com (Bob Lee)
 @author jessewilson@google.com (Jesse Wilson)]]>
    </doc>
  </interface>
  <!-- end interface com.google.inject.Binding -->
  <!-- start class com.google.inject.BindingAnnotation -->
  <class name="BindingAnnotation"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.lang.annotation.Annotation"/>
    <doc>
    <![CDATA[Annotates annotations which are used for binding. Only one such annotation
 may apply to a single injection point. You must also annotate binder
 annotations with {@code @Retention(RUNTIME)}. For example:

 <pre>
   {@code @}Retention(RUNTIME)
   {@code @}Target({ FIELD, PARAMETER, METHOD })
   {@code @}BindingAnnotation
   public {@code @}interface Transactional {}
 </pre>

 @author crazybob@google.com (Bob Lee)]]>
    </doc>
  </class>
  <!-- end class com.google.inject.BindingAnnotation -->
  <!-- start class com.google.inject.ConfigurationException -->
  <class name="ConfigurationException" extends="java.lang.RuntimeException"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="ConfigurationException" type="java.lang.Iterable&lt;com.google.inject.spi.Message&gt;"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a ConfigurationException containing {@code messages}.]]>
      </doc>
    </constructor>
    <method name="withPartialValue" return="com.google.inject.ConfigurationException"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="partialValue" type="java.lang.Object"/>
      <doc>
      <![CDATA[Returns a copy of this configuration exception with the specified partial value.]]>
      </doc>
    </method>
    <method name="getErrorMessages" return="java.util.Collection&lt;com.google.inject.spi.Message&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns messages for the errors that caused this exception.]]>
      </doc>
    </method>
    <method name="getPartialValue" return="E"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a value that was only partially computed due to this exception. The caller can use
 this while collecting additional configuration problems.

 @return the partial value, or {@code null} if none was set. The type of the partial value is
      specified by the throwing method.]]>
      </doc>
    </method>
    <method name="getMessage" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Thrown when a programming error such as a misplaced annotation, illegal binding, or unsupported
 scope is found. Clients should catch this exception, log it, and stop execution.

 @author jessewilson@google.com (Jesse Wilson)
 @since 2.0]]>
    </doc>
  </class>
  <!-- end class com.google.inject.ConfigurationException -->
  <!-- start class com.google.inject.CreationException -->
  <class name="CreationException" extends="java.lang.RuntimeException"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="CreationException" type="java.util.Collection&lt;com.google.inject.spi.Message&gt;"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a CreationException containing {@code messages}.]]>
      </doc>
    </constructor>
    <method name="getErrorMessages" return="java.util.Collection&lt;com.google.inject.spi.Message&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns messages for the errors that caused this exception.]]>
      </doc>
    </method>
    <method name="getMessage" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Thrown when errors occur while creating a {@link Injector}. Includes a list of encountered
 errors. Clients should catch this exception, log it, and stop execution.

 @author crazybob@google.com (Bob Lee)]]>
    </doc>
  </class>
  <!-- end class com.google.inject.CreationException -->
  <!-- start class com.google.inject.Exposed -->
  <class name="Exposed"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.lang.annotation.Annotation"/>
    <doc>
    <![CDATA[Acccompanies a {@literal @}{@link com.google.inject.Provides Provides} method annotation in a
 private module to indicate that the provided binding is exposed.

 @author jessewilson@google.com (Jesse Wilson)
 @since 2.0]]>
    </doc>
  </class>
  <!-- end class com.google.inject.Exposed -->
  <!-- start class com.google.inject.Guice -->
  <class name="Guice" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="createInjector" return="com.google.inject.Injector"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="modules" type="com.google.inject.Module[]"/>
      <doc>
      <![CDATA[Creates an injector for the given set of modules.

 @throws CreationException if one or more errors occur during injector
     construction]]>
      </doc>
    </method>
    <method name="createInjector" return="com.google.inject.Injector"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="modules" type="java.lang.Iterable&lt;? extends com.google.inject.Module&gt;"/>
      <doc>
      <![CDATA[Creates an injector for the given set of modules.

 @throws CreationException if one or more errors occur during injector
     creation]]>
      </doc>
    </method>
    <method name="createInjector" return="com.google.inject.Injector"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="stage" type="com.google.inject.Stage"/>
      <param name="modules" type="com.google.inject.Module[]"/>
      <doc>
      <![CDATA[Creates an injector for the given set of modules, in a given development
 stage.

 @throws CreationException if one or more errors occur during injector
     creation.]]>
      </doc>
    </method>
    <method name="createInjector" return="com.google.inject.Injector"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="stage" type="com.google.inject.Stage"/>
      <param name="modules" type="java.lang.Iterable&lt;? extends com.google.inject.Module&gt;"/>
      <doc>
      <![CDATA[Creates an injector for the given set of modules, in a given development
 stage.

 @throws CreationException if one or more errors occur during injector
     construction]]>
      </doc>
    </method>
    <doc>
    <![CDATA[The entry point to the Guice framework. Creates {@link Injector}s from
 {@link Module}s.

 <p>Guice supports a model of development that draws clear boundaries between
 APIs, Implementations of these APIs, Modules which configure these
 implementations, and finally Applications which consist of a collection of
 Modules. It is the Application, which typically defines your {@code main()}
 method, that bootstraps the Guice Injector using the {@code Guice} class, as
 in this example:
 <pre>
     public class FooApplication {
       public static void main(String[] args) {
         Injector injector = Guice.createInjector(
             new ModuleA(),
             new ModuleB(),
             . . .
             new FooApplicationFlagsModule(args)
         );

         // Now just bootstrap the application and you're done
         FooStarter starter = injector.getInstance(FooStarter.class);
         starter.runApplication();
       }
     }
 </pre>]]>
    </doc>
  </class>
  <!-- end class com.google.inject.Guice -->
  <!-- start class com.google.inject.ImplementedBy -->
  <class name="ImplementedBy"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.lang.annotation.Annotation"/>
    <doc>
    <![CDATA[A pointer to the default implementation of a type.

 @author crazybob@google.com (Bob Lee)]]>
    </doc>
  </class>
  <!-- end class com.google.inject.ImplementedBy -->
  <!-- start class com.google.inject.Inject -->
  <class name="Inject"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.lang.annotation.Annotation"/>
    <doc>
    <![CDATA[Annotates members of your implementation class (constructors, methods
 and fields) into which the {@link Injector} should inject values.
 The Injector fulfills injection requests for:

 <ul>
 <li>Every instance it constructs. The class being constructed must have
 exactly one of its constructors marked with {@code @Inject} or must have a
 constructor taking no parameters. The Injector then proceeds to perform
 method and field injections.
 
 <li>Pre-constructed instances passed to {@link Injector#injectMembers},
 {@link com.google.inject.binder.LinkedBindingBuilder#toInstance(Object)} and
 {@link com.google.inject.binder.LinkedBindingBuilder#toProvider(Provider)}.
 In this case all constructors are, of course, ignored.

 <li>Static fields and methods of classes which any {@link Module} has
 specifically requested static injection for, using
 {@link Binder#requestStaticInjection}.
 </ul>

 In all cases, a member can be injected regardless of its Java access
 specifier (private, default, protected, public).

 @author crazybob@google.com (Bob Lee)]]>
    </doc>
  </class>
  <!-- end class com.google.inject.Inject -->
  <!-- start interface com.google.inject.Injector -->
  <interface name="Injector"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="injectMembers"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="instance" type="java.lang.Object"/>
      <doc>
      <![CDATA[Injects dependencies into the fields and methods of {@code instance}. Ignores the presence or
 absence of an injectable constructor.

 <p>Whenever Guice creates an instance, it performs this injection automatically (after first
 performing constructor injection), so if you're able to let Guice create all your objects for
 you, you'll never need to use this method.

 @param instance to inject members on

 @see Binder#getMembersInjector(Class) for a preferred alternative that supports checks before
  run time]]>
      </doc>
    </method>
    <method name="getMembersInjector" return="com.google.inject.MembersInjector&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="typeLiteral" type="com.google.inject.TypeLiteral&lt;T&gt;"/>
      <doc>
      <![CDATA[Returns the members injector used to inject dependencies into methods and fields on instances
 of the given type {@code T}.

 @param typeLiteral type to get members injector for
 @see Binder#getMembersInjector(TypeLiteral) for an alternative that offers up front error
  detection
 @since 2.0]]>
      </doc>
    </method>
    <method name="getMembersInjector" return="com.google.inject.MembersInjector&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="java.lang.Class&lt;T&gt;"/>
      <doc>
      <![CDATA[Returns the members injector used to inject dependencies into methods and fields on instances
 of the given type {@code T}. When feasible, use {@link Binder#getMembersInjector(TypeLiteral)}
 instead to get increased up front error detection.

 @param type type to get members injector for
 @see Binder#getMembersInjector(Class) for an alternative that offers up front error
  detection
 @since 2.0]]>
      </doc>
    </method>
    <method name="getBindings" return="java.util.Map&lt;com.google.inject.Key&lt;?&gt;, com.google.inject.Binding&lt;?&gt;&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns this injector's <strong>explicit</strong> bindings.

 <p>The returned map does not include bindings inherited from a {@link #getParent() parent
 injector}, should one exist. The returned map is guaranteed to iterate (for example, with
 its {@link Map#entrySet()} iterator) in the order of insertion. In other words, the order in
 which bindings appear in user Modules.

 <p>This method is part of the Guice SPI and is intended for use by tools and extensions.]]>
      </doc>
    </method>
    <method name="getAllBindings" return="java.util.Map&lt;com.google.inject.Key&lt;?&gt;, com.google.inject.Binding&lt;?&gt;&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a snapshot of this injector's bindings, <strong>both explicit and
 just-in-time</strong>. The returned map is immutable; it contains only the bindings that were
 present when {@code getAllBindings()} was invoked. Subsequent calls may return a map with
 additional just-in-time bindings.

 <p>The returned map does not include bindings inherited from a {@link #getParent() parent
 injector}, should one exist.

 <p>This method is part of the Guice SPI and is intended for use by tools and extensions.
 
 @since 3.0]]>
      </doc>
    </method>
    <method name="getBinding" return="com.google.inject.Binding&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="com.google.inject.Key&lt;T&gt;"/>
      <doc>
      <![CDATA[Returns the binding for the given injection key. This will be an explicit bindings if the key
 was bound explicitly by a module, or an implicit binding otherwise. The implicit binding will
 be created if necessary.

 <p>This method is part of the Guice SPI and is intended for use by tools and extensions.

 @throws ConfigurationException if this injector cannot find or create the binding.]]>
      </doc>
    </method>
    <method name="getBinding" return="com.google.inject.Binding&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="java.lang.Class&lt;T&gt;"/>
      <doc>
      <![CDATA[Returns the binding for the given type. This will be an explicit bindings if the injection key
 was bound explicitly by a module, or an implicit binding otherwise. The implicit binding will
 be created if necessary.

 <p>This method is part of the Guice SPI and is intended for use by tools and extensions.

 @throws ConfigurationException if this injector cannot find or create the binding.
 @since 2.0]]>
      </doc>
    </method>
    <method name="getExistingBinding" return="com.google.inject.Binding&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="com.google.inject.Key&lt;T&gt;"/>
      <doc>
      <![CDATA[Returns the binding if it already exists, or null if does not exist. Unlike
 {@link #getBinding(Key)}, this does not attempt to create just-in-time bindings
 for keys that aren't bound.
 
 <p> This method is part of the Guice SPI and is intended for use by tools and extensions.
 
 @since 3.0]]>
      </doc>
    </method>
    <method name="findBindingsByType" return="java.util.List&lt;com.google.inject.Binding&lt;T&gt;&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="com.google.inject.TypeLiteral&lt;T&gt;"/>
      <doc>
      <![CDATA[Returns all explicit bindings for {@code type}.

 <p>This method is part of the Guice SPI and is intended for use by tools and extensions.]]>
      </doc>
    </method>
    <method name="getProvider" return="com.google.inject.Provider&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="com.google.inject.Key&lt;T&gt;"/>
      <doc>
      <![CDATA[Returns the provider used to obtain instances for the given injection key. When feasible, avoid
 using this method, in favor of having Guice inject your dependencies ahead of time.

 @throws ConfigurationException if this injector cannot find or create the provider.
 @see Binder#getProvider(Key) for an alternative that offers up front error detection]]>
      </doc>
    </method>
    <method name="getProvider" return="com.google.inject.Provider&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="java.lang.Class&lt;T&gt;"/>
      <doc>
      <![CDATA[Returns the provider used to obtain instances for the given type. When feasible, avoid
 using this method, in favor of having Guice inject your dependencies ahead of time.

 @throws ConfigurationException if this injector cannot find or create the provider.
 @see Binder#getProvider(Class) for an alternative that offers up front error detection]]>
      </doc>
    </method>
    <method name="getInstance" return="T"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="com.google.inject.Key&lt;T&gt;"/>
      <doc>
      <![CDATA[Returns the appropriate instance for the given injection key; equivalent to {@code
 getProvider(key).get()}. When feasible, avoid using this method, in favor of having Guice
 inject your dependencies ahead of time.

 @throws ConfigurationException if this injector cannot find or create the provider.
 @throws ProvisionException if there was a runtime failure while providing an instance.]]>
      </doc>
    </method>
    <method name="getInstance" return="T"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="java.lang.Class&lt;T&gt;"/>
      <doc>
      <![CDATA[Returns the appropriate instance for the given injection type; equivalent to {@code
 getProvider(type).get()}. When feasible, avoid using this method, in favor of having Guice
 inject your dependencies ahead of time.

 @throws ConfigurationException if this injector cannot find or create the provider.
 @throws ProvisionException if there was a runtime failure while providing an instance.]]>
      </doc>
    </method>
    <method name="getParent" return="com.google.inject.Injector"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns this injector's parent, or {@code null} if this is a top-level injector.

 @since 2.0]]>
      </doc>
    </method>
    <method name="createChildInjector" return="com.google.inject.Injector"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="modules" type="java.lang.Iterable&lt;? extends com.google.inject.Module&gt;"/>
      <doc>
      <![CDATA[Returns a new injector that inherits all state from this injector. All bindings, scopes,
 interceptors and type converters are inherited -- they are visible to the child injector.
 Elements of the child injector are not visible to its parent.

 <p>Just-in-time bindings created for child injectors will be created in an ancestor injector
 whenever possible. This allows for scoped instances to be shared between injectors. Use
 explicit bindings to prevent bindings from being shared with the parent injector.  Optional
 injections in just-in-time bindings (created in the parent injector) may be silently
 ignored if the optional dependencies are from the child injector.

 <p>No key may be bound by both an injector and one of its ancestors. This includes just-in-time
 bindings. The lone exception is the key for {@code Injector.class}, which is bound by each
 injector to itself.

 @since 2.0]]>
      </doc>
    </method>
    <method name="createChildInjector" return="com.google.inject.Injector"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="modules" type="com.google.inject.Module[]"/>
      <doc>
      <![CDATA[Returns a new injector that inherits all state from this injector. All bindings, scopes,
 interceptors and type converters are inherited -- they are visible to the child injector.
 Elements of the child injector are not visible to its parent.

 <p>Just-in-time bindings created for child injectors will be created in an ancestor injector
 whenever possible. This allows for scoped instances to be shared between injectors. Use
 explicit bindings to prevent bindings from being shared with the parent injector.

 <p>No key may be bound by both an injector and one of its ancestors. This includes just-in-time
 bindings. The lone exception is the key for {@code Injector.class}, which is bound by each
 injector to itself.

 @since 2.0]]>
      </doc>
    </method>
    <method name="getScopeBindings" return="java.util.Map&lt;java.lang.Class&lt;? extends java.lang.annotation.Annotation&gt;, com.google.inject.Scope&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a map containing all scopes in the injector. The maps keys are scoping annotations
 like {@code Singleton.class}, and the values are scope instances, such as {@code
 Scopes.SINGLETON}. The returned map is immutable.

 <p>This method is part of the Guice SPI and is intended for use by tools and extensions.
 
 @since 3.0]]>
      </doc>
    </method>
    <method name="getTypeConverterBindings" return="java.util.Set&lt;com.google.inject.spi.TypeConverterBinding&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a set containing all type converter bindings in the injector. The returned set is
 immutable.

 <p>This method is part of the Guice SPI and is intended for use by tools and extensions.
 
 @since 3.0]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Builds the graphs of objects that make up your application. The injector tracks the dependencies
 for each type and uses bindings to inject them. This is the core of Guice, although you rarely
 interact with it directly. This "behind-the-scenes" operation is what distinguishes dependency
 injection from its cousin, the service locator pattern.

 <p>Contains several default bindings:

 <ul>
 <li>This {@link Injector} instance itself
 <li>A {@code Provider<T>} for each binding of type {@code T}
 <li>The {@link java.util.logging.Logger} for the class being injected
 <li>The {@link Stage} in which the Injector was created
 </ul>

 Injectors are created using the facade class {@link Guice}.

 <p>An injector can also {@link #injectMembers(Object) inject the dependencies} of
 already-constructed instances. This can be used to interoperate with objects created by other
 frameworks or services.

 <p>Injectors can be {@link #createChildInjector(Iterable) hierarchical}. Child injectors inherit
 the configuration of their parent injectors, but the converse does not hold.

 <p>The injector's {@link #getBindings() internal bindings} are available for introspection. This
 enables tools and extensions to operate on an injector reflectively.

 @author crazybob@google.com (Bob Lee)
 @author jessewilson@google.com (Jesse Wilson)]]>
    </doc>
  </interface>
  <!-- end interface com.google.inject.Injector -->
  <!-- start class com.google.inject.Key -->
  <class name="Key" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="Key" type="java.lang.Class&lt;? extends java.lang.annotation.Annotation&gt;"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a new key. Derives the type from this class's type parameter.

 <p>Clients create an empty anonymous subclass. Doing so embeds the type
 parameter in the anonymous class's type hierarchy so we can reconstitute it
 at runtime despite erasure.

 <p>Example usage for a binding of type {@code Foo} annotated with
 {@code @Bar}:

 <p>{@code new Key<Foo>(Bar.class) {}}.]]>
      </doc>
    </constructor>
    <constructor name="Key" type="java.lang.annotation.Annotation"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a new key. Derives the type from this class's type parameter.

 <p>Clients create an empty anonymous subclass. Doing so embeds the type
 parameter in the anonymous class's type hierarchy so we can reconstitute it
 at runtime despite erasure.

 <p>Example usage for a binding of type {@code Foo} annotated with
 {@code @Bar}:

 <p>{@code new Key<Foo>(new Bar()) {}}.]]>
      </doc>
    </constructor>
    <constructor name="Key"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a new key. Derives the type from this class's type parameter.

 <p>Clients create an empty anonymous subclass. Doing so embeds the type
 parameter in the anonymous class's type hierarchy so we can reconstitute it
 at runtime despite erasure.

 <p>Example usage for a binding of type {@code Foo}:

 <p>{@code new Key<Foo>() {}}.]]>
      </doc>
    </constructor>
    <method name="getTypeLiteral" return="com.google.inject.TypeLiteral&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the key type.]]>
      </doc>
    </method>
    <method name="getAnnotationType" return="java.lang.Class&lt;? extends java.lang.annotation.Annotation&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the annotation type.]]>
      </doc>
    </method>
    <method name="getAnnotation" return="java.lang.annotation.Annotation"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the annotation.]]>
      </doc>
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="o" type="java.lang.Object"/>
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="get" return="com.google.inject.Key&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="java.lang.Class&lt;T&gt;"/>
      <doc>
      <![CDATA[Gets a key for an injection type.]]>
      </doc>
    </method>
    <method name="get" return="com.google.inject.Key&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="java.lang.Class&lt;T&gt;"/>
      <param name="annotationType" type="java.lang.Class&lt;? extends java.lang.annotation.Annotation&gt;"/>
      <doc>
      <![CDATA[Gets a key for an injection type and an annotation type.]]>
      </doc>
    </method>
    <method name="get" return="com.google.inject.Key&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="java.lang.Class&lt;T&gt;"/>
      <param name="annotation" type="java.lang.annotation.Annotation"/>
      <doc>
      <![CDATA[Gets a key for an injection type and an annotation.]]>
      </doc>
    </method>
    <method name="get" return="com.google.inject.Key&lt;?&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="java.lang.reflect.Type"/>
      <doc>
      <![CDATA[Gets a key for an injection type.]]>
      </doc>
    </method>
    <method name="get" return="com.google.inject.Key&lt;?&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="java.lang.reflect.Type"/>
      <param name="annotationType" type="java.lang.Class&lt;? extends java.lang.annotation.Annotation&gt;"/>
      <doc>
      <![CDATA[Gets a key for an injection type and an annotation type.]]>
      </doc>
    </method>
    <method name="get" return="com.google.inject.Key&lt;?&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="java.lang.reflect.Type"/>
      <param name="annotation" type="java.lang.annotation.Annotation"/>
      <doc>
      <![CDATA[Gets a key for an injection type and an annotation.]]>
      </doc>
    </method>
    <method name="get" return="com.google.inject.Key&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="typeLiteral" type="com.google.inject.TypeLiteral&lt;T&gt;"/>
      <doc>
      <![CDATA[Gets a key for an injection type.]]>
      </doc>
    </method>
    <method name="get" return="com.google.inject.Key&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="typeLiteral" type="com.google.inject.TypeLiteral&lt;T&gt;"/>
      <param name="annotationType" type="java.lang.Class&lt;? extends java.lang.annotation.Annotation&gt;"/>
      <doc>
      <![CDATA[Gets a key for an injection type and an annotation type.]]>
      </doc>
    </method>
    <method name="get" return="com.google.inject.Key&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="typeLiteral" type="com.google.inject.TypeLiteral&lt;T&gt;"/>
      <param name="annotation" type="java.lang.annotation.Annotation"/>
      <doc>
      <![CDATA[Gets a key for an injection type and an annotation.]]>
      </doc>
    </method>
    <method name="ofType" return="com.google.inject.Key&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="java.lang.Class&lt;T&gt;"/>
      <doc>
      <![CDATA[Returns a new key of the specified type with the same annotation as this
 key.
 
 @since 3.0]]>
      </doc>
    </method>
    <method name="ofType" return="com.google.inject.Key&lt;?&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="java.lang.reflect.Type"/>
      <doc>
      <![CDATA[Returns a new key of the specified type with the same annotation as this
 key.
 
 @since 3.0]]>
      </doc>
    </method>
    <method name="ofType" return="com.google.inject.Key&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="com.google.inject.TypeLiteral&lt;T&gt;"/>
      <doc>
      <![CDATA[Returns a new key of the specified type with the same annotation as this
 key.
 
 @since 3.0]]>
      </doc>
    </method>
    <method name="hasAttributes" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns true if this key has annotation attributes.
 
 @since 3.0]]>
      </doc>
    </method>
    <method name="withoutAttributes" return="com.google.inject.Key&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns this key without annotation attributes, i.e. with only the
 annotation type.
 
 @since 3.0]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Binding key consisting of an injection type and an optional annotation.
 Matches the type and annotation at a point of injection.

 <p>For example, {@code Key.get(Service.class, Transactional.class)} will
 match:

 <pre>
   {@literal @}Inject
   public void setService({@literal @}Transactional Service service) {
     ...
   }
 </pre>

 <p>{@code Key} supports generic types via subclassing just like {@link
 TypeLiteral}.

 <p>Keys do not differentiate between primitive types (int, char, etc.) and
 their correpsonding wrapper types (Integer, Character, etc.). Primitive
 types will be replaced with their wrapper types when keys are created.

 @author crazybob@google.com (Bob Lee)]]>
    </doc>
  </class>
  <!-- end class com.google.inject.Key -->
  <!-- start interface com.google.inject.MembersInjector -->
  <interface name="MembersInjector"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="injectMembers"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="instance" type="T"/>
      <doc>
      <![CDATA[Injects dependencies into the fields and methods of {@code instance}. Ignores the presence or
 absence of an injectable constructor.

 <p>Whenever Guice creates an instance, it performs this injection automatically (after first
 performing constructor injection), so if you're able to let Guice create all your objects for
 you, you'll never need to use this method.

 @param instance to inject members on. May be {@code null}.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Injects dependencies into the fields and methods on instances of type {@code T}. Ignores the
 presence or absence of an injectable constructor.

 @param <T> type to inject members of

 @author crazybob@google.com (Bob Lee)
 @author jessewilson@google.com (Jesse Wilson)
 @since 2.0]]>
    </doc>
  </interface>
  <!-- end interface com.google.inject.MembersInjector -->
  <!-- start interface com.google.inject.Module -->
  <interface name="Module"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="configure"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="binder" type="com.google.inject.Binder"/>
      <doc>
      <![CDATA[Contributes bindings and other configurations for this module to {@code binder}.

 <p><strong>Do not invoke this method directly</strong> to install submodules. Instead use
 {@link Binder#install(Module)}, which ensures that {@link Provides provider methods} are
 discovered.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A module contributes configuration information, typically interface
 bindings, which will be used to create an {@link Injector}. A Guice-based
 application is ultimately composed of little more than a set of
 {@code Module}s and some bootstrapping code.

 <p>Your Module classes can use a more streamlined syntax by extending
 {@link AbstractModule} rather than implementing this interface directly.

 <p>In addition to the bindings configured via {@link #configure}, bindings
 will be created for all methods annotated with {@literal @}{@link Provides}.
 Use scope and binding annotations on these methods to configure the
 bindings.]]>
    </doc>
  </interface>
  <!-- end interface com.google.inject.Module -->
  <!-- start class com.google.inject.OutOfScopeException -->
  <class name="OutOfScopeException" extends="java.lang.RuntimeException"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="OutOfScopeException" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="OutOfScopeException" type="java.lang.String, java.lang.Throwable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="OutOfScopeException" type="java.lang.Throwable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <doc>
    <![CDATA[Thrown from {@link Provider#get} when an attempt is made to access a scoped
 object while the scope in question is not currently active.

 @author kevinb@google.com (Kevin Bourrillion)
 @since 2.0]]>
    </doc>
  </class>
  <!-- end class com.google.inject.OutOfScopeException -->
  <!-- start interface com.google.inject.PrivateBinder -->
  <interface name="PrivateBinder"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.inject.Binder"/>
    <method name="expose"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="com.google.inject.Key&lt;?&gt;"/>
      <doc>
      <![CDATA[Makes the binding for {@code key} available to the enclosing environment]]>
      </doc>
    </method>
    <method name="expose" return="com.google.inject.binder.AnnotatedElementBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="java.lang.Class&lt;?&gt;"/>
      <doc>
      <![CDATA[Makes a binding for {@code type} available to the enclosing environment. Use {@link
 com.google.inject.binder.AnnotatedElementBuilder#annotatedWith(Class) annotatedWith()} to expose {@code type} with a
 binding annotation.]]>
      </doc>
    </method>
    <method name="expose" return="com.google.inject.binder.AnnotatedElementBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="com.google.inject.TypeLiteral&lt;?&gt;"/>
      <doc>
      <![CDATA[Makes a binding for {@code type} available to the enclosing environment. Use {@link
 AnnotatedElementBuilder#annotatedWith(Class) annotatedWith()} to expose {@code type} with a
 binding annotation.]]>
      </doc>
    </method>
    <method name="withSource" return="com.google.inject.PrivateBinder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="source" type="java.lang.Object"/>
    </method>
    <method name="skipSources" return="com.google.inject.PrivateBinder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="classesToSkip" type="java.lang.Class[]"/>
    </method>
    <doc>
    <![CDATA[Returns a binder whose configuration information is hidden from its environment by default. See
 {@link com.google.inject.PrivateModule PrivateModule} for details.
 
 @author jessewilson@google.com (Jesse Wilson)
 @since 2.0]]>
    </doc>
  </interface>
  <!-- end interface com.google.inject.PrivateBinder -->
  <!-- start class com.google.inject.PrivateModule -->
  <class name="PrivateModule" extends="java.lang.Object"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.inject.Module"/>
    <constructor name="PrivateModule"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="configure"
      abstract="false" native="false" synchronized="true"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="binder" type="com.google.inject.Binder"/>
    </method>
    <method name="configure"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates bindings and other configurations private to this module. Use {@link #expose(Class)
 expose()} to make the bindings in this module available externally.]]>
      </doc>
    </method>
    <method name="expose"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="protected"
      deprecated="not deprecated">
      <param name="key" type="com.google.inject.Key&lt;T&gt;"/>
      <doc>
      <![CDATA[Makes the binding for {@code key} available to other modules and the injector.]]>
      </doc>
    </method>
    <method name="expose" return="com.google.inject.binder.AnnotatedElementBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="protected"
      deprecated="not deprecated">
      <param name="type" type="java.lang.Class&lt;?&gt;"/>
      <doc>
      <![CDATA[Makes a binding for {@code type} available to other modules and the injector. Use {@link
 AnnotatedElementBuilder#annotatedWith(Class) annotatedWith()} to expose {@code type} with a
 binding annotation.]]>
      </doc>
    </method>
    <method name="expose" return="com.google.inject.binder.AnnotatedElementBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="protected"
      deprecated="not deprecated">
      <param name="type" type="com.google.inject.TypeLiteral&lt;?&gt;"/>
      <doc>
      <![CDATA[Makes a binding for {@code type} available to other modules and the injector. Use {@link
 AnnotatedElementBuilder#annotatedWith(Class) annotatedWith()} to expose {@code type} with a
 binding annotation.]]>
      </doc>
    </method>
    <method name="binder" return="com.google.inject.PrivateBinder"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the current binder.]]>
      </doc>
    </method>
    <method name="bindScope"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="protected"
      deprecated="not deprecated">
      <param name="scopeAnnotation" type="java.lang.Class&lt;? extends java.lang.annotation.Annotation&gt;"/>
      <param name="scope" type="com.google.inject.Scope"/>
      <doc>
      <![CDATA[@see Binder#bindScope(Class, Scope)]]>
      </doc>
    </method>
    <method name="bind" return="com.google.inject.binder.LinkedBindingBuilder&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="protected"
      deprecated="not deprecated">
      <param name="key" type="com.google.inject.Key&lt;T&gt;"/>
      <doc>
      <![CDATA[@see Binder#bind(Key)]]>
      </doc>
    </method>
    <method name="bind" return="com.google.inject.binder.AnnotatedBindingBuilder&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="protected"
      deprecated="not deprecated">
      <param name="typeLiteral" type="com.google.inject.TypeLiteral&lt;T&gt;"/>
      <doc>
      <![CDATA[@see Binder#bind(TypeLiteral)]]>
      </doc>
    </method>
    <method name="bind" return="com.google.inject.binder.AnnotatedBindingBuilder&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="protected"
      deprecated="not deprecated">
      <param name="clazz" type="java.lang.Class&lt;T&gt;"/>
      <doc>
      <![CDATA[@see Binder#bind(Class)]]>
      </doc>
    </method>
    <method name="bindConstant" return="com.google.inject.binder.AnnotatedConstantBindingBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@see Binder#bindConstant()]]>
      </doc>
    </method>
    <method name="install"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="protected"
      deprecated="not deprecated">
      <param name="module" type="com.google.inject.Module"/>
      <doc>
      <![CDATA[@see Binder#install(Module)]]>
      </doc>
    </method>
    <method name="addError"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="protected"
      deprecated="not deprecated">
      <param name="message" type="java.lang.String"/>
      <param name="arguments" type="java.lang.Object[]"/>
      <doc>
      <![CDATA[@see Binder#addError(String, Object[])]]>
      </doc>
    </method>
    <method name="addError"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="protected"
      deprecated="not deprecated">
      <param name="t" type="java.lang.Throwable"/>
      <doc>
      <![CDATA[@see Binder#addError(Throwable)]]>
      </doc>
    </method>
    <method name="addError"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="protected"
      deprecated="not deprecated">
      <param name="message" type="com.google.inject.spi.Message"/>
      <doc>
      <![CDATA[@see Binder#addError(Message)]]>
      </doc>
    </method>
    <method name="requestInjection"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="protected"
      deprecated="not deprecated">
      <param name="instance" type="java.lang.Object"/>
      <doc>
      <![CDATA[@see Binder#requestInjection(Object)]]>
      </doc>
    </method>
    <method name="requestStaticInjection"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="protected"
      deprecated="not deprecated">
      <param name="types" type="java.lang.Class[]"/>
      <doc>
      <![CDATA[@see Binder#requestStaticInjection(Class[])]]>
      </doc>
    </method>
    <method name="bindInterceptor"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="protected"
      deprecated="not deprecated">
      <param name="classMatcher" type="com.google.inject.matcher.Matcher&lt;? super java.lang.Class&lt;?&gt;&gt;"/>
      <param name="methodMatcher" type="com.google.inject.matcher.Matcher&lt;? super java.lang.reflect.Method&gt;"/>
      <param name="interceptors" type="org.aopalliance.intercept.MethodInterceptor[]"/>
      <doc>
      <![CDATA[@see Binder#bindInterceptor(com.google.inject.matcher.Matcher, com.google.inject.matcher.Matcher, org.aopalliance.intercept.MethodInterceptor[])]]>
      </doc>
    </method>
    <method name="requireBinding"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="protected"
      deprecated="not deprecated">
      <param name="key" type="com.google.inject.Key&lt;?&gt;"/>
      <doc>
      <![CDATA[Instructs Guice to require a binding to the given key.]]>
      </doc>
    </method>
    <method name="requireBinding"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="protected"
      deprecated="not deprecated">
      <param name="type" type="java.lang.Class&lt;?&gt;"/>
      <doc>
      <![CDATA[Instructs Guice to require a binding to the given type.]]>
      </doc>
    </method>
    <method name="getProvider" return="com.google.inject.Provider&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="protected"
      deprecated="not deprecated">
      <param name="key" type="com.google.inject.Key&lt;T&gt;"/>
      <doc>
      <![CDATA[@see Binder#getProvider(Key)]]>
      </doc>
    </method>
    <method name="getProvider" return="com.google.inject.Provider&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="protected"
      deprecated="not deprecated">
      <param name="type" type="java.lang.Class&lt;T&gt;"/>
      <doc>
      <![CDATA[@see Binder#getProvider(Class)]]>
      </doc>
    </method>
    <method name="convertToTypes"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="protected"
      deprecated="not deprecated">
      <param name="typeMatcher" type="com.google.inject.matcher.Matcher&lt;? super com.google.inject.TypeLiteral&lt;?&gt;&gt;"/>
      <param name="converter" type="com.google.inject.spi.TypeConverter"/>
      <doc>
      <![CDATA[@see Binder#convertToTypes(com.google.inject.matcher.Matcher, com.google.inject.spi.TypeConverter)]]>
      </doc>
    </method>
    <method name="currentStage" return="com.google.inject.Stage"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@see Binder#currentStage()]]>
      </doc>
    </method>
    <method name="getMembersInjector" return="com.google.inject.MembersInjector&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="type" type="java.lang.Class&lt;T&gt;"/>
      <doc>
      <![CDATA[@see Binder#getMembersInjector(Class)]]>
      </doc>
    </method>
    <method name="getMembersInjector" return="com.google.inject.MembersInjector&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="type" type="com.google.inject.TypeLiteral&lt;T&gt;"/>
      <doc>
      <![CDATA[@see Binder#getMembersInjector(TypeLiteral)]]>
      </doc>
    </method>
    <method name="bindListener"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="typeMatcher" type="com.google.inject.matcher.Matcher&lt;? super com.google.inject.TypeLiteral&lt;?&gt;&gt;"/>
      <param name="listener" type="com.google.inject.spi.TypeListener"/>
      <doc>
      <![CDATA[@see Binder#bindListener(com.google.inject.matcher.Matcher, com.google.inject.spi.TypeListener)]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A module whose configuration information is hidden from its environment by default. Only bindings
 that are explicitly exposed will be available to other modules and to the users of the injector.
 This module may expose the bindings it creates and the bindings of the modules it installs.

 <p>A private module can be nested within a regular module or within another private module using
 {@link Binder#install install()}.  Its bindings live in a new environment that inherits bindings,
 type converters, scopes, and interceptors from the surrounding ("parent") environment.  When you
 nest multiple private modules, the result is a tree of environments where the injector's
 environment is the root.

 <p>Guice EDSL bindings can be exposed with {@link #expose(Class) expose()}. {@literal @}{@link
 com.google.inject.Provides Provides} bindings can be exposed with the {@literal @}{@link
 Exposed} annotation:

 <pre>
 public class FooBarBazModule extends PrivateModule {
   protected void configure() {
     bind(Foo.class).to(RealFoo.class);
     expose(Foo.class);

     install(new TransactionalBarModule());
     expose(Bar.class).annotatedWith(Transactional.class);

     bind(SomeImplementationDetail.class);
     install(new MoreImplementationDetailsModule());
   }

   {@literal @}Provides {@literal @}Exposed
   public Baz provideBaz() {
     return new SuperBaz();
   }
 }
 </pre>

 <p>Private modules are implemented using {@link Injector#createChildInjector(Module[]) parent
 injectors}. When it can satisfy their dependencies, just-in-time bindings will be created in the
 root environment. Such bindings are shared among all environments in the tree.
 
 <p>The scope of a binding is constrained to its environment. A singleton bound in a private
 module will be unique to its environment. But a binding for the same type in a different private
 module will yield a different instance.

 <p>A shared binding that injects the {@code Injector} gets the root injector, which only has
 access to bindings in the root environment. An explicit binding that injects the {@code Injector}
 gets access to all bindings in the child environment.

 <p>To promote a just-in-time binding to an explicit binding, bind it:
 <pre>
   bind(FooImpl.class);
 </pre>

 @author jessewilson@google.com (Jesse Wilson)
 @since 2.0]]>
    </doc>
  </class>
  <!-- end class com.google.inject.PrivateModule -->
  <!-- start class com.google.inject.ProvidedBy -->
  <class name="ProvidedBy"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.lang.annotation.Annotation"/>
    <doc>
    <![CDATA[A pointer to the default provider type for a type.

 @author crazybob@google.com (Bob Lee)]]>
    </doc>
  </class>
  <!-- end class com.google.inject.ProvidedBy -->
  <!-- start interface com.google.inject.Provider -->
  <interface name="Provider"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="javax.inject.Provider&lt;T&gt;"/>
    <method name="get" return="T"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Provides an instance of {@code T}. Must never return {@code null}.

 @throws OutOfScopeException when an attempt is made to access a scoped object while the scope
     in question is not currently active
 @throws ProvisionException if an instance cannot be provided. Such exceptions include messages
     and throwables to describe why provision failed.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[An object capable of providing instances of type {@code T}. Providers are used in numerous ways
 by Guice:

 <ul>
 <li>When the default means for obtaining instances (an injectable or parameterless constructor)
 is insufficient for a particular binding, the module can specify a custom {@code Provider}
 instead, to control exactly how Guice creates or obtains instances for the binding.

 <li>An implementation class may always choose to have a {@code Provider<T>} instance injected,
 rather than having a {@code T} injected directly.  This may give you access to multiple
 instances, instances you wish to safely mutate and discard, instances which are out of scope
 (e.g. using a {@code @RequestScoped} object from within a {@code @SessionScoped} object), or
 instances that will be initialized lazily.

 <li>A custom {@link Scope} is implemented as a decorator of {@code Provider<T>}, which decides
 when to delegate to the backing provider and when to provide the instance some other way.

 <li>The {@link Injector} offers access to the {@code Provider<T>} it uses to fulfill requests
 for a given key, via the {@link Injector#getProvider} methods.
 </ul>

 @param <T> the type of object this provides

 @author crazybob@google.com (Bob Lee)]]>
    </doc>
  </interface>
  <!-- end interface com.google.inject.Provider -->
  <!-- start class com.google.inject.Provides -->
  <class name="Provides"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.lang.annotation.Annotation"/>
    <doc>
    <![CDATA[Annotates methods of a {@link Module} to create a provider method binding. The method's return
 type is bound to it's returned value. Guice will pass dependencies to the method as parameters.

 @author crazybob@google.com (Bob Lee)
 @since 2.0]]>
    </doc>
  </class>
  <!-- end class com.google.inject.Provides -->
  <!-- start class com.google.inject.ProvisionException -->
  <class name="ProvisionException" extends="java.lang.RuntimeException"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="ProvisionException" type="java.lang.Iterable&lt;com.google.inject.spi.Message&gt;"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a ProvisionException containing {@code messages}.]]>
      </doc>
    </constructor>
    <constructor name="ProvisionException" type="java.lang.String, java.lang.Throwable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="ProvisionException" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getErrorMessages" return="java.util.Collection&lt;com.google.inject.spi.Message&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns messages for the errors that caused this exception.]]>
      </doc>
    </method>
    <method name="getMessage" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Indicates that there was a runtime failure while providing an instance.

 @author kevinb@google.com (Kevin Bourrillion)
 @author jessewilson@google.com (Jesse Wilson)
 @since 2.0]]>
    </doc>
  </class>
  <!-- end class com.google.inject.ProvisionException -->
  <!-- start interface com.google.inject.Scope -->
  <interface name="Scope"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="scope" return="com.google.inject.Provider&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="com.google.inject.Key&lt;T&gt;"/>
      <param name="unscoped" type="com.google.inject.Provider&lt;T&gt;"/>
      <doc>
      <![CDATA[Scopes a provider. The returned provider returns objects from this scope.
 If an object does not exist in this scope, the provider can use the given
 unscoped provider to retrieve one.

 <p>Scope implementations are strongly encouraged to override
 {@link Object#toString} in the returned provider and include the backing
 provider's {@code toString()} output.

 @param key binding key
 @param unscoped locates an instance when one doesn't already exist in this
  scope.
 @return a new provider which only delegates to the given unscoped provider
  when an instance of the requested object doesn't already exist in this
  scope]]>
      </doc>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[A short but useful description of this scope.  For comparison, the standard
 scopes that ship with guice use the descriptions
 {@code "Scopes.SINGLETON"}, {@code "ServletScopes.SESSION"} and
 {@code "ServletScopes.REQUEST"}.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A scope is a level of visibility that instances provided by Guice may have.
 By default, an instance created by the {@link Injector} has <i>no scope</i>,
 meaning it has no state from the framework's perspective -- the
 {@code Injector} creates it, injects it once into the class that required it,
 and then immediately forgets it. Associating a scope with a particular
 binding allows the created instance to be "remembered" and possibly used
 again for other injections.

 <p>An example of a scope is {@link Scopes#SINGLETON}.

 @author crazybob@google.com (Bob Lee)]]>
    </doc>
  </interface>
  <!-- end interface com.google.inject.Scope -->
  <!-- start class com.google.inject.ScopeAnnotation -->
  <class name="ScopeAnnotation"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.lang.annotation.Annotation"/>
    <doc>
    <![CDATA[Annotates annotations which are used for scoping. Only one such annotation
 may apply to a single implementation class. You must also annotate scope
 annotations with {@code @Retention(RUNTIME)}. For example:

 <pre>
   {@code @}Retention(RUNTIME)
   {@code @}Target(TYPE, METHOD)
   {@code @}ScopeAnnotation
   public {@code @}interface SessionScoped {}
 </pre>

 @author crazybob@google.com (Bob Lee)]]>
    </doc>
  </class>
  <!-- end class com.google.inject.ScopeAnnotation -->
  <!-- start class com.google.inject.Scopes -->
  <class name="Scopes" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="isSingleton" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="binding" type="com.google.inject.Binding&lt;?&gt;"/>
      <doc>
      <![CDATA[Returns true if {@code binding} is singleton-scoped. If the binding is a {@link
 com.google.inject.spi.LinkedKeyBinding linked key binding} and belongs to an injector (ie. it
 was retrieved via {@link Injector#getBinding Injector.getBinding()}), then this method will
 also true if the target binding is singleton-scoped.

 @since 3.0]]>
      </doc>
    </method>
    <field name="SINGLETON" type="com.google.inject.Scope"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[One instance per {@link Injector}. Also see {@code @}{@link Singleton}.]]>
      </doc>
    </field>
    <field name="NO_SCOPE" type="com.google.inject.Scope"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[No scope; the same as not applying any scope at all.  Each time the
 Injector obtains an instance of an object with "no scope", it injects this
 instance then immediately forgets it.  When the next request for the same
 binding arrives it will need to obtain the instance over again.

 <p>This exists only in case a class has been annotated with a scope
 annotation such as {@link Singleton @Singleton}, and you need to override
 this to "no scope" in your binding.

 @since 2.0]]>
      </doc>
    </field>
    <doc>
    <![CDATA[Built-in scope implementations.

 @author crazybob@google.com (Bob Lee)]]>
    </doc>
  </class>
  <!-- end class com.google.inject.Scopes -->
  <!-- start class com.google.inject.Singleton -->
  <class name="Singleton"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.lang.annotation.Annotation"/>
    <doc>
    <![CDATA[Apply this to implementation classes when you want only one instance
 (per {@link Injector}) to be reused for all injections for that binding.

 @author crazybob@google.com (Bob Lee)]]>
    </doc>
  </class>
  <!-- end class com.google.inject.Singleton -->
  <!-- start class com.google.inject.Stage -->
  <class name="Stage" extends="java.lang.Enum&lt;com.google.inject.Stage&gt;"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="values" return="com.google.inject.Stage[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="com.google.inject.Stage"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <doc>
    <![CDATA[The stage we're running in.

 @author crazybob@google.com (Bob Lee)]]>
    </doc>
  </class>
  <!-- end class com.google.inject.Stage -->
  <!-- start class com.google.inject.TypeLiteral -->
  <class name="TypeLiteral" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="TypeLiteral"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a new type literal. Derives represented class from type
 parameter.

 <p>Clients create an empty anonymous subclass. Doing so embeds the type
 parameter in the anonymous class's type hierarchy so we can reconstitute it
 at runtime despite erasure.]]>
      </doc>
    </constructor>
    <method name="getRawType" return="java.lang.Class&lt;? super T&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the raw (non-generic) type for this type.
 
 @since 2.0]]>
      </doc>
    </method>
    <method name="getType" return="java.lang.reflect.Type"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets underlying {@code Type} instance.]]>
      </doc>
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="o" type="java.lang.Object"/>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="get" return="com.google.inject.TypeLiteral&lt;?&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="java.lang.reflect.Type"/>
      <doc>
      <![CDATA[Gets type literal for the given {@code Type} instance.]]>
      </doc>
    </method>
    <method name="get" return="com.google.inject.TypeLiteral&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="java.lang.Class&lt;T&gt;"/>
      <doc>
      <![CDATA[Gets type literal for the given {@code Class} instance.]]>
      </doc>
    </method>
    <method name="getSupertype" return="com.google.inject.TypeLiteral&lt;?&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="supertype" type="java.lang.Class&lt;?&gt;"/>
      <doc>
      <![CDATA[Returns the generic form of {@code supertype}. For example, if this is {@code
 ArrayList<String>}, this returns {@code Iterable<String>} given the input {@code
 Iterable.class}.

 @param supertype a superclass of, or interface implemented by, this.
 @since 2.0]]>
      </doc>
    </method>
    <method name="getFieldType" return="com.google.inject.TypeLiteral&lt;?&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="field" type="java.lang.reflect.Field"/>
      <doc>
      <![CDATA[Returns the resolved generic type of {@code field}.

 @param field a field defined by this or any superclass.
 @since 2.0]]>
      </doc>
    </method>
    <method name="getParameterTypes" return="java.util.List&lt;com.google.inject.TypeLiteral&lt;?&gt;&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="methodOrConstructor" type="java.lang.reflect.Member"/>
      <doc>
      <![CDATA[Returns the resolved generic parameter types of {@code methodOrConstructor}.

 @param methodOrConstructor a method or constructor defined by this or any supertype.
 @since 2.0]]>
      </doc>
    </method>
    <method name="getExceptionTypes" return="java.util.List&lt;com.google.inject.TypeLiteral&lt;?&gt;&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="methodOrConstructor" type="java.lang.reflect.Member"/>
      <doc>
      <![CDATA[Returns the resolved generic exception types thrown by {@code constructor}.

 @param methodOrConstructor a method or constructor defined by this or any supertype.
 @since 2.0]]>
      </doc>
    </method>
    <method name="getReturnType" return="com.google.inject.TypeLiteral&lt;?&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="method" type="java.lang.reflect.Method"/>
      <doc>
      <![CDATA[Returns the resolved generic return type of {@code method}.

 @param method a method defined by this or any supertype.
 @since 2.0]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Represents a generic type {@code T}. Java doesn't yet provide a way to
 represent generic types, so this class does. Forces clients to create a
 subclass of this class which enables retrieval the type information even at
 runtime.

 <p>For example, to create a type literal for {@code List<String>}, you can
 create an empty anonymous inner class:

 <p>
 {@code TypeLiteral<List<String>> list = new TypeLiteral<List<String>>() {};}

 <p>Along with modeling generic types, this class can resolve type parameters.
 For example, to figure out what type {@code keySet()} returns on a {@code
 Map<Integer, String>}, use this code:<pre>   {@code

   TypeLiteral<Map<Integer, String>> mapType
       = new TypeLiteral<Map<Integer, String>>() {};
   TypeLiteral<?> keySetType
       = mapType.getReturnType(Map.class.getMethod("keySet"));
   System.out.println(keySetType); // prints "Set<Integer>"}</pre>

 @author crazybob@google.com (Bob Lee)
 @author jessewilson@google.com (Jesse Wilson)]]>
    </doc>
  </class>
  <!-- end class com.google.inject.TypeLiteral -->
</package>
<package name="com.google.inject.assistedinject">
  <!-- start class com.google.inject.assistedinject.Assisted -->
  <class name="Assisted"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.lang.annotation.Annotation"/>
    <doc>
    <![CDATA[Annotates an injected parameter or field whose value comes from an argument to a factory method.

 @author jmourits@google.com (Jerome Mourits)
 @author jessewilson@google.com (Jesse Wilson)]]>
    </doc>
  </class>
  <!-- end class com.google.inject.assistedinject.Assisted -->
  <!-- start class com.google.inject.assistedinject.AssistedInject -->
  <class name="AssistedInject"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.lang.annotation.Annotation"/>
    <doc>
    <![CDATA[<p>
 When used in tandem with {@link FactoryModuleBuilder}, constructors annotated with 
 {@code @AssistedInject} indicate that multiple constructors can be injected, each with different
 parameters. AssistedInject annotations should not be mixed with {@literal @}{@link Inject}
 annotations. The assisted parameters must exactly match one corresponding factory method within
 the factory interface, but the parameters do not need to be in the same order. Constructors
 annotated with AssistedInject <b>are</b> created by Guice and receive all the benefits
 (such as AOP).
 
 <p>
 <strong>Obsolete Usage:</strong> When used in tandem with {@link FactoryProvider}, constructors
 annotated with {@code @AssistedInject} trigger a "backwards compatibility mode". The assisted
 parameters must exactly match one corresponding factory method within the factory interface and
 all must be in the same order as listed in the factory. In this backwards compatable mode,
 constructors annotated with AssistedInject <b>are not</b> created by Guice and thus receive
 none of the benefits.
 
 <p>
 Constructor parameters must be either supplied by the factory interface and marked with
 <code>@Assisted</code>, or they must be injectable.
 
 @author jmourits@google.com (Jerome Mourits)
 @author jessewilson@google.com (Jesse Wilson)]]>
    </doc>
  </class>
  <!-- end class com.google.inject.assistedinject.AssistedInject -->
  <!-- start interface com.google.inject.assistedinject.AssistedInjectBinding -->
  <interface name="AssistedInjectBinding"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="getKey" return="com.google.inject.Key&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the {@link Key} for the factory binding.]]>
      </doc>
    </method>
    <method name="getAssistedMethods" return="java.util.Collection&lt;com.google.inject.assistedinject.AssistedMethod&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns an {@link AssistedMethod} for each method in the factory.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A binding for a factory created by FactoryModuleBuilder.
 
 @param <T> The fully qualified type of the factory.
  
 @since 3.0
 @author ramakrishna@google.com (Ramakrishna Rajanna)]]>
    </doc>
  </interface>
  <!-- end interface com.google.inject.assistedinject.AssistedInjectBinding -->
  <!-- start interface com.google.inject.assistedinject.AssistedInjectTargetVisitor -->
  <interface name="AssistedInjectTargetVisitor"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.inject.spi.BindingTargetVisitor&lt;T, V&gt;"/>
    <method name="visit" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="assistedInjectBinding" type="com.google.inject.assistedinject.AssistedInjectBinding&lt;? extends T&gt;"/>
      <doc>
      <![CDATA[Visits an {@link AssistedInjectBinding} created through {@link FactoryModuleBuilder}.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A visitor for the AssistedInject extension.
 <p>
 If your {@link BindingTargetVisitor} implements this interface, bindings created by using
 {@link FactoryModuleBuilder} will be visited through this interface.

 @since 3.0
 @author ramakrishna@google.com (Ramakrishna Rajanna)]]>
    </doc>
  </interface>
  <!-- end interface com.google.inject.assistedinject.AssistedInjectTargetVisitor -->
  <!-- start interface com.google.inject.assistedinject.AssistedMethod -->
  <interface name="AssistedMethod"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="getFactoryMethod" return="java.lang.reflect.Method"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the factory method that is being assisted.]]>
      </doc>
    </method>
    <method name="getImplementationType" return="com.google.inject.TypeLiteral&lt;?&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the implementation type that will be created when the method is
 used.]]>
      </doc>
    </method>
    <method name="getImplementationConstructor" return="java.lang.reflect.Constructor&lt;?&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the constructor that will be used to construct instances of the 
 implementation.]]>
      </doc>
    </method>
    <method name="getDependencies" return="java.util.Set&lt;com.google.inject.spi.Dependency&lt;?&gt;&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns all non-assisted dependencies required to construct and inject
 the implementation.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Details about how a method in an assisted inject factory will be assisted.
 
 @since 3.0
 @author ramakrishna@google.com (Ramakrishna Rajanna)]]>
    </doc>
  </interface>
  <!-- end interface com.google.inject.assistedinject.AssistedMethod -->
  <!-- start class com.google.inject.assistedinject.FactoryModuleBuilder -->
  <class name="FactoryModuleBuilder" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="FactoryModuleBuilder"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="implement" return="com.google.inject.assistedinject.FactoryModuleBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="source" type="java.lang.Class&lt;T&gt;"/>
      <param name="target" type="java.lang.Class&lt;? extends T&gt;"/>
      <doc>
      <![CDATA[See the factory configuration examples at {@link FactoryModuleBuilder}.]]>
      </doc>
    </method>
    <method name="implement" return="com.google.inject.assistedinject.FactoryModuleBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="source" type="java.lang.Class&lt;T&gt;"/>
      <param name="target" type="com.google.inject.TypeLiteral&lt;? extends T&gt;"/>
      <doc>
      <![CDATA[See the factory configuration examples at {@link FactoryModuleBuilder}.]]>
      </doc>
    </method>
    <method name="implement" return="com.google.inject.assistedinject.FactoryModuleBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="source" type="com.google.inject.TypeLiteral&lt;T&gt;"/>
      <param name="target" type="java.lang.Class&lt;? extends T&gt;"/>
      <doc>
      <![CDATA[See the factory configuration examples at {@link FactoryModuleBuilder}.]]>
      </doc>
    </method>
    <method name="implement" return="com.google.inject.assistedinject.FactoryModuleBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="source" type="com.google.inject.TypeLiteral&lt;T&gt;"/>
      <param name="target" type="com.google.inject.TypeLiteral&lt;? extends T&gt;"/>
      <doc>
      <![CDATA[See the factory configuration examples at {@link FactoryModuleBuilder}.]]>
      </doc>
    </method>
    <method name="implement" return="com.google.inject.assistedinject.FactoryModuleBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="source" type="java.lang.Class&lt;T&gt;"/>
      <param name="annotation" type="java.lang.annotation.Annotation"/>
      <param name="target" type="java.lang.Class&lt;? extends T&gt;"/>
      <doc>
      <![CDATA[See the factory configuration examples at {@link FactoryModuleBuilder}.]]>
      </doc>
    </method>
    <method name="implement" return="com.google.inject.assistedinject.FactoryModuleBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="source" type="java.lang.Class&lt;T&gt;"/>
      <param name="annotation" type="java.lang.annotation.Annotation"/>
      <param name="target" type="com.google.inject.TypeLiteral&lt;? extends T&gt;"/>
      <doc>
      <![CDATA[See the factory configuration examples at {@link FactoryModuleBuilder}.]]>
      </doc>
    </method>
    <method name="implement" return="com.google.inject.assistedinject.FactoryModuleBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="source" type="com.google.inject.TypeLiteral&lt;T&gt;"/>
      <param name="annotation" type="java.lang.annotation.Annotation"/>
      <param name="target" type="java.lang.Class&lt;? extends T&gt;"/>
      <doc>
      <![CDATA[See the factory configuration examples at {@link FactoryModuleBuilder}.]]>
      </doc>
    </method>
    <method name="implement" return="com.google.inject.assistedinject.FactoryModuleBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="source" type="com.google.inject.TypeLiteral&lt;T&gt;"/>
      <param name="annotation" type="java.lang.annotation.Annotation"/>
      <param name="target" type="com.google.inject.TypeLiteral&lt;? extends T&gt;"/>
      <doc>
      <![CDATA[See the factory configuration examples at {@link FactoryModuleBuilder}.]]>
      </doc>
    </method>
    <method name="implement" return="com.google.inject.assistedinject.FactoryModuleBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="source" type="java.lang.Class&lt;T&gt;"/>
      <param name="annotationType" type="java.lang.Class&lt;? extends java.lang.annotation.Annotation&gt;"/>
      <param name="target" type="java.lang.Class&lt;? extends T&gt;"/>
      <doc>
      <![CDATA[See the factory configuration examples at {@link FactoryModuleBuilder}.]]>
      </doc>
    </method>
    <method name="implement" return="com.google.inject.assistedinject.FactoryModuleBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="source" type="java.lang.Class&lt;T&gt;"/>
      <param name="annotationType" type="java.lang.Class&lt;? extends java.lang.annotation.Annotation&gt;"/>
      <param name="target" type="com.google.inject.TypeLiteral&lt;? extends T&gt;"/>
      <doc>
      <![CDATA[See the factory configuration examples at {@link FactoryModuleBuilder}.]]>
      </doc>
    </method>
    <method name="implement" return="com.google.inject.assistedinject.FactoryModuleBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="source" type="com.google.inject.TypeLiteral&lt;T&gt;"/>
      <param name="annotationType" type="java.lang.Class&lt;? extends java.lang.annotation.Annotation&gt;"/>
      <param name="target" type="java.lang.Class&lt;? extends T&gt;"/>
      <doc>
      <![CDATA[See the factory configuration examples at {@link FactoryModuleBuilder}.]]>
      </doc>
    </method>
    <method name="implement" return="com.google.inject.assistedinject.FactoryModuleBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="source" type="com.google.inject.TypeLiteral&lt;T&gt;"/>
      <param name="annotationType" type="java.lang.Class&lt;? extends java.lang.annotation.Annotation&gt;"/>
      <param name="target" type="com.google.inject.TypeLiteral&lt;? extends T&gt;"/>
      <doc>
      <![CDATA[See the factory configuration examples at {@link FactoryModuleBuilder}.]]>
      </doc>
    </method>
    <method name="implement" return="com.google.inject.assistedinject.FactoryModuleBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="source" type="com.google.inject.Key&lt;T&gt;"/>
      <param name="target" type="java.lang.Class&lt;? extends T&gt;"/>
      <doc>
      <![CDATA[See the factory configuration examples at {@link FactoryModuleBuilder}.]]>
      </doc>
    </method>
    <method name="implement" return="com.google.inject.assistedinject.FactoryModuleBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="source" type="com.google.inject.Key&lt;T&gt;"/>
      <param name="target" type="com.google.inject.TypeLiteral&lt;? extends T&gt;"/>
      <doc>
      <![CDATA[See the factory configuration examples at {@link FactoryModuleBuilder}.]]>
      </doc>
    </method>
    <method name="build" return="com.google.inject.Module"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="factoryInterface" type="java.lang.Class&lt;F&gt;"/>
      <doc>
      <![CDATA[See the factory configuration examples at {@link FactoryModuleBuilder}.]]>
      </doc>
    </method>
    <method name="build" return="com.google.inject.Module"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="factoryInterface" type="com.google.inject.TypeLiteral&lt;F&gt;"/>
      <doc>
      <![CDATA[See the factory configuration examples at {@link FactoryModuleBuilder}.]]>
      </doc>
    </method>
    <method name="build" return="com.google.inject.Module"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="factoryInterface" type="com.google.inject.Key&lt;F&gt;"/>
    </method>
    <doc>
    <![CDATA[Provides a factory that combines the caller's arguments with injector-supplied values to
 construct objects.

 <h3>Defining a factory</h3>
 Create an interface whose methods return the constructed type, or any of its supertypes. The
 method's parameters are the arguments required to build the constructed type.

 <pre>public interface PaymentFactory {
   Payment create(Date startDate, Money amount);
 }</pre>

 You can name your factory methods whatever you like, such as <i>create</i>, <i>createPayment</i>
 or <i>newPayment</i>.

 <h3>Creating a type that accepts factory parameters</h3>
 {@code constructedType} is a concrete class with an {@literal @}{@link com.google.inject.Inject
 Inject}-annotated constructor. In addition to injector-supplied parameters, the constructor
 should have parameters that match each of the factory method's parameters. Each factory-supplied
 parameter requires an {@literal @}{@link Assisted} annotation. This serves to document that the
 parameter is not bound by your application's modules.

 <pre>public class RealPayment implements Payment {
   {@literal @}Inject
   public RealPayment(
      CreditService creditService,
      AuthService authService,
      <strong>{@literal @}Assisted Date startDate</strong>,
      <strong>{@literal @}Assisted Money amount</strong>) {
     ...
   }
 }</pre>
 
 <h3>Multiple factory methods for the same type</h3>
 If the factory contains many methods that return the same type, you can create multiple
 constructors in your concrete class, each constructor marked with with
 {@literal @}{@link AssistedInject}, in order to match the different parameters types of the
 factory methods. 
 
 <pre>public interface PaymentFactory {
    Payment create(Date startDate, Money amount);
    Payment createWithoutDate(Money amount);
 }
 
 public class RealPayment implements Payment {
  {@literal @}AssistedInject
   public RealPayment(
      CreditService creditService,
      AuthService authService,
     <strong>{@literal @}Assisted Date startDate</strong>,
     <strong>{@literal @}Assisted Money amount</strong>) {
     ...
   }
   
  {@literal @}AssistedInject
   public RealPayment(
      CreditService creditService,
      AuthService authService,
     <strong>{@literal @}Assisted Money amount</strong>) {
     ...
   }   
 }</pre> 

 <h3>Configuring simple factories</h3>
 In your {@link Module module}, install a {@code FactoryModuleBuilder} that creates the
 factory:

 <pre>install(new FactoryModuleBuilder()
     .implement(Payment.class, RealPayment.class)
     .build(PaymentFactory.class);</pre>

 As a side-effect of this binding, Guice will inject the factory to initialize it for use. The
 factory cannot be used until the injector has been initialized.
 
 <h3>Configuring complex factories</h3>
 Factories can create an arbitrary number of objects, one per each method.  Each factory
 method can be configured using <code>.implement</code>.

 <pre>public interface OrderFactory {
    Payment create(Date startDate, Money amount);
    Shipment create(Customer customer, Item item);
    Receipt create(Payment payment, Shipment shipment);
 }
 
 [...]
 
 install(new FactoryModuleBuilder()
     .implement(Payment.class, RealPayment.class)
     // excluding .implement for Shipment means the implementation class
     // will be 'Shipment' itself, which is legal if it's not an interface.
     .implement(Receipt.class, RealReceipt.class)
     .build(OrderFactory.class);</pre>
 </pre>

 <h3>Using the factory</h3>
 Inject your factory into your application classes. When you use the factory, your arguments
 will be combined with values from the injector to construct an instance.

 <pre>public class PaymentAction {
   {@literal @}Inject private PaymentFactory paymentFactory;

   public void doPayment(Money amount) {
     Payment payment = paymentFactory.create(new Date(), amount);
     payment.apply();
   }
 }</pre>

 <h3>Making parameter types distinct</h3>
 The types of the factory method's parameters must be distinct. To use multiple parameters of
 the same type, use a named {@literal @}{@link Assisted} annotation to disambiguate the
 parameters. The names must be applied to the factory method's parameters:

 <pre>public interface PaymentFactory {
   Payment create(
       <strong>{@literal @}Assisted("startDate")</strong> Date startDate,
       <strong>{@literal @}Assisted("dueDate")</strong> Date dueDate,
       Money amount);
 } </pre>

 ...and to the concrete type's constructor parameters:

 <pre>public class RealPayment implements Payment {
   {@literal @}Inject
   public RealPayment(
      CreditService creditService,
      AuthService authService,
      <strong>{@literal @}Assisted("startDate")</strong> Date startDate,
      <strong>{@literal @}Assisted("dueDate")</strong> Date dueDate,
      <strong>{@literal @}Assisted</strong> Money amount) {
     ...
   }
 }</pre>

 <h3>Values are created by Guice</h3>
 Returned factories use child injectors to create values. The values are eligible for method
 interception. In addition, {@literal @}{@literal Inject} members will be injected before they are
 returned.

 <h3>More configuration options</h3>
 In addition to simply specifying an implementation class for any returned type, factories' return
 values can be automatic or can be configured to use annotations:
 <p/>
 If you just want to return the types specified in the factory, do not configure any
 implementations:

 <pre>public interface FruitFactory {
   Apple getApple(Color color);
 }
 ...
 protected void configure() {
   install(new FactoryModuleBuilder().build(FruitFactory.class));
 }</pre>

 Note that any type returned by the factory in this manner needs to be an implementation class.
 <p/>
 To return two different implementations for the same interface from your factory, use binding
 annotations on your return types:

 <pre>interface CarFactory {
   {@literal @}Named("fast") Car getFastCar(Color color);
   {@literal @}Named("clean") Car getCleanCar(Color color);
 }
 ...
 protected void configure() {
   install(new FactoryModuleBuilder()
       .implement(Car.class, Names.named("fast"), Porsche.class)
       .implement(Car.class, Names.named("clean"), Prius.class)
       .build(CarFactory.class));
 }</pre>
 
 <h3>Implementation limitations</h3>
 As a limitation of the implementation, it is prohibited to declare a factory method that
 accepts a {@code Provider} as one of its arguments.

 @since 3.0
 @author schmitt@google.com (Peter Schmitt)]]>
    </doc>
  </class>
  <!-- end class com.google.inject.assistedinject.FactoryModuleBuilder -->
  <!-- start class com.google.inject.assistedinject.FactoryProvider -->
  <class name="FactoryProvider" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="use {@link FactoryModuleBuilder} instead.">
    <implements name="com.google.inject.Provider&lt;F&gt;"/>
    <implements name="com.google.inject.spi.HasDependencies"/>
    <method name="newFactory" return="com.google.inject.Provider&lt;F&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="factoryType" type="java.lang.Class&lt;F&gt;"/>
      <param name="implementationType" type="java.lang.Class&lt;?&gt;"/>
    </method>
    <method name="newFactory" return="com.google.inject.Provider&lt;F&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="factoryType" type="com.google.inject.TypeLiteral&lt;F&gt;"/>
      <param name="implementationType" type="com.google.inject.TypeLiteral&lt;?&gt;"/>
    </method>
    <method name="getDependencies" return="java.util.Set&lt;com.google.inject.spi.Dependency&lt;?&gt;&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="get" return="F"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[<strong>Obsolete.</strong> Prefer {@link FactoryModuleBuilder} for its more concise API and
 additional capability.

 <p>Provides a factory that combines the caller's arguments with injector-supplied values to
 construct objects.

 <h3>Defining a factory</h3>
 Create an interface whose methods return the constructed type, or any of its supertypes. The
 method's parameters are the arguments required to build the constructed type.
 <pre>public interface PaymentFactory {
   Payment create(Date startDate, Money amount);
 }</pre>
 You can name your factory methods whatever you like, such as <i>create</i>, <i>createPayment</i>
 or <i>newPayment</i>.

 <h3>Creating a type that accepts factory parameters</h3>
 {@code constructedType} is a concrete class with an {@literal @}{@link Inject}-annotated
 constructor. In addition to injector-supplied parameters, the constructor should have
 parameters that match each of the factory method's parameters. Each factory-supplied parameter
 requires an {@literal @}{@link Assisted} annotation. This serves to document that the parameter
 is not bound by your application's modules.
 <pre>public class RealPayment implements Payment {
   {@literal @}Inject
   public RealPayment(
      CreditService creditService,
      AuthService authService,
      <strong>{@literal @}Assisted Date startDate</strong>,
      <strong>{@literal @}Assisted Money amount</strong>) {
     ...
   }
 }</pre>
 Any parameter that permits a null value should also be annotated {@code @Nullable}.

 <h3>Configuring factories</h3>
 In your {@link com.google.inject.Module module}, bind the factory interface to the returned
 factory:
 <pre>bind(PaymentFactory.class).toProvider(
     FactoryProvider.newFactory(PaymentFactory.class, RealPayment.class));</pre>
 As a side-effect of this binding, Guice will inject the factory to initialize it for use. The
 factory cannot be used until the injector has been initialized.

 <h3>Using the factory</h3>
 Inject your factory into your application classes. When you use the factory, your arguments
 will be combined with values from the injector to construct an instance.
 <pre>public class PaymentAction {
   {@literal @}Inject private PaymentFactory paymentFactory;

   public void doPayment(Money amount) {
     Payment payment = paymentFactory.create(new Date(), amount);
     payment.apply();
   }
 }</pre>

 <h3>Making parameter types distinct</h3>
 The types of the factory method's parameters must be distinct. To use multiple parameters of
 the same type, use a named {@literal @}{@link Assisted} annotation to disambiguate the
 parameters. The names must be applied to the factory method's parameters:

 <pre>public interface PaymentFactory {
   Payment create(
       <strong>{@literal @}Assisted("startDate")</strong> Date startDate,
       <strong>{@literal @}Assisted("dueDate")</strong> Date dueDate,
       Money amount);
 } </pre>
 ...and to the concrete type's constructor parameters:
 <pre>public class RealPayment implements Payment {
   {@literal @}Inject
   public RealPayment(
      CreditService creditService,
      AuthService authService,
      <strong>{@literal @}Assisted("startDate")</strong> Date startDate,
      <strong>{@literal @}Assisted("dueDate")</strong> Date dueDate,
      <strong>{@literal @}Assisted</strong> Money amount) {
     ...
   }
 }</pre>

 <h3>Values are created by Guice</h3>
 Returned factories use child injectors to create values. The values are eligible for method
 interception. In addition, {@literal @}{@literal Inject} members will be injected before they are
 returned.

 <h3>Backwards compatibility using {@literal @}AssistedInject</h3>
 Instead of the {@literal @}Inject annotation, you may annotate the constructed classes with
 {@literal @}{@link AssistedInject}. This triggers a limited backwards-compatability mode.

 <p>Instead of matching factory method arguments to constructor parameters using their names, the
 <strong>parameters are matched by their order</strong>. The first factory method argument is
 used for the first {@literal @}Assisted constructor parameter, etc.. Annotation names have no
 effect.

 <p>Returned values are <strong>not created by Guice</strong>. These types are not eligible for
 method interception. They do receive post-construction member injection.

 @param <F> The factory interface

 @author jmourits@google.com (Jerome Mourits)
 @author jessewilson@google.com (Jesse Wilson)
 @author dtm@google.com (Daniel Martin)
 
 @deprecated use {@link FactoryModuleBuilder} instead.]]>
    </doc>
  </class>
  <!-- end class com.google.inject.assistedinject.FactoryProvider -->
</package>
<package name="com.google.inject.binder">
  <!-- start interface com.google.inject.binder.AnnotatedBindingBuilder -->
  <interface name="AnnotatedBindingBuilder"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.inject.binder.LinkedBindingBuilder&lt;T&gt;"/>
    <method name="annotatedWith" return="com.google.inject.binder.LinkedBindingBuilder&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="annotationType" type="java.lang.Class&lt;? extends java.lang.annotation.Annotation&gt;"/>
      <doc>
      <![CDATA[See the EDSL examples at {@link com.google.inject.Binder}.]]>
      </doc>
    </method>
    <method name="annotatedWith" return="com.google.inject.binder.LinkedBindingBuilder&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="annotation" type="java.lang.annotation.Annotation"/>
      <doc>
      <![CDATA[See the EDSL examples at {@link com.google.inject.Binder}.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[See the EDSL examples at {@link com.google.inject.Binder}.

 @author crazybob@google.com (Bob Lee)]]>
    </doc>
  </interface>
  <!-- end interface com.google.inject.binder.AnnotatedBindingBuilder -->
  <!-- start interface com.google.inject.binder.AnnotatedConstantBindingBuilder -->
  <interface name="AnnotatedConstantBindingBuilder"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="annotatedWith" return="com.google.inject.binder.ConstantBindingBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="annotationType" type="java.lang.Class&lt;? extends java.lang.annotation.Annotation&gt;"/>
      <doc>
      <![CDATA[See the EDSL examples at {@link com.google.inject.Binder}.]]>
      </doc>
    </method>
    <method name="annotatedWith" return="com.google.inject.binder.ConstantBindingBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="annotation" type="java.lang.annotation.Annotation"/>
      <doc>
      <![CDATA[See the EDSL examples at {@link com.google.inject.Binder}.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[See the EDSL examples at {@link com.google.inject.Binder}.

 @author crazybob@google.com (Bob Lee)]]>
    </doc>
  </interface>
  <!-- end interface com.google.inject.binder.AnnotatedConstantBindingBuilder -->
  <!-- start interface com.google.inject.binder.AnnotatedElementBuilder -->
  <interface name="AnnotatedElementBuilder"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="annotatedWith"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="annotationType" type="java.lang.Class&lt;? extends java.lang.annotation.Annotation&gt;"/>
      <doc>
      <![CDATA[See the EDSL examples at {@link com.google.inject.Binder}.]]>
      </doc>
    </method>
    <method name="annotatedWith"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="annotation" type="java.lang.annotation.Annotation"/>
      <doc>
      <![CDATA[See the EDSL examples at {@link com.google.inject.Binder}.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[See the EDSL examples at {@link com.google.inject.Binder}.

 @author jessewilson@google.com (Jesse Wilson)
 @since 2.0]]>
    </doc>
  </interface>
  <!-- end interface com.google.inject.binder.AnnotatedElementBuilder -->
  <!-- start interface com.google.inject.binder.ConstantBindingBuilder -->
  <interface name="ConstantBindingBuilder"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="to"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="java.lang.String"/>
      <doc>
      <![CDATA[Binds constant to the given value.]]>
      </doc>
    </method>
    <method name="to"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="int"/>
      <doc>
      <![CDATA[Binds constant to the given value.]]>
      </doc>
    </method>
    <method name="to"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="long"/>
      <doc>
      <![CDATA[Binds constant to the given value.]]>
      </doc>
    </method>
    <method name="to"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="boolean"/>
      <doc>
      <![CDATA[Binds constant to the given value.]]>
      </doc>
    </method>
    <method name="to"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="double"/>
      <doc>
      <![CDATA[Binds constant to the given value.]]>
      </doc>
    </method>
    <method name="to"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="float"/>
      <doc>
      <![CDATA[Binds constant to the given value.]]>
      </doc>
    </method>
    <method name="to"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="short"/>
      <doc>
      <![CDATA[Binds constant to the given value.]]>
      </doc>
    </method>
    <method name="to"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="char"/>
      <doc>
      <![CDATA[Binds constant to the given value.]]>
      </doc>
    </method>
    <method name="to"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="byte"/>
      <doc>
      <![CDATA[Binds constant to the given value.
 
 @since 3.0]]>
      </doc>
    </method>
    <method name="to"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="java.lang.Class&lt;?&gt;"/>
      <doc>
      <![CDATA[Binds constant to the given value.]]>
      </doc>
    </method>
    <method name="to"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="E extends java.lang.Enum&lt;E&gt;"/>
      <doc>
      <![CDATA[Binds constant to the given value.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Binds to a constant value.]]>
    </doc>
  </interface>
  <!-- end interface com.google.inject.binder.ConstantBindingBuilder -->
  <!-- start interface com.google.inject.binder.LinkedBindingBuilder -->
  <interface name="LinkedBindingBuilder"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.inject.binder.ScopedBindingBuilder"/>
    <method name="to" return="com.google.inject.binder.ScopedBindingBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="implementation" type="java.lang.Class&lt;? extends T&gt;"/>
      <doc>
      <![CDATA[See the EDSL examples at {@link com.google.inject.Binder}.]]>
      </doc>
    </method>
    <method name="to" return="com.google.inject.binder.ScopedBindingBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="implementation" type="com.google.inject.TypeLiteral&lt;? extends T&gt;"/>
      <doc>
      <![CDATA[See the EDSL examples at {@link com.google.inject.Binder}.]]>
      </doc>
    </method>
    <method name="to" return="com.google.inject.binder.ScopedBindingBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="targetKey" type="com.google.inject.Key&lt;? extends T&gt;"/>
      <doc>
      <![CDATA[See the EDSL examples at {@link com.google.inject.Binder}.]]>
      </doc>
    </method>
    <method name="toInstance"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="instance" type="T"/>
      <doc>
      <![CDATA[See the EDSL examples at {@link com.google.inject.Binder}.

 @see com.google.inject.Injector#injectMembers]]>
      </doc>
    </method>
    <method name="toProvider" return="com.google.inject.binder.ScopedBindingBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="provider" type="com.google.inject.Provider&lt;? extends T&gt;"/>
      <doc>
      <![CDATA[See the EDSL examples at {@link com.google.inject.Binder}.

 @see com.google.inject.Injector#injectMembers]]>
      </doc>
    </method>
    <method name="toProvider" return="com.google.inject.binder.ScopedBindingBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="providerType" type="java.lang.Class&lt;? extends javax.inject.Provider&lt;? extends T&gt;&gt;"/>
      <doc>
      <![CDATA[See the EDSL examples at {@link com.google.inject.Binder}.]]>
      </doc>
    </method>
    <method name="toProvider" return="com.google.inject.binder.ScopedBindingBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="providerType" type="com.google.inject.TypeLiteral&lt;? extends javax.inject.Provider&lt;? extends T&gt;&gt;"/>
      <doc>
      <![CDATA[See the EDSL examples at {@link com.google.inject.Binder}.]]>
      </doc>
    </method>
    <method name="toProvider" return="com.google.inject.binder.ScopedBindingBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="providerKey" type="com.google.inject.Key&lt;? extends javax.inject.Provider&lt;? extends T&gt;&gt;"/>
      <doc>
      <![CDATA[See the EDSL examples at {@link com.google.inject.Binder}.]]>
      </doc>
    </method>
    <method name="toConstructor" return="com.google.inject.binder.ScopedBindingBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="constructor" type="java.lang.reflect.Constructor&lt;S&gt;"/>
      <doc>
      <![CDATA[See the EDSL examples at {@link com.google.inject.Binder}.
 
 @since 3.0]]>
      </doc>
    </method>
    <method name="toConstructor" return="com.google.inject.binder.ScopedBindingBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="constructor" type="java.lang.reflect.Constructor&lt;S&gt;"/>
      <param name="type" type="com.google.inject.TypeLiteral&lt;? extends S&gt;"/>
      <doc>
      <![CDATA[See the EDSL examples at {@link com.google.inject.Binder}.
 
 @since 3.0]]>
      </doc>
    </method>
    <doc>
    <![CDATA[See the EDSL examples at {@link com.google.inject.Binder}.

 @author crazybob@google.com (Bob Lee)]]>
    </doc>
  </interface>
  <!-- end interface com.google.inject.binder.LinkedBindingBuilder -->
  <!-- start interface com.google.inject.binder.ScopedBindingBuilder -->
  <interface name="ScopedBindingBuilder"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="in"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="scopeAnnotation" type="java.lang.Class&lt;? extends java.lang.annotation.Annotation&gt;"/>
      <doc>
      <![CDATA[See the EDSL examples at {@link com.google.inject.Binder}.]]>
      </doc>
    </method>
    <method name="in"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="scope" type="com.google.inject.Scope"/>
      <doc>
      <![CDATA[See the EDSL examples at {@link com.google.inject.Binder}.]]>
      </doc>
    </method>
    <method name="asEagerSingleton"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Instructs the {@link com.google.inject.Injector} to eagerly initialize this
 singleton-scoped binding upon creation. Useful for application
 initialization logic.  See the EDSL examples at
 {@link com.google.inject.Binder}.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[See the EDSL examples at {@link com.google.inject.Binder}.

 @author crazybob@google.com (Bob Lee)]]>
    </doc>
  </interface>
  <!-- end interface com.google.inject.binder.ScopedBindingBuilder -->
</package>
<package name="com.google.inject.grapher">
  <!-- start interface com.google.inject.grapher.BindingEdge -->
  <interface name="BindingEdge"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="setType"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="com.google.inject.grapher.BindingEdge.Type"/>
    </method>
    <doc>
    <![CDATA[Interface for an edge that connects an interface to the type or instance
 that is bound to implement it.

 @author phopkins@gmail.com (Pete Hopkins)

 @param <K> The type for node IDs.]]>
    </doc>
  </interface>
  <!-- end interface com.google.inject.grapher.BindingEdge -->
  <!-- start interface com.google.inject.grapher.BindingEdge.Factory -->
  <interface name="BindingEdge.Factory"    abstract="true"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="newBindingEdge" return="T extends com.google.inject.grapher.BindingEdge&lt;K&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="fromId" type="K"/>
      <param name="toId" type="K"/>
      <doc>
      <![CDATA[Creates a new {@link BindingEdge} instance and adds it to the graph.

 @param fromId Node ID for the interface node.
 @param toId Node ID for the implementation (class or instance) node.
 @return The newly created and added {@link BindingEdge}.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Factory interface for {@link BindingEdge}s. Renderer implementations will
 need to provide an implementation for this.

 @param <K> The type for node IDs.
 @param <T> The {@link BindingEdge} sub-type that this factory provides.]]>
    </doc>
  </interface>
  <!-- end interface com.google.inject.grapher.BindingEdge.Factory -->
  <!-- start class com.google.inject.grapher.BindingEdge.Type -->
  <class name="BindingEdge.Type" extends="java.lang.Enum&lt;com.google.inject.grapher.BindingEdge.Type&gt;"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="values" return="com.google.inject.grapher.BindingEdge.Type[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="com.google.inject.grapher.BindingEdge.Type"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <doc>
    <![CDATA[Classification for what kind of binding this edge represents.]]>
    </doc>
  </class>
  <!-- end class com.google.inject.grapher.BindingEdge.Type -->
  <!-- start interface com.google.inject.grapher.DependencyEdge -->
  <interface name="DependencyEdge"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <doc>
    <![CDATA[Interface for an edge from a class or {@link InjectionPoint} to the
 interface node that will satisfy the dependency.

 @author phopkins@gmail.com (Pete Hopkins)

 @param <K> The type for node IDs.]]>
    </doc>
  </interface>
  <!-- end interface com.google.inject.grapher.DependencyEdge -->
  <!-- start interface com.google.inject.grapher.DependencyEdge.Factory -->
  <interface name="DependencyEdge.Factory"    abstract="true"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="newDependencyEdge" return="T extends com.google.inject.grapher.DependencyEdge&lt;K&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="fromId" type="K"/>
      <param name="fromPoint" type="com.google.inject.spi.InjectionPoint"/>
      <param name="toId" type="K"/>
      <doc>
      <![CDATA[Creates a new {@link DependencyEdge} and adds it to the graph.

 @param fromId The ID for the class or instance node that has the
     dependency.
 @param fromPoint The point where the dependency will be
     {@literal @}{@link Inject}ed. 
 @param toId The ID for the interface node that satisfies the dependency.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Factory interface for {@link DependencyEdge}s. Renderer implementations
 will need to provide an implementation for this.

 @param <K> The type for node IDs.
 @param <T> The {@link DependencyEdge} sub-type that this factory provides.]]>
    </doc>
  </interface>
  <!-- end interface com.google.inject.grapher.DependencyEdge.Factory -->
  <!-- start class com.google.inject.grapher.GrapherModule -->
  <class name="GrapherModule" extends="com.google.inject.AbstractModule"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="GrapherModule"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="configure"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Module for the common bindings for {@link InjectorGrapher}. You will also
 need to bind a {@link Module} that satisfies the {@link Renderer}
 dependency.
 <p>
 If you want to use subtypes of the node and edge classes, or a different
 node ID type, you will need to override the {@link GraphingVisitor} binding
 to specify the new type parameters. 

 @author phopkins@gmail.com (Pete Hopkins)]]>
    </doc>
  </class>
  <!-- end class com.google.inject.grapher.GrapherModule -->
  <!-- start class com.google.inject.grapher.GraphingVisitor -->
  <class name="GraphingVisitor" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.inject.spi.BindingTargetVisitor&lt;java.lang.Object, java.lang.Void&gt;"/>
    <constructor name="GraphingVisitor" type="com.google.inject.grapher.NodeIdFactory&lt;K&gt;, com.google.inject.grapher.InterfaceNode.Factory&lt;K, N&gt;, com.google.inject.grapher.ImplementationNode.Factory&lt;K, M&gt;, com.google.inject.grapher.BindingEdge.Factory&lt;K, B&gt;, com.google.inject.grapher.DependencyEdge.Factory&lt;K, D&gt;, com.google.inject.grapher.NodeAliasFactory&lt;K&gt;"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getClassNodeId" return="K"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="protected"
      deprecated="not deprecated">
      <param name="binding" type="com.google.inject.Binding&lt;?&gt;"/>
      <doc>
      <![CDATA[Helper method to return the standard node ID for the {@link Binding}'s
 {@link Key}.
 
 @see NodeIdFactory#getClassNodeId(Key)]]>
      </doc>
    </method>
    <method name="getInstanceNodeId" return="K"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="protected"
      deprecated="not deprecated">
      <param name="binding" type="com.google.inject.Binding&lt;?&gt;"/>
      <doc>
      <![CDATA[Helper method to return the instance node ID for the {@link Binding}'s
 {@link Key}.
 
 @see NodeIdFactory#getInstanceNodeId(Key)]]>
      </doc>
    </method>
    <method name="newInterfaceNode" return="N extends com.google.inject.grapher.InterfaceNode&lt;K&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="binding" type="com.google.inject.Binding&lt;?&gt;"/>
      <doc>
      <![CDATA[Creates and returns a new {@link InterfaceNode} object for the given
 {@link Binding}.]]>
      </doc>
    </method>
    <method name="newClassImplementationNode" return="M extends com.google.inject.grapher.ImplementationNode&lt;K&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="binding" type="com.google.inject.Binding&lt;?&gt;"/>
      <param name="constructorInjectionPoint" type="com.google.inject.spi.InjectionPoint"/>
      <param name="memberInjectionPoints" type="java.util.Collection&lt;com.google.inject.spi.InjectionPoint&gt;"/>
      <doc>
      <![CDATA[Creates and returns a new {@link ImplementationNode} for the given
 {@link Binding}, where the {@link Binding} is for a class that Guice
 will instantiate, rather than a specific instance.]]>
      </doc>
    </method>
    <method name="newInstanceImplementationNode" return="M extends com.google.inject.grapher.ImplementationNode&lt;K&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="binding" type="com.google.inject.Binding&lt;?&gt;"/>
      <param name="instance" type="java.lang.Object"/>
      <doc>
      <![CDATA[Creates and returns a new {@link ImplementationNode} for the given
 {@link Binding}, where the {@link Binding} is for an instance, rather than
 a class.]]>
      </doc>
    </method>
    <method name="newBindingEdge" return="B extends com.google.inject.grapher.BindingEdge&lt;K&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="nodeId" type="K"/>
      <param name="toId" type="K"/>
      <param name="type" type="com.google.inject.grapher.BindingEdge.Type"/>
      <doc>
      <![CDATA[Creates a new {@link BindingEdge} from the given node to the specified
 node.

 @param nodeId ID of the {@link InterfaceNode} that binds to the other.
 @param toId The node ID of a class or instance that is bound.
 @param type The {@link BindingEdge.Type} of this binding.
 @return The newly-created and added {@link BindingEdge}.]]>
      </doc>
    </method>
    <method name="newDependencyEdges" return="java.util.Collection&lt;D&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="nodeId" type="K"/>
      <param name="node" type="M extends com.google.inject.grapher.ImplementationNode&lt;K&gt;"/>
      <param name="dependencies" type="java.util.Collection&lt;com.google.inject.spi.Dependency&lt;?&gt;&gt;"/>
      <doc>
      <![CDATA[Adds {@link DependencyEdge}s to the graph for each of the provided
 {@link Dependency}s. These will be from the given node ID to the
 {@link Dependency}'s {@link Key}.
 <p>
 If a {@link Dependency} has an associated {@link InjectionPoint}, its
 member will be added to the given {@link ImplementationNode} and the edge
 will start at the {@link Member}.

 @see #newDependencyEdge(Object, InjectionPoint, Dependency)
 
 @param nodeId ID of the node that should be the tail of the
     {@link DependencyEdge}s.
 @param node An {@link ImplementationNode} to add {@link Member}s to.
 @param dependencies {@link Collection} of {@link Dependency}s from the
     {@link Binding}.
 @return A {@link Collection} of the {@link DependencyEdge}s that were
     added to the graph.]]>
      </doc>
    </method>
    <method name="newDependencyEdge" return="D extends com.google.inject.grapher.DependencyEdge&lt;K&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="nodeId" type="K"/>
      <param name="injectionPoint" type="com.google.inject.spi.InjectionPoint"/>
      <param name="dependency" type="com.google.inject.spi.Dependency&lt;?&gt;"/>
      <doc>
      <![CDATA[Creates a new {@link DependencyEdge} from the given node to a
 {@link Dependency}.
 <p>
 This method takes more comprehensive parameters than strictly necessary
 in case they would be useful to overriding implementations.

 @param nodeId ID of the {@link ImplementationNode} where the edges will start.
 @param injectionPoint The {@link InjectionPoint} that gave rise to this
     {@link Dependency}, if one exists. Used to figure out which
     {@link Member} the edge should point from.
 @param dependency The {@link Dependency} to represent with this edge.
 @return The newly-created and added {@link DependencyEdge}.]]>
      </doc>
    </method>
    <method name="visit" return="java.lang.Void"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="binding" type="com.google.inject.spi.ConstructorBinding&lt;?&gt;"/>
      <doc>
      <![CDATA[Visitor for {@link ConstructorBinding}s. These are for classes that Guice
 will instantiate to satisfy injection requests. We create a new
 {@link ImplementationNode} for the class, then add edges to everything
 that it depends on to be instantiated.

 @see #newClassImplementationNode(Binding, InjectionPoint, Collection)
 @see #newDependencyEdges(Object, ImplementationNode, Collection)]]>
      </doc>
    </method>
    <method name="visit" return="java.lang.Void"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="binding" type="com.google.inject.spi.ConvertedConstantBinding&lt;?&gt;"/>
      <doc>
      <![CDATA[Visitor for {@link ConvertedConstantBinding}. The {@link Binding}'s
 {@link Key} will be of an annotated primitive type, and the value of
 {@link ConvertedConstantBinding#getSourceKey()} will be of a
 {@link String} with the same annotation.
 <p>
 We render this as an {@link InterfaceNode} that has a
 {@link BindingEdge} to the source {@link Key}. That will then be rendered
 by {@link #visit(InstanceBinding)} as an {@link InterfaceNode}
 with a {@link BindingEdge} to the {@link String} instance.
 
 @see #newInterfaceNode(Binding)
 @see #newBindingEdge(Object, Object, com.google.inject.grapher.BindingEdge.Type)]]>
      </doc>
    </method>
    <method name="visit" return="java.lang.Void"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="binding" type="com.google.inject.spi.ExposedBinding&lt;?&gt;"/>
      <doc>
      <![CDATA[Currently not displayed on the graph.]]>
      </doc>
    </method>
    <method name="visit" return="java.lang.Void"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="binding" type="com.google.inject.spi.InstanceBinding&lt;?&gt;"/>
      <doc>
      <![CDATA[Visitor for {@link InstanceBinding}. We render two nodes in this case: a
 {@link InterfaceNode} for the binding's {@link Key}, and then an
 {@link ImplementationNode} for the instance {@link Object} itself. We run
 a binding node between them.
 <p>
 We then render any {@link DependencyEdge}s that the instance may have,
 which come either from {@link InjectionPoint}s (method and field) on the
 instance, or on {@link Dependency}s the instance declares through the
 {@link HasDependencies} interface.
 
 @see #newInterfaceNode(Binding)
 @see #newBindingEdge(Object, Object, com.google.inject.grapher.BindingEdge.Type)
 @see #newInstanceImplementationNode(Binding, Object)
 @see #newDependencyEdges(Object, ImplementationNode, java.util.Collection)]]>
      </doc>
    </method>
    <method name="visit" return="java.lang.Void"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="binding" type="com.google.inject.spi.LinkedKeyBinding&lt;?&gt;"/>
      <doc>
      <![CDATA[Visitor for {@link LinkedKeyBinding}. This is the standard {@link Binding}
 you get from binding an interface class to an implementation class. We
 create an {@link InterfaceNode}, then draw a {@link BindingEdge} to the
 node of the implementing class.
 
 @see #newInterfaceNode(Binding)
 @see #newBindingEdge(Object, Object, com.google.inject.grapher.BindingEdge.Type)]]>
      </doc>
    </method>
    <method name="visit" return="java.lang.Void"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="binding" type="com.google.inject.spi.ProviderBinding&lt;?&gt;"/>
      <doc>
      <![CDATA[Visitor for {@link ProviderBinding}. These {@link Binding}s arise from an
 {@link InjectionPoint} for the {@link Provider} interface. Since this
 isn't tremendously interesting information, we don't render this binding
 on the graph, and instead let the {@link DependencyEdge} go straight from
 the {@link InjectionPoint} to the node specified by
 {@link ProviderBinding#getProvidedKey()}.
 
 @see NodeAliasFactory#newAlias(Object, Object)]]>
      </doc>
    </method>
    <method name="visit" return="java.lang.Void"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="binding" type="com.google.inject.spi.ProviderInstanceBinding&lt;?&gt;"/>
      <doc>
      <![CDATA[Same as {@link #visit(InstanceBinding)}, but the
 {@link BindingEdge} is {@link BindingEdge.Type#PROVIDER}.
 
 @see #newInterfaceNode(Binding)
 @see #newBindingEdge(Object, Object, com.google.inject.grapher.BindingEdge.Type)
 @see #newInstanceImplementationNode(Binding, Object)
 @see #newDependencyEdges(Object, ImplementationNode, java.util.Collection)]]>
      </doc>
    </method>
    <method name="visit" return="java.lang.Void"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="binding" type="com.google.inject.spi.ProviderKeyBinding&lt;?&gt;"/>
      <doc>
      <![CDATA[Same as {@link #visit(LinkedKeyBinding)}, but the
 {@link BindingEdge} is {@link BindingEdge.Type#PROVIDER}.
 
 @see #newInterfaceNode(Binding)
 @see #newBindingEdge(Object, Object, com.google.inject.grapher.BindingEdge.Type)]]>
      </doc>
    </method>
    <method name="visit" return="java.lang.Void"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="binding" type="com.google.inject.spi.UntargettedBinding&lt;?&gt;"/>
      <doc>
      <![CDATA[Currently not displayed on the graph.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[{@link BindingTargetVisitor} that adds nodes and edges to the graph based on
 the visited {@link Binding}.
 <p>
 This class is parameterized over the four graph element types
 ({@link InterfaceNode}, {@link ImplementationNode}, {@link BindingEdge}, and
 {@link DependencyEdge}) so that you can extend those interfaces and also
 extend this class, and the helper methods will all return your new types.
 
 @author phopkins@gmail.com (Pete Hopkins)

 @param <K> The type for node IDs.
 @param <N> Type for {@link InterfaceNode}s.
 @param <M> Type for {@link ImplementationNode}.s
 @param <B> Type for {@link BindingEdge}s.
 @param <D> Type for {@link DependencyEdge}s.]]>
    </doc>
  </class>
  <!-- end class com.google.inject.grapher.GraphingVisitor -->
  <!-- start interface com.google.inject.grapher.ImplementationNode -->
  <interface name="ImplementationNode"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="setClassKey"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="com.google.inject.Key&lt;?&gt;"/>
      <doc>
      <![CDATA[Sets the {@link Key} that this node is for. Used when the node is
 representing a class that Guice will instantiate.]]>
      </doc>
    </method>
    <method name="setInstance"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="instance" type="java.lang.Object"/>
      <doc>
      <![CDATA[Sets the {@link Object} that's the already-created instance. Used when
 this node is represeting the instance instead of a class.]]>
      </doc>
    </method>
    <method name="setSource"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="source" type="java.lang.Object"/>
    </method>
    <method name="addMember"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="member" type="java.lang.reflect.Member"/>
    </method>
    <doc>
    <![CDATA[Node for classes and instances that have {@link Dependency}s and are
 bound to {@link InterfaceNode}s. These nodes will often have fields for
 {@link Member}s that are {@link InjectionPoint}s.
 
 @see DependencyEdge

 @author phopkins@gmail.com (Pete Hopkins)

 @param <K> The type for node IDs.]]>
    </doc>
  </interface>
  <!-- end interface com.google.inject.grapher.ImplementationNode -->
  <!-- start interface com.google.inject.grapher.ImplementationNode.Factory -->
  <interface name="ImplementationNode.Factory"    abstract="true"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="newImplementationNode" return="T extends com.google.inject.grapher.ImplementationNode&lt;K&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="nodeId" type="K"/>
      <doc>
      <![CDATA[Creates a new {@link ImplementationNode} and adds it to the graph.

 @param nodeId ID for the node.
 @return The new {@link ImplementationNode} instance.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Factory interface for {@link ImplementationNode}s. Renderer
 implementations will need to provide an implementation for this.

 @param <K> The type for node IDs.
 @param <T> The {@link ImplementationNode} sub-type that this factory
     provides.]]>
    </doc>
  </interface>
  <!-- end interface com.google.inject.grapher.ImplementationNode.Factory -->
  <!-- start class com.google.inject.grapher.InjectorGrapher -->
  <class name="InjectorGrapher" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="InjectorGrapher" type="com.google.inject.spi.BindingTargetVisitor&lt;java.lang.Object, java.util.Collection&lt;com.google.inject.Key&lt;?&gt;&gt;&gt;, com.google.inject.spi.BindingTargetVisitor&lt;java.lang.Object, java.lang.Void&gt;, com.google.inject.grapher.Renderer"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="of" return="com.google.inject.grapher.InjectorGrapher"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="injector" type="com.google.inject.Injector"/>
      <doc>
      <![CDATA[Sets the {@link Injector} to graph.]]>
      </doc>
    </method>
    <method name="rootedAt" return="com.google.inject.grapher.InjectorGrapher"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="classes" type="java.lang.Class[]"/>
      <doc>
      <![CDATA[Sets an initial group of {@link Class}es to use as the starting point for
 the graph. The graph will be of these classes and their transitive
 dependencies and bindings.]]>
      </doc>
    </method>
    <method name="rootedAt" return="com.google.inject.grapher.InjectorGrapher"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="keys" type="com.google.inject.Key[]"/>
      <doc>
      <![CDATA[Sets an initial group of {@link Key}s to use as the starting point for
 the graph. The graph will be of these keys and their transitive
 dependencies and bindings.]]>
      </doc>
    </method>
    <method name="graph"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Renders a graph with the bound {@link Renderer}. The {@link Injector}
 must have already been specified with {@link #of(Injector)}.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Root class for graphing an {@link Injector}. Bound in {@link GrapherModule}.
 <p>
 Use {@link #of(Injector)} to specify the {@link Injector} to use, and
 {@link graph()} to graph the {@link Injector} using the currently-bound
 {@link Renderer}.
 <p>
 By default, this will graph the entire {@link Injector}. Use
 {@link #rootedAt(Class...)} or {@link #rootedAt(Key...)} to specify an
 initial set of {@link Class}es or {@link Key}s to use, and this will graph
 their transitive bindings and dependencies.

 @author phopkins@gmail.com (Pete Hopkins)]]>
    </doc>
  </class>
  <!-- end class com.google.inject.grapher.InjectorGrapher -->
  <!-- start interface com.google.inject.grapher.InterfaceNode -->
  <interface name="InterfaceNode"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="setKey"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="com.google.inject.Key&lt;?&gt;"/>
    </method>
    <method name="setSource"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="source" type="java.lang.Object"/>
    </method>
    <doc>
    <![CDATA[Node for an interface class that has been bound to an implementation class
 or instance. These nodes are basically defined by a {@link Key}.

 @see BindingEdge

 @author phopkins@gmail.com (Pete Hopkins)

 @param <K> The type for node IDs.]]>
    </doc>
  </interface>
  <!-- end interface com.google.inject.grapher.InterfaceNode -->
  <!-- start interface com.google.inject.grapher.InterfaceNode.Factory -->
  <interface name="InterfaceNode.Factory"    abstract="true"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="newInterfaceNode" return="T extends com.google.inject.grapher.InterfaceNode&lt;K&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="nodeId" type="K"/>
      <doc>
      <![CDATA[Creates a new {@link InterfaceNode} and adds it to the graph.

 @param nodeId ID for the node.
 @return The new {@link InterfaceNode} instance.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Factory interface for {@link InterfaceNode}s. Renderer implementations
 will need to provide an implementation for this.

 @param <K> The type for node IDs.
 @param <T> The {@link InterfaceNode} sub-type that this factory provides.]]>
    </doc>
  </interface>
  <!-- end interface com.google.inject.grapher.InterfaceNode.Factory -->
  <!-- start interface com.google.inject.grapher.NameFactory -->
  <interface name="NameFactory"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="getMemberName" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="member" type="java.lang.reflect.Member"/>
    </method>
    <method name="getClassName" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="com.google.inject.Key&lt;?&gt;"/>
    </method>
    <method name="getInstanceName" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="instance" type="java.lang.Object"/>
    </method>
    <method name="getAnnotationName" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="com.google.inject.Key&lt;?&gt;"/>
    </method>
    <method name="getSourceName" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="source" type="java.lang.Object"/>
    </method>
    <doc>
    <![CDATA[Interface for a service that provides nice {@link String}s that we can
 display in the graph for the types that come up in {@link Binding}s.

 @author phopkins@gmail.com (Pete Hopkins)]]>
    </doc>
  </interface>
  <!-- end interface com.google.inject.grapher.NameFactory -->
  <!-- start interface com.google.inject.grapher.NodeAliasFactory -->
  <interface name="NodeAliasFactory"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="newAlias"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="fromId" type="K"/>
      <param name="toId" type="K"/>
      <doc>
      <![CDATA[Makes edges that would point to {@code fromId} point to
 {@code toId} instead.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Factory for aliasing one node ID to another. Used when we don't want to
 render {@link Key}s from {@link Binding}s that are not interesting.
 
 @author phopkins@gmail.com (Pete Hopkins)]]>
    </doc>
  </interface>
  <!-- end interface com.google.inject.grapher.NodeAliasFactory -->
  <!-- start interface com.google.inject.grapher.NodeIdFactory -->
  <interface name="NodeIdFactory"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="getClassNodeId" return="K"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="com.google.inject.Key&lt;?&gt;"/>
    </method>
    <method name="getInstanceNodeId" return="K"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="com.google.inject.Key&lt;?&gt;"/>
    </method>
    <doc>
    <![CDATA[Factory for abstract identifiers for elements on the graph. Most graph nodes
 will correspond directly to {@link Key}s, but we do this for additional
 flexibility and because instances do not have separate {@link Key}s from the
 interfaces they are bound to.
 <p>
 Node IDs are treated as opaque values by {@link GraphingVisitor} and the
 other classes in this package.

 @author phopkins@gmail.com (Pete Hopkins)
 
 @param <K> The type for node IDs.]]>
    </doc>
  </interface>
  <!-- end interface com.google.inject.grapher.NodeIdFactory -->
  <!-- start interface com.google.inject.grapher.Renderer -->
  <interface name="Renderer"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="render"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <doc>
    <![CDATA[Interface for the service that renders the graph. It is assumed that the
 implementations for {@link BindingEdge.Factory},
 {@link ImplementationNode.Factory}, etc. will have direct access to the
 internals of the {@link Renderer} implementation, so the only external
 interface needed is the {@link #render()} call that {@link InjectorGrapher}
 calls when it's done.

 @author phopkins@gmail.com (Pete Hopkins)]]>
    </doc>
  </interface>
  <!-- end interface com.google.inject.grapher.Renderer -->
  <!-- start class com.google.inject.grapher.ShortNameFactory -->
  <class name="ShortNameFactory" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.inject.grapher.NameFactory"/>
    <constructor name="ShortNameFactory"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getMemberName" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="member" type="java.lang.reflect.Member"/>
    </method>
    <method name="getAnnotationName" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="com.google.inject.Key&lt;?&gt;"/>
    </method>
    <method name="getClassName" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="com.google.inject.Key&lt;?&gt;"/>
    </method>
    <method name="getInstanceName" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="instance" type="java.lang.Object"/>
    </method>
    <method name="getSourceName" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="source" type="java.lang.Object"/>
      <doc>
      <![CDATA[Returns a name for a Guice "source" object. This will typically be either
 a {@link StackTraceElement} for when the binding is made to the instance,
 or a {@link Method} when a provider method is used.]]>
      </doc>
    </method>
    <method name="getFileString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="stackTraceElement" type="java.lang.StackTraceElement"/>
    </method>
    <method name="getMethodString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="method" type="java.lang.reflect.Method"/>
    </method>
    <doc>
    <![CDATA[Reasonable implementation for {@link NameFactory}. Mostly takes various
 {@link Object#toString()}s and strips package names out of them so that
 they'll fit on the graph.

 @author phopkins@gmail.com (Pete Hopkins)]]>
    </doc>
  </class>
  <!-- end class com.google.inject.grapher.ShortNameFactory -->
  <!-- start class com.google.inject.grapher.StringNodeIdFactory -->
  <class name="StringNodeIdFactory" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.inject.grapher.NodeIdFactory&lt;java.lang.String&gt;"/>
    <constructor name="StringNodeIdFactory"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getClassNodeId" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="com.google.inject.Key&lt;?&gt;"/>
    </method>
    <method name="getInstanceNodeId" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="com.google.inject.Key&lt;?&gt;"/>
    </method>
    <doc>
    <![CDATA[{@link IdFactory} implementation that for {@link String} node IDs. The IDs
 are comprised of letters, numbers and underscores.

 @author phopkins@gmail.com (Pete Hopkins)]]>
    </doc>
  </class>
  <!-- end class com.google.inject.grapher.StringNodeIdFactory -->
  <!-- start class com.google.inject.grapher.TransitiveDependencyVisitor -->
  <class name="TransitiveDependencyVisitor" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.inject.spi.BindingTargetVisitor&lt;java.lang.Object, java.util.Collection&lt;com.google.inject.Key&lt;?&gt;&gt;&gt;"/>
    <constructor name="TransitiveDependencyVisitor"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="visit" return="java.util.Collection&lt;com.google.inject.Key&lt;?&gt;&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="binding" type="com.google.inject.spi.ConstructorBinding&lt;?&gt;"/>
    </method>
    <method name="visit" return="java.util.Collection&lt;com.google.inject.Key&lt;?&gt;&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="binding" type="com.google.inject.spi.ConvertedConstantBinding&lt;?&gt;"/>
    </method>
    <method name="visit" return="java.util.Collection&lt;com.google.inject.Key&lt;?&gt;&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="binding" type="com.google.inject.spi.ExposedBinding&lt;?&gt;"/>
    </method>
    <method name="visit" return="java.util.Collection&lt;com.google.inject.Key&lt;?&gt;&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="binding" type="com.google.inject.spi.InstanceBinding&lt;?&gt;"/>
    </method>
    <method name="visit" return="java.util.Collection&lt;com.google.inject.Key&lt;?&gt;&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="binding" type="com.google.inject.spi.LinkedKeyBinding&lt;?&gt;"/>
    </method>
    <method name="visit" return="java.util.Collection&lt;com.google.inject.Key&lt;?&gt;&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="binding" type="com.google.inject.spi.ProviderBinding&lt;?&gt;"/>
    </method>
    <method name="visit" return="java.util.Collection&lt;com.google.inject.Key&lt;?&gt;&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="binding" type="com.google.inject.spi.ProviderInstanceBinding&lt;?&gt;"/>
    </method>
    <method name="visit" return="java.util.Collection&lt;com.google.inject.Key&lt;?&gt;&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="binding" type="com.google.inject.spi.ProviderKeyBinding&lt;?&gt;"/>
    </method>
    <method name="visit" return="java.util.Collection&lt;com.google.inject.Key&lt;?&gt;&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="binding" type="com.google.inject.spi.UntargettedBinding&lt;?&gt;"/>
    </method>
    <doc>
    <![CDATA[{@link BindingTargetVisitor} that returns a {@link Collection} of the
 {@link Key}s of each {@link Binding}'s dependencies. Used by
 {@link InjectorGropher} to walk the dependency graph from a starting set of
 {@link Binding}s.

 @author phopkins@gmail.com (Pete Hopkins)]]>
    </doc>
  </class>
  <!-- end class com.google.inject.grapher.TransitiveDependencyVisitor -->
</package>
<package name="com.google.inject.grapher.graphviz">
  <!-- start class com.google.inject.grapher.graphviz.ArrowType -->
  <class name="ArrowType" extends="java.lang.Enum&lt;com.google.inject.grapher.graphviz.ArrowType&gt;"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="values" return="com.google.inject.grapher.graphviz.ArrowType[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="com.google.inject.grapher.graphviz.ArrowType"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Arrow symbols that are available from Graphviz. These can be composed by
 concatenation to make double arrows and such.
 <p>
 See: http://www.graphviz.org/doc/info/arrows.html

 @author phopkins@gmail.com (Pete Hopkins)]]>
    </doc>
  </class>
  <!-- end class com.google.inject.grapher.graphviz.ArrowType -->
  <!-- start class com.google.inject.grapher.graphviz.BindingEdgeFactory -->
  <class name="BindingEdgeFactory" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.inject.grapher.BindingEdge.Factory&lt;java.lang.String, com.google.inject.grapher.BindingEdge&lt;java.lang.String&gt;&gt;"/>
    <constructor name="BindingEdgeFactory" type="com.google.inject.grapher.graphviz.GraphvizRenderer"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="newBindingEdge" return="com.google.inject.grapher.BindingEdge&lt;java.lang.String&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="fromId" type="java.lang.String"/>
      <param name="toId" type="java.lang.String"/>
    </method>
    <method name="newAdaptor" return="com.google.inject.grapher.graphviz.BindingEdgeFactory.GraphvizEdgeAdaptor"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="edge" type="com.google.inject.grapher.graphviz.GraphvizEdge"/>
    </method>
    <doc>
    <![CDATA[Graphviz-specific implementation of {@link BindingEdge.Factory}. Uses a
 {@link GraphvizEdgeAdaptor} to delegate to a {@link GraphvizEdge}.

 @author phopkins@gmail.com (Pete Hopkins)]]>
    </doc>
  </class>
  <!-- end class com.google.inject.grapher.graphviz.BindingEdgeFactory -->
  <!-- start class com.google.inject.grapher.graphviz.BindingEdgeFactory.GraphvizEdgeAdaptor -->
  <class name="BindingEdgeFactory.GraphvizEdgeAdaptor" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="protected"
    deprecated="not deprecated">
    <implements name="com.google.inject.grapher.BindingEdge&lt;java.lang.String&gt;"/>
    <constructor name="BindingEdgeFactory.GraphvizEdgeAdaptor" type="com.google.inject.grapher.graphviz.GraphvizEdge"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="setType"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="com.google.inject.grapher.BindingEdge.Type"/>
    </method>
    <field name="edge" type="com.google.inject.grapher.graphviz.GraphvizEdge"
      transient="false" volatile="false"
      static="false" final="true" visibility="protected"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[Adaptor class that converts {@link BindingEdge} methods to display
 operations on a {@link GraphvizEdge}.]]>
    </doc>
  </class>
  <!-- end class com.google.inject.grapher.graphviz.BindingEdgeFactory.GraphvizEdgeAdaptor -->
  <!-- start class com.google.inject.grapher.graphviz.CompassPoint -->
  <class name="CompassPoint" extends="java.lang.Enum&lt;com.google.inject.grapher.graphviz.CompassPoint&gt;"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="values" return="com.google.inject.grapher.graphviz.CompassPoint[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="com.google.inject.grapher.graphviz.CompassPoint"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Enum for the "compass point" values used to control where edge
 end points appear on the graph.
 <p>
 See: http://www.graphviz.org/doc/info/attrs.html#k:portPos

 @author phopkins@gmail.com (Pete Hopkins)]]>
    </doc>
  </class>
  <!-- end class com.google.inject.grapher.graphviz.CompassPoint -->
  <!-- start class com.google.inject.grapher.graphviz.DependencyEdgeFactory -->
  <class name="DependencyEdgeFactory" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.inject.grapher.DependencyEdge.Factory&lt;java.lang.String, com.google.inject.grapher.DependencyEdge&lt;java.lang.String&gt;&gt;"/>
    <constructor name="DependencyEdgeFactory" type="com.google.inject.grapher.graphviz.GraphvizRenderer, com.google.inject.grapher.graphviz.PortIdFactory"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="newDependencyEdge" return="com.google.inject.grapher.DependencyEdge&lt;java.lang.String&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="fromId" type="java.lang.String"/>
      <param name="fromPoint" type="com.google.inject.spi.InjectionPoint"/>
      <param name="toId" type="java.lang.String"/>
    </method>
    <method name="newAdaptor" return="com.google.inject.grapher.graphviz.DependencyEdgeFactory.GraphvizEdgeAdaptor"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="edge" type="com.google.inject.grapher.graphviz.GraphvizEdge"/>
    </method>
    <doc>
    <![CDATA[Graphviz-specific implementation of {@link DependencyEdge.Factory}. Uses a
 {@link GraphvizEdgeAdaptor} to delegate to a {@link GraphvizEdge}.

 @author phopkins@gmail.com (Pete Hopkins)]]>
    </doc>
  </class>
  <!-- end class com.google.inject.grapher.graphviz.DependencyEdgeFactory -->
  <!-- start class com.google.inject.grapher.graphviz.DependencyEdgeFactory.GraphvizEdgeAdaptor -->
  <class name="DependencyEdgeFactory.GraphvizEdgeAdaptor" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="protected"
    deprecated="not deprecated">
    <implements name="com.google.inject.grapher.DependencyEdge&lt;java.lang.String&gt;"/>
    <constructor name="DependencyEdgeFactory.GraphvizEdgeAdaptor" type="com.google.inject.grapher.graphviz.GraphvizEdge"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <field name="edge" type="com.google.inject.grapher.graphviz.GraphvizEdge"
      transient="false" volatile="false"
      static="false" final="true" visibility="protected"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[Adaptor class that converts {@link DependencyEdge} methods to display
 operations on a {@link GraphvizEdge}.]]>
    </doc>
  </class>
  <!-- end class com.google.inject.grapher.graphviz.DependencyEdgeFactory.GraphvizEdgeAdaptor -->
  <!-- start class com.google.inject.grapher.graphviz.EdgeStyle -->
  <class name="EdgeStyle" extends="java.lang.Enum&lt;com.google.inject.grapher.graphviz.EdgeStyle&gt;"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="values" return="com.google.inject.grapher.graphviz.EdgeStyle[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="com.google.inject.grapher.graphviz.EdgeStyle"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Styles for edges.
 <p>
 See: http://www.graphviz.org/doc/info/attrs.html#k:style

 @author phopkins@gmail.com (Pete Hopkins)]]>
    </doc>
  </class>
  <!-- end class com.google.inject.grapher.graphviz.EdgeStyle -->
  <!-- start class com.google.inject.grapher.graphviz.GraphvizEdge -->
  <class name="GraphvizEdge" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="GraphvizEdge" type="java.lang.String, java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getHeadNodeId" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getHeadPortId" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setHeadPortId"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="headPortId" type="java.lang.String"/>
    </method>
    <method name="getHeadCompassPoint" return="com.google.inject.grapher.graphviz.CompassPoint"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setHeadCompassPoint"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="headCompassPoint" type="com.google.inject.grapher.graphviz.CompassPoint"/>
    </method>
    <method name="getArrowHead" return="java.util.List&lt;com.google.inject.grapher.graphviz.ArrowType&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setArrowHead"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="arrowHead" type="java.util.List&lt;com.google.inject.grapher.graphviz.ArrowType&gt;"/>
    </method>
    <method name="getTailNodeId" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getTailPortId" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setTailPortId"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="tailPortId" type="java.lang.String"/>
    </method>
    <method name="getTailCompassPoint" return="com.google.inject.grapher.graphviz.CompassPoint"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setTailCompassPoint"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="tailCompassPoint" type="com.google.inject.grapher.graphviz.CompassPoint"/>
    </method>
    <method name="getArrowTail" return="java.util.List&lt;com.google.inject.grapher.graphviz.ArrowType&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setArrowTail"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="arrowTail" type="java.util.List&lt;com.google.inject.grapher.graphviz.ArrowType&gt;"/>
    </method>
    <method name="getStyle" return="com.google.inject.grapher.graphviz.EdgeStyle"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setStyle"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="style" type="com.google.inject.grapher.graphviz.EdgeStyle"/>
    </method>
    <doc>
    <![CDATA[Data object to encapsulate the attributes of Graphviz edges that we're
 interested in drawing.

 @author phopkins@gmail.com (Pete Hopkins)]]>
    </doc>
  </class>
  <!-- end class com.google.inject.grapher.graphviz.GraphvizEdge -->
  <!-- start class com.google.inject.grapher.graphviz.GraphvizModule -->
  <class name="GraphvizModule" extends="com.google.inject.AbstractModule"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="GraphvizModule"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="configure"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Module that provides {@link GraphvizRenderer} as the {@link Renderer} and
 binds the other Graphviz factories.

 @author phopkins@gmail.com (Pete Hopkins)]]>
    </doc>
  </class>
  <!-- end class com.google.inject.grapher.graphviz.GraphvizModule -->
  <!-- start class com.google.inject.grapher.graphviz.GraphvizNode -->
  <class name="GraphvizNode" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="GraphvizNode" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getNodeId" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getShape" return="com.google.inject.grapher.graphviz.NodeShape"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setShape"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="shape" type="com.google.inject.grapher.graphviz.NodeShape"/>
    </method>
    <method name="getStyle" return="com.google.inject.grapher.graphviz.NodeStyle"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setStyle"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="style" type="com.google.inject.grapher.graphviz.NodeStyle"/>
    </method>
    <method name="getTitle" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setTitle"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="title" type="java.lang.String"/>
    </method>
    <method name="getSubtitles" return="java.util.List&lt;java.lang.String&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="addSubtitle"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="position" type="int"/>
      <param name="subtitle" type="java.lang.String"/>
    </method>
    <method name="getHeaderTextColor" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setHeaderTextColor"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="headerTextColor" type="java.lang.String"/>
    </method>
    <method name="getHeaderBackgroundColor" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setHeaderBackgroundColor"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="headerBackgroundColor" type="java.lang.String"/>
    </method>
    <method name="addField"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="portId" type="java.lang.String"/>
      <param name="title" type="java.lang.String"/>
    </method>
    <method name="getFields" return="java.util.Map&lt;java.lang.String, java.lang.String&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Data object to encapsulate the attributes of Graphviz nodes that we're
 interested in drawing.

 @author phopkins@gmail.com (Pete Hopkins)]]>
    </doc>
  </class>
  <!-- end class com.google.inject.grapher.graphviz.GraphvizNode -->
  <!-- start class com.google.inject.grapher.graphviz.GraphvizRenderer -->
  <class name="GraphvizRenderer" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.inject.grapher.Renderer"/>
    <implements name="com.google.inject.grapher.NodeAliasFactory&lt;java.lang.String&gt;"/>
    <constructor name="GraphvizRenderer"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="setOut" return="com.google.inject.grapher.graphviz.GraphvizRenderer"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="out" type="java.io.PrintWriter"/>
    </method>
    <method name="setRankdir" return="com.google.inject.grapher.graphviz.GraphvizRenderer"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="rankdir" type="java.lang.String"/>
    </method>
    <method name="addNode"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="node" type="com.google.inject.grapher.graphviz.GraphvizNode"/>
    </method>
    <method name="addEdge"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="edge" type="com.google.inject.grapher.graphviz.GraphvizEdge"/>
    </method>
    <method name="newAlias"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="fromId" type="java.lang.String"/>
      <param name="toId" type="java.lang.String"/>
    </method>
    <method name="resolveAlias" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="id" type="java.lang.String"/>
    </method>
    <method name="render"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getGraphAttributes" return="java.util.Map&lt;java.lang.String, java.lang.String&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </method>
    <method name="start"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </method>
    <method name="finish"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </method>
    <method name="renderNode"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="node" type="com.google.inject.grapher.graphviz.GraphvizNode"/>
    </method>
    <method name="getNodeAttributes" return="java.util.Map&lt;java.lang.String, java.lang.String&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="node" type="com.google.inject.grapher.graphviz.GraphvizNode"/>
    </method>
    <method name="getNodeLabel" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="node" type="com.google.inject.grapher.graphviz.GraphvizNode"/>
      <doc>
      <![CDATA[Creates the "label" for a node. This is a string of HTML that defines a
 table with a heading at the top and (in the case of
 {@link ImplementationNode}s) rows for each of the member fields.]]>
      </doc>
    </method>
    <method name="renderEdge"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="edge" type="com.google.inject.grapher.graphviz.GraphvizEdge"/>
    </method>
    <method name="getEdgeAttributes" return="java.util.Map&lt;java.lang.String, java.lang.String&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="edge" type="com.google.inject.grapher.graphviz.GraphvizEdge"/>
    </method>
    <method name="getArrowString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="arrows" type="java.util.List&lt;com.google.inject.grapher.graphviz.ArrowType&gt;"/>
      <doc>
      <![CDATA[Turns a {@link List} of {@link ArrowType}s into a {@link String} that
 represents combining them. With Graphviz, that just means concatenating
 them.]]>
      </doc>
    </method>
    <method name="getEdgeEndPoint" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="nodeId" type="java.lang.String"/>
      <param name="portId" type="java.lang.String"/>
      <param name="compassPoint" type="com.google.inject.grapher.graphviz.CompassPoint"/>
    </method>
    <method name="htmlEscape" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="str" type="java.lang.String"/>
    </method>
    <doc>
    <![CDATA[{@link Renderer} implementation that writes out a Graphviz DOT file of the
 graph. Bound in {@link GraphvizModule}.
 <p>
 Specify the {@link PrintWriter} to output to with
 {@link #setOut(PrintWriter)}.

 @author phopkins@gmail.com (Pete Hopkins)]]>
    </doc>
  </class>
  <!-- end class com.google.inject.grapher.graphviz.GraphvizRenderer -->
  <!-- start class com.google.inject.grapher.graphviz.ImplementationNodeFactory -->
  <class name="ImplementationNodeFactory" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.inject.grapher.ImplementationNode.Factory&lt;java.lang.String, com.google.inject.grapher.ImplementationNode&lt;java.lang.String&gt;&gt;"/>
    <constructor name="ImplementationNodeFactory" type="com.google.inject.grapher.graphviz.GraphvizRenderer, com.google.inject.grapher.NameFactory, com.google.inject.grapher.graphviz.PortIdFactory"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="newImplementationNode" return="com.google.inject.grapher.ImplementationNode&lt;java.lang.String&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="nodeId" type="java.lang.String"/>
    </method>
    <method name="newAdaptor" return="com.google.inject.grapher.graphviz.ImplementationNodeFactory.GraphvizNodeAdaptor"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="node" type="com.google.inject.grapher.graphviz.GraphvizNode"/>
    </method>
    <doc>
    <![CDATA[Graphviz-specific implementation of {@link ImplementationNode.Factory}. Uses
 a {@link GraphvizEdgeAdaptor} to delegate to a {@link GraphvizNode}.

 @author phopkins@gmail.com (Pete Hopkins)]]>
    </doc>
  </class>
  <!-- end class com.google.inject.grapher.graphviz.ImplementationNodeFactory -->
  <!-- start class com.google.inject.grapher.graphviz.ImplementationNodeFactory.GraphvizNodeAdaptor -->
  <class name="ImplementationNodeFactory.GraphvizNodeAdaptor" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="protected"
    deprecated="not deprecated">
    <implements name="com.google.inject.grapher.ImplementationNode&lt;java.lang.String&gt;"/>
    <constructor name="ImplementationNodeFactory.GraphvizNodeAdaptor" type="com.google.inject.grapher.graphviz.GraphvizNode"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="setClassKey"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="com.google.inject.Key&lt;?&gt;"/>
    </method>
    <method name="setInstance"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="instance" type="java.lang.Object"/>
    </method>
    <method name="setSource"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="source" type="java.lang.Object"/>
    </method>
    <method name="addMember"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="member" type="java.lang.reflect.Member"/>
    </method>
    <field name="node" type="com.google.inject.grapher.graphviz.GraphvizNode"
      transient="false" volatile="false"
      static="false" final="true" visibility="protected"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[Adaptor class that converts {@link ImplementationNode} methods to display
 operations on a {@link GraphvizNode}.]]>
    </doc>
  </class>
  <!-- end class com.google.inject.grapher.graphviz.ImplementationNodeFactory.GraphvizNodeAdaptor -->
  <!-- start class com.google.inject.grapher.graphviz.InterfaceNodeFactory -->
  <class name="InterfaceNodeFactory" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.inject.grapher.InterfaceNode.Factory&lt;java.lang.String, com.google.inject.grapher.InterfaceNode&lt;java.lang.String&gt;&gt;"/>
    <constructor name="InterfaceNodeFactory" type="com.google.inject.grapher.graphviz.GraphvizRenderer, com.google.inject.grapher.NameFactory"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="newInterfaceNode" return="com.google.inject.grapher.InterfaceNode&lt;java.lang.String&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="nodeId" type="java.lang.String"/>
    </method>
    <doc>
    <![CDATA[Graphviz-specific implementation of {@link InterfaceNode.Factory}. Uses
 a {@link GraphvizEdgeAdaptor} to delegate to a {@link GraphvizNode}.

 @author phopkins@gmail.com (Pete Hopkins)]]>
    </doc>
  </class>
  <!-- end class com.google.inject.grapher.graphviz.InterfaceNodeFactory -->
  <!-- start class com.google.inject.grapher.graphviz.InterfaceNodeFactory.GraphvizNodeAdaptor -->
  <class name="InterfaceNodeFactory.GraphvizNodeAdaptor" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="protected"
    deprecated="not deprecated">
    <implements name="com.google.inject.grapher.InterfaceNode&lt;java.lang.String&gt;"/>
    <constructor name="InterfaceNodeFactory.GraphvizNodeAdaptor" type="com.google.inject.grapher.graphviz.GraphvizNode"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="setKey"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="com.google.inject.Key&lt;?&gt;"/>
    </method>
    <method name="setSource"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="source" type="java.lang.Object"/>
    </method>
    <field name="node" type="com.google.inject.grapher.graphviz.GraphvizNode"
      transient="false" volatile="false"
      static="false" final="true" visibility="protected"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[Adaptor class that converts {@link InterfaceNode} methods to display
 operations on a {@link GraphvizNode}.]]>
    </doc>
  </class>
  <!-- end class com.google.inject.grapher.graphviz.InterfaceNodeFactory.GraphvizNodeAdaptor -->
  <!-- start class com.google.inject.grapher.graphviz.NodeShape -->
  <class name="NodeShape" extends="java.lang.Enum&lt;com.google.inject.grapher.graphviz.NodeShape&gt;"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="values" return="com.google.inject.grapher.graphviz.NodeShape[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="com.google.inject.grapher.graphviz.NodeShape"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Enum for the shapes that are most interesting for Guice graphing.
 <p>
 See: http://www.graphviz.org/doc/info/shapes.html
 
 @author phopkins@gmail.com (Pete Hopkins)]]>
    </doc>
  </class>
  <!-- end class com.google.inject.grapher.graphviz.NodeShape -->
  <!-- start class com.google.inject.grapher.graphviz.NodeStyle -->
  <class name="NodeStyle" extends="java.lang.Enum&lt;com.google.inject.grapher.graphviz.NodeStyle&gt;"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="values" return="com.google.inject.grapher.graphviz.NodeStyle[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="com.google.inject.grapher.graphviz.NodeStyle"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Styles for nodes. Similar to {@link EdgeStyle} but with a few more options.
 <p>
 See: http://www.graphviz.org/doc/info/attrs.html#k:style

 @author phopkins@gmail.com (Pete Hopkins)]]>
    </doc>
  </class>
  <!-- end class com.google.inject.grapher.graphviz.NodeStyle -->
  <!-- start interface com.google.inject.grapher.graphviz.PortIdFactory -->
  <interface name="PortIdFactory"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="getPortId" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="member" type="java.lang.reflect.Member"/>
    </method>
    <doc>
    <![CDATA[Interface for a service that returns Graphviz port IDs, used for naming the
 rows in {@link ImplementationNode}-displaying {@link GraphvizNode}s.
 Implemented by {@link StringNodeIdFactory}.

 @author phopkins@gmail.com (Pete Hopkins)]]>
    </doc>
  </interface>
  <!-- end interface com.google.inject.grapher.graphviz.PortIdFactory -->
  <!-- start class com.google.inject.grapher.graphviz.PortIdFactoryImpl -->
  <class name="PortIdFactoryImpl" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.inject.grapher.graphviz.PortIdFactory"/>
    <constructor name="PortIdFactoryImpl"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getPortId" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="member" type="java.lang.reflect.Member"/>
    </method>
    <doc>
    <![CDATA[Implementation of {@link PortIdFactory}. Bound in {@link GraphvizModule}.

 @author phopkins@gmail.com (Pete Hopkins)]]>
    </doc>
  </class>
  <!-- end class com.google.inject.grapher.graphviz.PortIdFactoryImpl -->
</package>
<package name="com.google.inject.jndi">
  <!-- start class com.google.inject.jndi.JndiIntegration -->
  <class name="JndiIntegration" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="fromJndi" return="com.google.inject.Provider&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="java.lang.Class&lt;T&gt;"/>
      <param name="name" type="java.lang.String"/>
      <doc>
      <![CDATA[Creates a provider which looks up objects in JNDI using the given name.
 Example usage:

 <pre>
 bind(DataSource.class).toProvider(fromJndi(DataSource.class, "java:..."));
 </pre>]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Integrates Guice with JNDI. Requires a binding to 
 {@link javax.naming.Context}.

 @author crazybob@google.com (Bob Lee)]]>
    </doc>
  </class>
  <!-- end class com.google.inject.jndi.JndiIntegration -->
</package>
<package name="com.google.inject.matcher">
  <!-- start class com.google.inject.matcher.AbstractMatcher -->
  <class name="AbstractMatcher" extends="java.lang.Object"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.inject.matcher.Matcher&lt;T&gt;"/>
    <constructor name="AbstractMatcher"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="and" return="com.google.inject.matcher.Matcher&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="other" type="com.google.inject.matcher.Matcher&lt;? super T&gt;"/>
    </method>
    <method name="or" return="com.google.inject.matcher.Matcher&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="other" type="com.google.inject.matcher.Matcher&lt;? super T&gt;"/>
    </method>
    <doc>
    <![CDATA[Implements {@code and()} and {@code or()}.

 @author crazybob@google.com (Bob Lee)]]>
    </doc>
  </class>
  <!-- end class com.google.inject.matcher.AbstractMatcher -->
  <!-- start interface com.google.inject.matcher.Matcher -->
  <interface name="Matcher"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="matches" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="t" type="T"/>
      <doc>
      <![CDATA[Returns {@code true} if this matches {@code t}, {@code false} otherwise.]]>
      </doc>
    </method>
    <method name="and" return="com.google.inject.matcher.Matcher&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="other" type="com.google.inject.matcher.Matcher&lt;? super T&gt;"/>
      <doc>
      <![CDATA[Returns a new matcher which returns {@code true} if both this and the
 given matcher return {@code true}.]]>
      </doc>
    </method>
    <method name="or" return="com.google.inject.matcher.Matcher&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="other" type="com.google.inject.matcher.Matcher&lt;? super T&gt;"/>
      <doc>
      <![CDATA[Returns a new matcher which returns {@code true} if either this or the
 given matcher return {@code true}.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Returns {@code true} or {@code false} for a given input.

 @author crazybob@google.com (Bob Lee)]]>
    </doc>
  </interface>
  <!-- end interface com.google.inject.matcher.Matcher -->
  <!-- start class com.google.inject.matcher.Matchers -->
  <class name="Matchers" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="any" return="com.google.inject.matcher.Matcher&lt;java.lang.Object&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a matcher which matches any input.]]>
      </doc>
    </method>
    <method name="not" return="com.google.inject.matcher.Matcher&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="p" type="com.google.inject.matcher.Matcher&lt;? super T&gt;"/>
      <doc>
      <![CDATA[Inverts the given matcher.]]>
      </doc>
    </method>
    <method name="annotatedWith" return="com.google.inject.matcher.Matcher&lt;java.lang.reflect.AnnotatedElement&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="annotationType" type="java.lang.Class&lt;? extends java.lang.annotation.Annotation&gt;"/>
      <doc>
      <![CDATA[Returns a matcher which matches elements (methods, classes, etc.)
 with a given annotation.]]>
      </doc>
    </method>
    <method name="annotatedWith" return="com.google.inject.matcher.Matcher&lt;java.lang.reflect.AnnotatedElement&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="annotation" type="java.lang.annotation.Annotation"/>
      <doc>
      <![CDATA[Returns a matcher which matches elements (methods, classes, etc.)
 with a given annotation.]]>
      </doc>
    </method>
    <method name="subclassesOf" return="com.google.inject.matcher.Matcher&lt;java.lang.Class&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="superclass" type="java.lang.Class&lt;?&gt;"/>
      <doc>
      <![CDATA[Returns a matcher which matches subclasses of the given type (as well as
 the given type).]]>
      </doc>
    </method>
    <method name="only" return="com.google.inject.matcher.Matcher&lt;java.lang.Object&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="java.lang.Object"/>
      <doc>
      <![CDATA[Returns a matcher which matches objects equal to the given object.]]>
      </doc>
    </method>
    <method name="identicalTo" return="com.google.inject.matcher.Matcher&lt;java.lang.Object&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="java.lang.Object"/>
      <doc>
      <![CDATA[Returns a matcher which matches only the given object.]]>
      </doc>
    </method>
    <method name="inPackage" return="com.google.inject.matcher.Matcher&lt;java.lang.Class&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="targetPackage" type="java.lang.Package"/>
      <doc>
      <![CDATA[Returns a matcher which matches classes in the given package. Packages are specific to their
 classloader, so classes with the same package name may not have the same package at runtime.]]>
      </doc>
    </method>
    <method name="inSubpackage" return="com.google.inject.matcher.Matcher&lt;java.lang.Class&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="targetPackageName" type="java.lang.String"/>
      <doc>
      <![CDATA[Returns a matcher which matches classes in the given package and its subpackages. Unlike
 {@link #inPackage(Package) inPackage()}, this matches classes from any classloader.
 
 @since 2.0]]>
      </doc>
    </method>
    <method name="returns" return="com.google.inject.matcher.Matcher&lt;java.lang.reflect.Method&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="returnType" type="com.google.inject.matcher.Matcher&lt;? super java.lang.Class&lt;?&gt;&gt;"/>
      <doc>
      <![CDATA[Returns a matcher which matches methods with matching return types.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Matcher implementations. Supports matching classes and methods.

 @author crazybob@google.com (Bob Lee)]]>
    </doc>
  </class>
  <!-- end class com.google.inject.matcher.Matchers -->
</package>
<package name="com.google.inject.multibindings">
  <!-- start class com.google.inject.multibindings.MapBinder -->
  <class name="MapBinder" extends="java.lang.Object"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="newMapBinder" return="com.google.inject.multibindings.MapBinder&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="binder" type="com.google.inject.Binder"/>
      <param name="keyType" type="com.google.inject.TypeLiteral&lt;K&gt;"/>
      <param name="valueType" type="com.google.inject.TypeLiteral&lt;V&gt;"/>
      <doc>
      <![CDATA[Returns a new mapbinder that collects entries of {@code keyType}/{@code valueType} in a
 {@link Map} that is itself bound with no binding annotation.]]>
      </doc>
    </method>
    <method name="newMapBinder" return="com.google.inject.multibindings.MapBinder&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="binder" type="com.google.inject.Binder"/>
      <param name="keyType" type="java.lang.Class&lt;K&gt;"/>
      <param name="valueType" type="java.lang.Class&lt;V&gt;"/>
      <doc>
      <![CDATA[Returns a new mapbinder that collects entries of {@code keyType}/{@code valueType} in a
 {@link Map} that is itself bound with no binding annotation.]]>
      </doc>
    </method>
    <method name="newMapBinder" return="com.google.inject.multibindings.MapBinder&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="binder" type="com.google.inject.Binder"/>
      <param name="keyType" type="com.google.inject.TypeLiteral&lt;K&gt;"/>
      <param name="valueType" type="com.google.inject.TypeLiteral&lt;V&gt;"/>
      <param name="annotation" type="java.lang.annotation.Annotation"/>
      <doc>
      <![CDATA[Returns a new mapbinder that collects entries of {@code keyType}/{@code valueType} in a
 {@link Map} that is itself bound with {@code annotation}.]]>
      </doc>
    </method>
    <method name="newMapBinder" return="com.google.inject.multibindings.MapBinder&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="binder" type="com.google.inject.Binder"/>
      <param name="keyType" type="java.lang.Class&lt;K&gt;"/>
      <param name="valueType" type="java.lang.Class&lt;V&gt;"/>
      <param name="annotation" type="java.lang.annotation.Annotation"/>
      <doc>
      <![CDATA[Returns a new mapbinder that collects entries of {@code keyType}/{@code valueType} in a
 {@link Map} that is itself bound with {@code annotation}.]]>
      </doc>
    </method>
    <method name="newMapBinder" return="com.google.inject.multibindings.MapBinder&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="binder" type="com.google.inject.Binder"/>
      <param name="keyType" type="com.google.inject.TypeLiteral&lt;K&gt;"/>
      <param name="valueType" type="com.google.inject.TypeLiteral&lt;V&gt;"/>
      <param name="annotationType" type="java.lang.Class&lt;? extends java.lang.annotation.Annotation&gt;"/>
      <doc>
      <![CDATA[Returns a new mapbinder that collects entries of {@code keyType}/{@code valueType} in a
 {@link Map} that is itself bound with {@code annotationType}.]]>
      </doc>
    </method>
    <method name="newMapBinder" return="com.google.inject.multibindings.MapBinder&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="binder" type="com.google.inject.Binder"/>
      <param name="keyType" type="java.lang.Class&lt;K&gt;"/>
      <param name="valueType" type="java.lang.Class&lt;V&gt;"/>
      <param name="annotationType" type="java.lang.Class&lt;? extends java.lang.annotation.Annotation&gt;"/>
      <doc>
      <![CDATA[Returns a new mapbinder that collects entries of {@code keyType}/{@code valueType} in a
 {@link Map} that is itself bound with {@code annotationType}.]]>
      </doc>
    </method>
    <method name="permitDuplicates" return="com.google.inject.multibindings.MapBinder&lt;K, V&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Configures the {@code MapBinder} to handle duplicate entries.
 <p>When multiple equal keys are bound, the value that gets included in the map is
 arbitrary.
 <p>In addition to the {@code Map<K, V>} and {@code Map<K, Provider<V>>}
 maps that are normally bound, a {@code Map<K, Set<V>>} and
 {@code Map<K, Set<Provider<V>>>} are <em>also</em> bound, which contain
 all values bound to each key.
 <p>
 When multiple modules contribute elements to the map, this configuration
 option impacts all of them.

 @return this map binder
 @since 3.0]]>
      </doc>
    </method>
    <method name="addBinding" return="com.google.inject.binder.LinkedBindingBuilder&lt;V&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="K"/>
      <doc>
      <![CDATA[Returns a binding builder used to add a new entry in the map. Each
 key must be distinct (and non-null). Bound providers will be evaluated each
 time the map is injected.

 <p>It is an error to call this method without also calling one of the
 {@code to} methods on the returned binding builder.

 <p>Scoping elements independently is supported. Use the {@code in} method
 to specify a binding scope.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[An API to bind multiple map entries separately, only to later inject them as
 a complete map. MapBinder is intended for use in your application's module:
 <pre><code>
 public class SnacksModule extends AbstractModule {
   protected void configure() {
     MapBinder&lt;String, Snack&gt; mapbinder
         = MapBinder.newMapBinder(binder(), String.class, Snack.class);
     mapbinder.addBinding("twix").toInstance(new Twix());
     mapbinder.addBinding("snickers").toProvider(SnickersProvider.class);
     mapbinder.addBinding("skittles").to(Skittles.class);
   }
 }</code></pre>

 <p>With this binding, a {@link Map}{@code <String, Snack>} can now be
 injected:
 <pre><code>
 class SnackMachine {
   {@literal @}Inject
   public SnackMachine(Map&lt;String, Snack&gt; snacks) { ... }
 }</code></pre>

 <p>In addition to binding {@code Map<K, V>}, a mapbinder will also bind
 {@code Map<K, Provider<V>>} for lazy value provision:
 <pre><code>
 class SnackMachine {
   {@literal @}Inject
   public SnackMachine(Map&lt;String, Provider&lt;Snack&gt;&gt; snackProviders) { ... }
 }</code></pre>

 <p>Contributing mapbindings from different modules is supported. For example,
 it is okay to have both {@code CandyModule} and {@code ChipsModule} both
 create their own {@code MapBinder<String, Snack>}, and to each contribute
 bindings to the snacks map. When that map is injected, it will contain
 entries from both modules.

 <p>The map's iteration order is consistent with the binding order. This is
 convenient when multiple elements are contributed by the same module because
 that module can order its bindings appropriately. Avoid relying on the
 iteration order of elements contributed by different modules, since there is
 no equivalent mechanism to order modules.
 
 <p>The map is unmodifiable.  Elements can only be added to the map by
 configuring the MapBinder.  Elements can never be removed from the map.

 <p>Values are resolved at map injection time. If a value is bound to a
 provider, that provider's get method will be called each time the map is
 injected (unless the binding is also scoped, or a map of providers is injected).

 <p>Annotations are used to create different maps of the same key/value
 type. Each distinct annotation gets its own independent map.

 <p><strong>Keys must be distinct.</strong> If the same key is bound more than
 once, map injection will fail. However, use {@link #permitDuplicates()} in
 order to allow duplicate keys; extra bindings to {@code Map<K, Set<V>>} and
 {@code Map<K, Set<Provider<V>>} will be added.

 <p><strong>Keys must be non-null.</strong> {@code addBinding(null)} will
 throw an unchecked exception.

 <p><strong>Values must be non-null to use map injection.</strong> If any
 value is null, map injection will fail (although injecting a map of providers
 will not).

 @author dpb@google.com (David P. Baker)]]>
    </doc>
  </class>
  <!-- end class com.google.inject.multibindings.MapBinder -->
  <!-- start interface com.google.inject.multibindings.MapBinderBinding -->
  <interface name="MapBinderBinding"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="getMapKey" return="com.google.inject.Key&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the {@link Key} for the map.]]>
      </doc>
    </method>
    <method name="getKeyTypeLiteral" return="com.google.inject.TypeLiteral&lt;?&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the TypeLiteral describing the keys of the map.
 <p>
 The TypeLiteral will always match the type Map's generic type. For example, if getMapKey
 returns a key of <code>Map&lt;String, Snack></code>, then this will always return a
 <code>TypeLiteral&lt;String></code>.]]>
      </doc>
    </method>
    <method name="getValueTypeLiteral" return="com.google.inject.TypeLiteral&lt;?&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the TypeLiteral describing the values of the map.
 <p>
 The TypeLiteral will always match the type Map's generic type. For example, if getMapKey
 returns a key of <code>Map&lt;String, Snack></code>, then this will always return a
 <code>TypeLiteral&lt;Snack></code>.]]>
      </doc>
    </method>
    <method name="getEntries" return="java.util.List&lt;java.util.Map.Entry&lt;?, com.google.inject.Binding&lt;?&gt;&gt;&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns all entries in the Map. The returned list of Map.Entries contains the key and a binding
 to the value. Duplicate keys or values will exist as separate Map.Entries in the returned list.
 This is only supported on bindings returned from an injector. This will throw
 {@link UnsupportedOperationException} if it is called on an element retrieved from
 {@link Elements#getElements}.
 <p>
 The elements will always match the type Map's generic type. For example, if getMapKey returns a
 key of <code>Map&lt;String, Snack></code>, then this will always return a list of type
 <code>List&lt;Map.Entry&lt;String, Binding&lt;Snack>>></code>.]]>
      </doc>
    </method>
    <method name="permitsDuplicates" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns true if the MapBinder permits duplicates. This is only supported on bindings returned
 from an injector. This will throw {@link UnsupportedOperationException} if it is called on a
 MapBinderBinding retrieved from {@link Elements#getElements}.]]>
      </doc>
    </method>
    <method name="containsElement" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="element" type="com.google.inject.spi.Element"/>
      <doc>
      <![CDATA[Returns true if this MapBinder contains the given Element in order to build the map or uses the
 given Element in order to support building and injecting the map. This will work for
 MapBinderBindings retrieved from an injector and {@link Elements#getElements}. Usually this is
 only necessary if you are working with elements retrieved from modules (without an Injector),
 otherwise {@link #getEntries} and {@link #permitsDuplicates} are better options.
 <p>
 If you need to introspect the details of the map, such as the keys, values or if it permits
 duplicates, it is necessary to pass the elements through an Injector and use
 {@link #getEntries()} and {@link #permitsDuplicates()}.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A binding for a MapBinder.
 <p>
 Although MapBinders may be injected through a variety of generic types (Map&lt;K, V>, Map
 &lt;K, Provider&lt;V>>, Map&lt;K, Set&lt;V>>, Map<K, Set&lt;
 Provider&lt;V>>, and even Set&lt;Map.Entry&lt;K, Provider&lt;V>>), a
 MapBinderBinding exists only on the Binding associated with the Map&lt;K, V> key. Other
 bindings can be validated to be derived from this MapBinderBinding using
 {@link #containsElement(Element)}.
 
 @param <T> The fully qualified type of the map, including Map. For example:
          <code>MapBinderBinding&lt;Map&lt;String, Snack>></code>
 
 @since 3.0
 @author sameb@google.com (Sam Berlin)]]>
    </doc>
  </interface>
  <!-- end interface com.google.inject.multibindings.MapBinderBinding -->
  <!-- start class com.google.inject.multibindings.Multibinder -->
  <class name="Multibinder" extends="java.lang.Object"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="newSetBinder" return="com.google.inject.multibindings.Multibinder&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="binder" type="com.google.inject.Binder"/>
      <param name="type" type="com.google.inject.TypeLiteral&lt;T&gt;"/>
      <doc>
      <![CDATA[Returns a new multibinder that collects instances of {@code type} in a {@link Set} that is
 itself bound with no binding annotation.]]>
      </doc>
    </method>
    <method name="newSetBinder" return="com.google.inject.multibindings.Multibinder&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="binder" type="com.google.inject.Binder"/>
      <param name="type" type="java.lang.Class&lt;T&gt;"/>
      <doc>
      <![CDATA[Returns a new multibinder that collects instances of {@code type} in a {@link Set} that is
 itself bound with no binding annotation.]]>
      </doc>
    </method>
    <method name="newSetBinder" return="com.google.inject.multibindings.Multibinder&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="binder" type="com.google.inject.Binder"/>
      <param name="type" type="com.google.inject.TypeLiteral&lt;T&gt;"/>
      <param name="annotation" type="java.lang.annotation.Annotation"/>
      <doc>
      <![CDATA[Returns a new multibinder that collects instances of {@code type} in a {@link Set} that is
 itself bound with {@code annotation}.]]>
      </doc>
    </method>
    <method name="newSetBinder" return="com.google.inject.multibindings.Multibinder&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="binder" type="com.google.inject.Binder"/>
      <param name="type" type="java.lang.Class&lt;T&gt;"/>
      <param name="annotation" type="java.lang.annotation.Annotation"/>
      <doc>
      <![CDATA[Returns a new multibinder that collects instances of {@code type} in a {@link Set} that is
 itself bound with {@code annotation}.]]>
      </doc>
    </method>
    <method name="newSetBinder" return="com.google.inject.multibindings.Multibinder&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="binder" type="com.google.inject.Binder"/>
      <param name="type" type="com.google.inject.TypeLiteral&lt;T&gt;"/>
      <param name="annotationType" type="java.lang.Class&lt;? extends java.lang.annotation.Annotation&gt;"/>
      <doc>
      <![CDATA[Returns a new multibinder that collects instances of {@code type} in a {@link Set} that is
 itself bound with {@code annotationType}.]]>
      </doc>
    </method>
    <method name="newSetBinder" return="com.google.inject.multibindings.Multibinder&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="binder" type="com.google.inject.Binder"/>
      <param name="type" type="java.lang.Class&lt;T&gt;"/>
      <param name="annotationType" type="java.lang.Class&lt;? extends java.lang.annotation.Annotation&gt;"/>
      <doc>
      <![CDATA[Returns a new multibinder that collects instances of {@code type} in a {@link Set} that is
 itself bound with {@code annotationType}.]]>
      </doc>
    </method>
    <method name="permitDuplicates" return="com.google.inject.multibindings.Multibinder&lt;T&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Configures the bound set to silently discard duplicate elements. When multiple equal values are
 bound, the one that gets included is arbitrary. When multiple modules contribute elements to
 the set, this configuration option impacts all of them.

 @return this multibinder
 @since 3.0]]>
      </doc>
    </method>
    <method name="addBinding" return="com.google.inject.binder.LinkedBindingBuilder&lt;T&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a binding builder used to add a new element in the set. Each
 bound element must have a distinct value. Bound providers will be
 evaluated each time the set is injected.

 <p>It is an error to call this method without also calling one of the
 {@code to} methods on the returned binding builder.

 <p>Scoping elements independently is supported. Use the {@code in} method
 to specify a binding scope.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[An API to bind multiple values separately, only to later inject them as a
 complete collection. Multibinder is intended for use in your application's
 module:
 <pre><code>
 public class SnacksModule extends AbstractModule {
   protected void configure() {
     Multibinder&lt;Snack&gt; multibinder
         = Multibinder.newSetBinder(binder(), Snack.class);
     multibinder.addBinding().toInstance(new Twix());
     multibinder.addBinding().toProvider(SnickersProvider.class);
     multibinder.addBinding().to(Skittles.class);
   }
 }</code></pre>

 <p>With this binding, a {@link Set}{@code <Snack>} can now be injected:
 <pre><code>
 class SnackMachine {
   {@literal @}Inject
   public SnackMachine(Set&lt;Snack&gt; snacks) { ... }
 }</code></pre>

 <p>Contributing multibindings from different modules is supported. For
 example, it is okay to have both {@code CandyModule} and {@code ChipsModule}
 to both create their own {@code Multibinder<Snack>}, and to each contribute
 bindings to the set of snacks. When that set is injected, it will contain
 elements from both modules.
 
 <p>The set's iteration order is consistent with the binding order. This is
 convenient when multiple elements are contributed by the same module because
 that module can order its bindings appropriately. Avoid relying on the
 iteration order of elements contributed by different modules, since there is
 no equivalent mechanism to order modules.
 
 <p>The set is unmodifiable.  Elements can only be added to the set by
 configuring the multibinder.  Elements can never be removed from the set.

 <p>Elements are resolved at set injection time. If an element is bound to a
 provider, that provider's get method will be called each time the set is
 injected (unless the binding is also scoped).

 <p>Annotations are be used to create different sets of the same element
 type. Each distinct annotation gets its own independent collection of
 elements.

 <p><strong>Elements must be distinct.</strong> If multiple bound elements
 have the same value, set injection will fail.

 <p><strong>Elements must be non-null.</strong> If any set element is null,
 set injection will fail.

 @author jessewilson@google.com (Jesse Wilson)]]>
    </doc>
  </class>
  <!-- end class com.google.inject.multibindings.Multibinder -->
  <!-- start interface com.google.inject.multibindings.MultibinderBinding -->
  <interface name="MultibinderBinding"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="getSetKey" return="com.google.inject.Key&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the key for the set.]]>
      </doc>
    </method>
    <method name="getElementTypeLiteral" return="com.google.inject.TypeLiteral&lt;?&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the TypeLiteral that describes the type of elements in the set.
 <p>
 The elements will always match the type Set's generic type. For example, if getSetKey returns a
 key of <code>Set&lt;String></code>, then this will always return a
 <code>TypeLiteral&lt;String></code>.]]>
      </doc>
    </method>
    <method name="getElements" return="java.util.List&lt;com.google.inject.Binding&lt;?&gt;&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns all bindings that make up the set. This is only supported on bindings returned from an
 injector. This will throw {@link UnsupportedOperationException} if it is called on an element
 retrieved from {@link Elements#getElements}.
 <p>
 The elements will always match the type Set's generic type. For example, if getSetKey returns a
 key of <code>Set&lt;String></code>, then this will always return a list of type
 <code>List&lt;Binding&lt;String>></code>.]]>
      </doc>
    </method>
    <method name="permitsDuplicates" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns true if the multibinder permits duplicates. This is only supported on bindings returned
 from an injector. This will throw {@link UnsupportedOperationException} if it is called on a
 MultibinderBinding retrieved from {@link Elements#getElements}.]]>
      </doc>
    </method>
    <method name="containsElement" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="element" type="com.google.inject.spi.Element"/>
      <doc>
      <![CDATA[Returns true if this Multibinder uses the given Element. This will be true for bindings that
 derive the elements of the set and other bindings that Multibinder uses internally. This will
 work for MultibinderBindings retrieved from an injector and {@link Elements#getElements}.
 Usually this is only necessary if you are working with elements retrieved from modules (without
 an Injector), otherwise {@link #getElements} and {@link #permitsDuplicates} are better options.
 <p>
 If you need to introspect the details of the set, such as the values or if it permits
 duplicates, it is necessary to pass the elements through an Injector and use
 {@link #getElements()} and {@link #permitsDuplicates()}.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A binding for a Multibinder.
 
 @param <T> The fully qualified type of the set, including Set. For example:
          <code>MultibinderBinding&lt;Set&lt;Boolean>></code>
 
 @since 3.0
 @author sameb@google.com (Sam Berlin)]]>
    </doc>
  </interface>
  <!-- end interface com.google.inject.multibindings.MultibinderBinding -->
  <!-- start interface com.google.inject.multibindings.MultibindingsTargetVisitor -->
  <interface name="MultibindingsTargetVisitor"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.inject.spi.BindingTargetVisitor&lt;T, V&gt;"/>
    <method name="visit" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="multibinding" type="com.google.inject.multibindings.MultibinderBinding&lt;? extends T&gt;"/>
      <doc>
      <![CDATA[Visits a binding created through {@link Multibinder}.]]>
      </doc>
    </method>
    <method name="visit" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="mapbinding" type="com.google.inject.multibindings.MapBinderBinding&lt;? extends T&gt;"/>
      <doc>
      <![CDATA[Visits a binding created through {@link MapBinder}.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A visitor for the multibinder extension.
 <p>
 If your {@link BindingTargetVisitor} implements this interface, bindings created by using
 {@link Multibinder} or {@link MapBinder} will be visited through this interface.
 
 @since 3.0
 @author sameb@google.com (Sam Berlin)]]>
    </doc>
  </interface>
  <!-- end interface com.google.inject.multibindings.MultibindingsTargetVisitor -->
</package>
<package name="com.google.inject.name">
  <!-- start class com.google.inject.name.Named -->
  <class name="Named"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.lang.annotation.Annotation"/>
    <doc>
    <![CDATA[Annotates named things.

 @author crazybob@google.com (Bob Lee)]]>
    </doc>
  </class>
  <!-- end class com.google.inject.name.Named -->
  <!-- start class com.google.inject.name.Names -->
  <class name="Names" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="named" return="com.google.inject.name.Named"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <doc>
      <![CDATA[Creates a {@link Named} annotation with {@code name} as the value.]]>
      </doc>
    </method>
    <method name="bindProperties"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="binder" type="com.google.inject.Binder"/>
      <param name="properties" type="java.util.Map&lt;java.lang.String, java.lang.String&gt;"/>
      <doc>
      <![CDATA[Creates a constant binding to {@code @Named(key)} for each entry in
 {@code properties}.]]>
      </doc>
    </method>
    <method name="bindProperties"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="binder" type="com.google.inject.Binder"/>
      <param name="properties" type="java.util.Properties"/>
      <doc>
      <![CDATA[Creates a constant binding to {@code @Named(key)} for each property. This
 method binds all properties including those inherited from 
 {@link Properties#defaults defaults}.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Utility methods for use with {@code @}{@link Named}.

 @author crazybob@google.com (Bob Lee)]]>
    </doc>
  </class>
  <!-- end class com.google.inject.name.Names -->
</package>
<package name="com.google.inject.persist">
  <!-- start class com.google.inject.persist.PersistFilter -->
  <class name="PersistFilter" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="PersistFilter" type="com.google.inject.persist.UnitOfWork, com.google.inject.persist.PersistService"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="init"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="filterConfig" type="FilterConfig"/>
      <exception name="ServletException" type="ServletException"/>
    </method>
    <method name="destroy"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="doFilter"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="servletRequest" type="ServletRequest"/>
      <param name="servletResponse" type="ServletResponse"/>
      <param name="filterChain" type="FilterChain"/>
      <exception name="IOException" type="java.io.IOException"/>
      <exception name="ServletException" type="ServletException"/>
    </method>
    <doc>
    <![CDATA[Apply this filter to enable the HTTP Request unit of work and to have
 guice-persist manage the lifecycle of active units of work.
 The filter automatically starts and stops the relevant {@link PersistService}
 upon {@link javax.servlet.Filter#init(javax.servlet.FilterConfig)} and
 {@link javax.servlet.Filter#destroy()} respectively.

 <p> To be able to use the open session-in-view pattern (i.e. work per request),
 register this filter <b>once</b> in your Guice {@code ServletModule}. It is
 important that you register this filter before any other filter.

 For multiple providers, you should register this filter once per provider, inside
 a private module for each persist module installed (this must be the same private
 module where the specific persist module is itself installed).

 <p>
 Example configuration:
 <pre>{@code
  public class MyModule extends ServletModule {
    public void configureServlets() {
      filter("/*").through(PersistFilter.class);

      serve("/index.html").with(MyHtmlServlet.class);
      // Etc.
    }
  }
 }</pre>
 <p>
 This filter is thread safe and allows you to create injectors concurrently
 and deploy multiple guice-persist modules within the same injector, or even
 multiple injectors with persist modules withing the same JVM or web app.
 <p>
 This filter requires the Guice Servlet extension.

 @author Dhanji R. Prasanna (dhanji@gmail.com)]]>
    </doc>
  </class>
  <!-- end class com.google.inject.persist.PersistFilter -->
  <!-- start class com.google.inject.persist.PersistModule -->
  <class name="PersistModule" extends="com.google.inject.AbstractModule"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="PersistModule"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="configure"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="protected"
      deprecated="not deprecated">
    </method>
    <method name="configurePersistence"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </method>
    <method name="getTransactionInterceptor" return="org.aopalliance.intercept.MethodInterceptor"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Install this module to add guice-persist library support for JPA persistence
 providers.

 @author dhanji@gmail.com (Dhanji R. Prasanna)]]>
    </doc>
  </class>
  <!-- end class com.google.inject.persist.PersistModule -->
  <!-- start interface com.google.inject.persist.PersistService -->
  <interface name="PersistService"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="start"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Starts the underlying persistence engine and makes guice-persist ready for
 use. For instance, with JPA, it creates an EntityManagerFactory and may
 open connection pools. This method must be called by your code prior to
 using any guice-persist or JPA artifacts. If already started,
 calling this method does nothing, if already stopped, it also does
 nothing.]]>
      </doc>
    </method>
    <method name="stop"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Stops the underlying persistence engine. For instance, with JPA, it
 closes the {@code EntityManagerFactory}. If already stopped, calling this
 method does nothing. If not yet started, it also does nothing.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Persistence provider service. Use this to manage the overall
 startup and stop of the persistence module(s).

 TODO(user): Integrate with Service API when appropriate.

 @author dhanji@gmail.com (Dhanji R. Prasanna)]]>
    </doc>
  </interface>
  <!-- end interface com.google.inject.persist.PersistService -->
  <!-- start class com.google.inject.persist.Transactional -->
  <class name="Transactional"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.lang.annotation.Annotation"/>
    <doc>
    <![CDATA[<p> Any method or class marked with this annotation will be considered for transactionality.
 Consult the documentation on http://code.google.com/p/google-guice for detailed semantics.
 Marking a method {@code @Transactional} will start a new transaction before the method
 executes and commit it after the method returns.
 <p>
 If the method throws an exception, the transaction will be rolled back <em>unless</em>
 you have specifically requested not to in the {@link #ignore()} clause.
 <p>
 Similarly, the set of exceptions that will trigger a rollback can be defined in
 the {@link #rollbackOn()} clause. By default, only unchecked exceptions trigger a
 rollback.

 @author Dhanji R. Prasanna (dhanji@gmail.com)]]>
    </doc>
  </class>
  <!-- end class com.google.inject.persist.Transactional -->
  <!-- start interface com.google.inject.persist.UnitOfWork -->
  <interface name="UnitOfWork"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="begin"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Starts a Unit Of Work. Underneath, causes a session to the data layer to be opened. If there
 is already one open, the invocation will do nothing. In this way, you can define arbitrary
 units-of-work that nest within one another safely.

 Transaction semantics are not affected.]]>
      </doc>
    </method>
    <method name="end"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Declares an end to the current Unit of Work. Underneath, causes any open session to the data
 layer to close. If there is no Unit of work open, then the call returns silently. You can
 safely invoke end() repeatedly.
 <p>
 Transaction semantics are not affected.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[This interface is used to gain manual control over the unit of work. This is mostly to do
 work in non-request, non-transactional threads. Or where more fine-grained control over the unit
 of work is required. Starting and ending a unit of work directly corresponds to opening and
 closing a {@code Session}, {@code EntityManager} or {@code ObjectContainer} respectively.
 <p> The
 Unit of Work referred to by UnitOfWork will always be local to the calling thread. Be careful to
 end() in a finally block. Neither JPA, nor Hibernate supports threadsafe sessions (reasoning
 behind thread-locality of Unit of Work semantics).

 <ul>
   <li>Using UnitOfWork with the PersistFilter inside a request is not recommended.</li>
   <li>Using UnitOfWork with session-per-txn strategy is not terribly clever either.</li>
   <li>Using UnitOfWork with session-per-request strategy but *outside* a request (i.e. in a
       background or bootstrap thread) is probably a good use case.</li>
  </ul>

 @author Dhanji R. Prasanna (dhanji@gmail com)]]>
    </doc>
  </interface>
  <!-- end interface com.google.inject.persist.UnitOfWork -->
</package>
<package name="com.google.inject.persist.finder">
  <!-- start class com.google.inject.persist.finder.DynamicFinder -->
  <class name="DynamicFinder" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="DynamicFinder" type="java.lang.reflect.Method"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="from" return="com.google.inject.persist.finder.DynamicFinder"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="method" type="java.lang.reflect.Method"/>
      <doc>
      <![CDATA[Returns some metadata if the method is annotated {@code @Finder} or null.

 @param method a method you want to test as a dynamic finder]]>
      </doc>
    </method>
    <method name="metadata" return="com.google.inject.persist.finder.Finder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Utility that helps you introspect dynamic finder methods.

 @author dhanji@gmail.com (Dhanji R. Prasanna)]]>
    </doc>
  </class>
  <!-- end class com.google.inject.persist.finder.DynamicFinder -->
  <!-- start class com.google.inject.persist.finder.Finder -->
  <class name="Finder"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.lang.annotation.Annotation"/>
    <doc>
    <![CDATA[Marks a method stub as a dynamic finder. The method is intercepted and replaced with the
 specified JPAQL query. Provides result auto-boxing and automatic parameter binding.

 @author Dhanji R. Prasanna (dhanji@gmail.com)]]>
    </doc>
  </class>
  <!-- end class com.google.inject.persist.finder.Finder -->
  <!-- start class com.google.inject.persist.finder.FirstResult -->
  <class name="FirstResult"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.lang.annotation.Annotation"/>
    <doc>
    <![CDATA[Annotate any dynamic finder method's integer argument with this to pass in
 the index of the first result in the result set you are interested in.
 Useful for paging result sets. Complemented by {@link MaxResults}.

 @author Dhanji R. Prasanna (dhanji@gmail.com)]]>
    </doc>
  </class>
  <!-- end class com.google.inject.persist.finder.FirstResult -->
  <!-- start class com.google.inject.persist.finder.MaxResults -->
  <class name="MaxResults"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.lang.annotation.Annotation"/>
    <doc>
    <![CDATA[Annotate any dynamic finder method's integer argument with this to pass in
 the maximum size of returned result window. Usefule for paging result sets.
 Complement of {@link FirstResult}.

 @author Dhanji R. Prasanna (dhanji@gmail.com)]]>
    </doc>
  </class>
  <!-- end class com.google.inject.persist.finder.MaxResults -->
</package>
<package name="com.google.inject.persist.jpa">
  <!-- start class com.google.inject.persist.jpa.JpaPersistModule -->
  <class name="JpaPersistModule" extends="com.google.inject.persist.PersistModule"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="JpaPersistModule" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="configurePersistence"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </method>
    <method name="getTransactionInterceptor" return="org.aopalliance.intercept.MethodInterceptor"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </method>
    <method name="properties" return="com.google.inject.persist.jpa.JpaPersistModule"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="properties" type="java.util.Properties"/>
      <doc>
      <![CDATA[Configures the JPA persistence provider with a set of properties.
 
 @param properties A set of name value pairs that configure a JPA persistence
 provider as per the specification.]]>
      </doc>
    </method>
    <method name="addFinder" return="com.google.inject.persist.jpa.JpaPersistModule"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="iface" type="java.lang.Class&lt;T&gt;"/>
      <doc>
      <![CDATA[Adds an interface to this module to use as a dynamic finder.

 @param iface Any interface type whose methods are all dynamic finders.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[JPA provider for guice persist.

 @author dhanji@gmail.com (Dhanji R. Prasanna)]]>
    </doc>
  </class>
  <!-- end class com.google.inject.persist.jpa.JpaPersistModule -->
</package>
<package name="com.google.inject.servlet">
  <!-- start class com.google.inject.servlet.GuiceFilter -->
  <class name="GuiceFilter" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="GuiceFilter"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="doFilter"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="servletRequest" type="ServletRequest"/>
      <param name="servletResponse" type="ServletResponse"/>
      <param name="filterChain" type="FilterChain"/>
      <exception name="IOException" type="java.io.IOException"/>
      <exception name="ServletException" type="ServletException"/>
    </method>
    <method name="init"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="filterConfig" type="FilterConfig"/>
      <exception name="ServletException" type="ServletException"/>
    </method>
    <method name="destroy"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[<p>
 Apply this filter in web.xml above all other filters (typically), to all requests where you plan
  to use servlet scopes. This is also needed in order to dispatch requests to injectable filters
  and servlets:
  <pre>
  &lt;filter&gt;
    &lt;filter-name&gt;guiceFilter&lt;/filter-name&gt;
    &lt;filter-class&gt;<b>com.google.inject.servlet.GuiceFilter</b>&lt;/filter-class&gt;
  &lt;/filter&gt;

  &lt;filter-mapping&gt;
    &lt;filter-name&gt;guiceFilter&lt;/filter-name&gt;
    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
  &lt;/filter-mapping&gt;
  </pre>

 This filter must appear before every filter that makes use of Guice injection or servlet
 scopes functionality. Typically, you will only register this filter in web.xml and register
 any other filters (and servlets) using a {@link ServletModule}.

 @author crazybob@google.com (Bob Lee)
 @author dhanji@gmail.com (Dhanji R. Prasanna)]]>
    </doc>
  </class>
  <!-- end class com.google.inject.servlet.GuiceFilter -->
  <!-- start class com.google.inject.servlet.GuiceServletContextListener -->
  <class name="GuiceServletContextListener" extends="java.lang.Object"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="GuiceServletContextListener"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="contextInitialized"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="servletContextEvent" type="ServletContextEvent"/>
    </method>
    <method name="contextDestroyed"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="servletContextEvent" type="ServletContextEvent"/>
    </method>
    <method name="getInjector" return="com.google.inject.Injector"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Override this method to create (or otherwise obtain a reference to) your
 injector.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[As of Guice 2.0 you can still use (your subclasses of) {@code GuiceServletContextListener}
 class as a logical place to create and configure your injector. This will ensure the injector
 is created when the web application is deployed.
 
 @author Kevin Bourrillion (kevinb@google.com)
 @since 2.0]]>
    </doc>
  </class>
  <!-- end class com.google.inject.servlet.GuiceServletContextListener -->
  <!-- start interface com.google.inject.servlet.InstanceFilterBinding -->
  <interface name="InstanceFilterBinding"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.inject.servlet.ServletModuleBinding"/>
    <method name="getFilterInstance" return="Filter"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the filter instance that will be used.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A binding to a single instance of a filter. 

 @author sameb@google.com
 @since 3.0]]>
    </doc>
  </interface>
  <!-- end interface com.google.inject.servlet.InstanceFilterBinding -->
  <!-- start interface com.google.inject.servlet.InstanceServletBinding -->
  <interface name="InstanceServletBinding"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.inject.servlet.ServletModuleBinding"/>
    <method name="getServletInstance" return="HttpServlet"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the servlet instance that will be used.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A binding to a single instance of a servlet. 

 @author sameb@google.com
 @since 3.0]]>
    </doc>
  </interface>
  <!-- end interface com.google.inject.servlet.InstanceServletBinding -->
  <!-- start interface com.google.inject.servlet.LinkedFilterBinding -->
  <interface name="LinkedFilterBinding"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.inject.servlet.ServletModuleBinding"/>
    <method name="getLinkedKey" return="com.google.inject.Key&lt;? extends Filter&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the key used to lookup the filter instance.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A linked binding to a filter. 

 @author sameb@google.com
 @since 3.0]]>
    </doc>
  </interface>
  <!-- end interface com.google.inject.servlet.LinkedFilterBinding -->
  <!-- start interface com.google.inject.servlet.LinkedServletBinding -->
  <interface name="LinkedServletBinding"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.inject.servlet.ServletModuleBinding"/>
    <method name="getLinkedKey" return="com.google.inject.Key&lt;? extends HttpServlet&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the key used to lookup the servlet instance.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A linked binding to a servlet. 

 @author sameb@google.com
 @since 3.0]]>
    </doc>
  </interface>
  <!-- end interface com.google.inject.servlet.LinkedServletBinding -->
  <!-- start class com.google.inject.servlet.RequestParameters -->
  <class name="RequestParameters"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.lang.annotation.Annotation"/>
    <doc>
    <![CDATA[Apply this to field or parameters of type {@code Map<String, String[]>}
 when you want the HTTP request parameter map to be injected.

 @author crazybob@google.com (Bob Lee)]]>
    </doc>
  </class>
  <!-- end class com.google.inject.servlet.RequestParameters -->
  <!-- start class com.google.inject.servlet.RequestScoped -->
  <class name="RequestScoped"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.lang.annotation.Annotation"/>
    <doc>
    <![CDATA[Apply this to implementation classes when you want one instance per request.

 @author crazybob@google.com (Bob Lee)]]>
    </doc>
  </class>
  <!-- end class com.google.inject.servlet.RequestScoped -->
  <!-- start class com.google.inject.servlet.ServletModule -->
  <class name="ServletModule" extends="com.google.inject.AbstractModule"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="ServletModule"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="configure"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="protected"
      deprecated="not deprecated">
    </method>
    <method name="configureServlets"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[<h3>Servlet Mapping EDSL</h3>

 <p> Part of the EDSL builder language for configuring servlets
 and filters with guice-servlet. Think of this as an in-code replacement for web.xml.
 Filters and servlets are configured here using simple java method calls. Here is a typical
 example of registering a filter when creating your Guice injector:

 <pre>
   Guice.createInjector(..., new ServletModule() {

     {@literal @}Override
     protected void configureServlets() {
       <b>serve("*.html").with(MyServlet.class)</b>
     }
   }
 </pre>

 This registers a servlet (subclass of {@code HttpServlet}) called {@code MyServlet} to service
 any web pages ending in {@code .html}. You can also use a path-style syntax to register
 servlets:

 <pre>
       <b>serve("/my/*").with(MyServlet.class)</b>
 </pre>

 Every servlet (or filter) is required to be a singleton. If you cannot annotate the class
 directly, you should add a separate {@code bind(..).in(Singleton.class)} rule elsewhere in
 your module. Mapping a servlet that is bound under any other scope is an error.

 <p>
 <h4>Dispatch Order</h4>
 You are free to register as many servlets and filters as you like this way. They will
 be compared and dispatched in the order in which the filter methods are called:

 <pre>

   Guice.createInjector(..., new ServletModule() {

     {@literal @}Override
     protected void configureServlets() {
       filter("/*").through(MyFilter.class);
       filter("*.css").through(MyCssFilter.class);
       filter("*.jpg").through(new MyJpgFilter());
       // etc..

       serve("*.html").with(MyServlet.class);
       serve("/my/*").with(MyServlet.class);
       serve("*.jpg").with(new MyServlet());
       // etc..
      }
    }
 </pre>
 This will traverse down the list of rules in lexical order. For example, a url
  "{@code /my/file.js}" (after it runs through the matching filters) will first
  be compared against the servlet mapping:
 
 <pre>
       serve("*.html").with(MyServlet.class);
 </pre>
 And failing that, it will descend to the next servlet mapping:

 <pre>
       serve("/my/*").with(MyServlet.class);
 </pre>

 Since this rule matches, Guice Servlet will dispatch to {@code MyServlet}. These
 two mapping rules can also be written in more compact form using varargs syntax:

 <pre>
       serve(<b>"*.html", "/my/*"</b>).with(MyServlet.class);
 </pre>
 
 This way you can map several URI patterns to the same servlet. A similar syntax is
 also available for filter mappings.

 <p>
 <h4>Regular Expressions</h4>
 You can also map servlets (or filters) to URIs using regular expressions:
 <pre>
    <b>serveRegex("(.)*ajax(.)*").with(MyAjaxServlet.class)</b>
 </pre>

 This will map any URI containing the text "ajax" in it to {@code MyAjaxServlet}. Such as:
 <ul>
 <li>http://www.google.com/ajax.html</li>
 <li>http://www.google.com/content/ajax/index</li>
 <li>http://www.google.com/it/is_totally_ajaxian</li>
 </ul>


 <h3>Initialization Parameters</h3>

 Servlets (and filters) allow you to pass in init params
 using the {@code <init-param>} tag in web.xml. You can similarly pass in parameters to
 Servlets and filters registered in Guice-servlet using a {@link java.util.Map} of parameter
 name/value pairs. For example, to initialize {@code MyServlet} with two parameters
 ({@code name="Dhanji", site="google.com"}) you could write:

 <pre>
  Map&lt;String, String&gt; params = new HashMap&lt;String, String&gt;();
  params.put("name", "Dhanji");
  params.put("site", "google.com");

  ...
      serve("/*").with(MyServlet.class, <b>params</b>)
 </pre>

 <p>
 <h3>Binding Keys</h3>

 You can also bind keys rather than classes. This lets you hide
 implementations with package-local visbility and expose them using
 only a Guice module and an annotation:

 <pre>
  ...
      filter("/*").through(<b>Key.get(Filter.class, Fave.class)</b>);
 </pre>

 Where {@code Filter.class} refers to the Servlet API interface and {@code Fave.class} is a
 custom binding annotation. Elsewhere (in one of your own modules) you can bind this
 filter's implementation:

 <pre>
   bind(Filter.class)<b>.annotatedWith(Fave.class)</b>.to(MyFilterImpl.class);
 </pre>

 See {@link com.google.inject.Binder} for more information on binding syntax.

 <p>
 <h3>Multiple Modules</h3>

 It is sometimes useful to capture servlet and filter mappings from multiple different
 modules. This is essential if you want to package and offer drop-in Guice plugins that
 provide servlet functionality.

 <p>
 Guice Servlet allows you to register several instances of {@code ServletModule} to your
 injector. The order in which these modules are installed determines the dispatch order
 of filters and the precedence order of servlets. For example, if you had two servlet modules,
 {@code RpcModule} and {@code WebServiceModule} and they each contained a filter that mapped
 to the same URI pattern, {@code "/*"}:

 <p>
 In {@code RpcModule}:
 <pre>
     filter("/*").through(RpcFilter.class);
 </pre>

 In {@code WebServiceModule}:
 <pre>
     filter("/*").through(WebServiceFilter.class);
 </pre>

 Then the order in which these filters are dispatched is determined by the order in which
 the modules are installed:

 <pre>
   <b>install(new WebServiceModule());</b>
   install(new RpcModule());
 </pre>

 In the case shown above {@code WebServiceFilter} will run first.
 
 @since 2.0]]>
      </doc>
    </method>
    <method name="filter" return="com.google.inject.servlet.ServletModule.FilterKeyBindingBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="protected"
      deprecated="not deprecated">
      <param name="urlPattern" type="java.lang.String"/>
      <param name="morePatterns" type="java.lang.String[]"/>
      <doc>
      <![CDATA[@param urlPattern Any Servlet-style pattern. examples: /*, /html/*, *.html, etc.
 @since 2.0]]>
      </doc>
    </method>
    <method name="filterRegex" return="com.google.inject.servlet.ServletModule.FilterKeyBindingBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="protected"
      deprecated="not deprecated">
      <param name="regex" type="java.lang.String"/>
      <param name="regexes" type="java.lang.String[]"/>
      <doc>
      <![CDATA[@param regex Any Java-style regular expression.
 @since 2.0]]>
      </doc>
    </method>
    <method name="serve" return="com.google.inject.servlet.ServletModule.ServletKeyBindingBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="protected"
      deprecated="not deprecated">
      <param name="urlPattern" type="java.lang.String"/>
      <param name="morePatterns" type="java.lang.String[]"/>
      <doc>
      <![CDATA[@param urlPattern Any Servlet-style pattern. examples: /*, /html/*, *.html, etc.
 @since 2.0]]>
      </doc>
    </method>
    <method name="serveRegex" return="com.google.inject.servlet.ServletModule.ServletKeyBindingBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="protected"
      deprecated="not deprecated">
      <param name="regex" type="java.lang.String"/>
      <param name="regexes" type="java.lang.String[]"/>
      <doc>
      <![CDATA[@param regex Any Java-style regular expression.
 @since 2.0]]>
      </doc>
    </method>
    <method name="getServletContext" return="ServletContext"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[This method only works if you are using the {@linkplain GuiceServletContextListener} to
 create your injector. Otherwise, it returns null.
 @return The current servlet context.
 @since 3.0]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Configures the servlet scopes and creates bindings for the servlet API
 objects so you can inject the request, response, session, etc.

 <p>
 You should subclass this module to register servlets and
 filters in the {@link #configureServlets()} method.

 @author crazybob@google.com (Bob Lee)
 @author dhanji@gmail.com (Dhanji R. Prasanna)]]>
    </doc>
  </class>
  <!-- end class com.google.inject.servlet.ServletModule -->
  <!-- start interface com.google.inject.servlet.ServletModule.FilterKeyBindingBuilder -->
  <interface name="ServletModule.FilterKeyBindingBuilder"    abstract="true"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="through"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="filterKey" type="java.lang.Class&lt;? extends Filter&gt;"/>
    </method>
    <method name="through"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="filterKey" type="com.google.inject.Key&lt;? extends Filter&gt;"/>
    </method>
    <method name="through"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="filter" type="Filter"/>
      <doc>
      <![CDATA[@since 3.0]]>
      </doc>
    </method>
    <method name="through"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="filterKey" type="java.lang.Class&lt;? extends Filter&gt;"/>
      <param name="initParams" type="java.util.Map&lt;java.lang.String, java.lang.String&gt;"/>
    </method>
    <method name="through"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="filterKey" type="com.google.inject.Key&lt;? extends Filter&gt;"/>
      <param name="initParams" type="java.util.Map&lt;java.lang.String, java.lang.String&gt;"/>
    </method>
    <method name="through"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="filter" type="Filter"/>
      <param name="initParams" type="java.util.Map&lt;java.lang.String, java.lang.String&gt;"/>
      <doc>
      <![CDATA[@since 3.0]]>
      </doc>
    </method>
    <doc>
    <![CDATA[See the EDSL examples at {@link ServletModule#configureServlets()}

 @since 2.0]]>
    </doc>
  </interface>
  <!-- end interface com.google.inject.servlet.ServletModule.FilterKeyBindingBuilder -->
  <!-- start interface com.google.inject.servlet.ServletModule.ServletKeyBindingBuilder -->
  <interface name="ServletModule.ServletKeyBindingBuilder"    abstract="true"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="with"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="servletKey" type="java.lang.Class&lt;? extends HttpServlet&gt;"/>
    </method>
    <method name="with"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="servletKey" type="com.google.inject.Key&lt;? extends HttpServlet&gt;"/>
    </method>
    <method name="with"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="servlet" type="HttpServlet"/>
      <doc>
      <![CDATA[@since 3.0]]>
      </doc>
    </method>
    <method name="with"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="servletKey" type="java.lang.Class&lt;? extends HttpServlet&gt;"/>
      <param name="initParams" type="java.util.Map&lt;java.lang.String, java.lang.String&gt;"/>
    </method>
    <method name="with"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="servletKey" type="com.google.inject.Key&lt;? extends HttpServlet&gt;"/>
      <param name="initParams" type="java.util.Map&lt;java.lang.String, java.lang.String&gt;"/>
    </method>
    <method name="with"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="servlet" type="HttpServlet"/>
      <param name="initParams" type="java.util.Map&lt;java.lang.String, java.lang.String&gt;"/>
      <doc>
      <![CDATA[@since 3.0]]>
      </doc>
    </method>
    <doc>
    <![CDATA[See the EDSL examples at {@link ServletModule#configureServlets()}

 @since 2.0]]>
    </doc>
  </interface>
  <!-- end interface com.google.inject.servlet.ServletModule.ServletKeyBindingBuilder -->
  <!-- start interface com.google.inject.servlet.ServletModuleBinding -->
  <interface name="ServletModuleBinding"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="getUriPatternType" return="com.google.inject.servlet.UriPatternType"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the pattern type that this binding was created with.]]>
      </doc>
    </method>
    <method name="getPattern" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the pattern used to match against the binding.]]>
      </doc>
    </method>
    <method name="getInitParams" return="java.util.Map&lt;java.lang.String, java.lang.String&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns any context params supplied when creating the binding.]]>
      </doc>
    </method>
    <method name="matchesUri" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="uri" type="java.lang.String"/>
      <doc>
      <![CDATA[Returns true if the given URI will match this binding.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A binding created by {@link ServletModule}.
 
 @author sameb@google.com (Sam Berlin)
 @since 3.0]]>
    </doc>
  </interface>
  <!-- end interface com.google.inject.servlet.ServletModuleBinding -->
  <!-- start interface com.google.inject.servlet.ServletModuleTargetVisitor -->
  <interface name="ServletModuleTargetVisitor"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.inject.spi.BindingTargetVisitor&lt;T, V&gt;"/>
    <method name="visit" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="binding" type="com.google.inject.servlet.LinkedFilterBinding"/>
      <doc>
      <![CDATA[Visits a filter binding created by {@link ServletModule#filter}, where
 {@link FilterKeyBindingBuilder#through} is called with a Class or Key.
 
 If multiple patterns were specified, this will be called multiple times.]]>
      </doc>
    </method>
    <method name="visit" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="binding" type="com.google.inject.servlet.InstanceFilterBinding"/>
      <doc>
      <![CDATA[Visits a filter binding created by {@link ServletModule#filter} where
 {@link FilterKeyBindingBuilder#through} is called with a {@link Filter}.
 
 If multiple patterns were specified, this will be called multiple times.]]>
      </doc>
    </method>
    <method name="visit" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="binding" type="com.google.inject.servlet.LinkedServletBinding"/>
      <doc>
      <![CDATA[Visits a servlet binding created by {@link ServletModule#serve} where
 {@link ServletKeyBindingBuilder#with}, is called with a Class or Key.
 
 If multiple patterns were specified, this will be called multiple times.]]>
      </doc>
    </method>
    <method name="visit" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="binding" type="com.google.inject.servlet.InstanceServletBinding"/>
      <doc>
      <![CDATA[Visits a servlet binding created by {@link ServletModule#serve} where 
 {@link ServletKeyBindingBuilder#with}, is called with an {@link HttpServlet}.
 
 If multiple patterns were specified, this will be called multiple times.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A visitor for the servlet extension.
 
 If your {@link BindingTargetVisitor} implements this interface, bindings created by using
 {@link ServletModule} will be visited through this interface.
 
 @since 3.0
 @author sameb@google.com (Sam Berlin)]]>
    </doc>
  </interface>
  <!-- end interface com.google.inject.servlet.ServletModuleTargetVisitor -->
  <!-- start class com.google.inject.servlet.ServletScopes -->
  <class name="ServletScopes" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="continueRequest" return="java.util.concurrent.Callable&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="callable" type="java.util.concurrent.Callable&lt;T&gt;"/>
      <param name="seedMap" type="java.util.Map&lt;com.google.inject.Key&lt;?&gt;, java.lang.Object&gt;"/>
      <doc>
      <![CDATA[Wraps the given callable in a contextual callable that "continues" the
 HTTP request in another thread. This acts as a way of transporting
 request context data from the request processing thread to to worker
 threads.
 <p>
 There are some limitations:
 <ul>
   <li>Derived objects (i.e. anything marked @RequestScoped will not be
      transported.</li>
   <li>State changes to the HttpServletRequest after this method is called
      will not be seen in the continued thread.</li>
   <li>Only the HttpServletRequest, ServletContext and request parameter
      map are available in the continued thread. The response and session
      are not available.</li>
 </ul>

 @param callable code to be executed in another thread, which depends on
     the request scope.
 @param seedMap the initial set of scoped instances for Guice to seed the
     request scope with.  To seed a key with null, use {@code null} as
     the value.
 @return a callable that will invoke the given callable, making the request
     context available to it.
 @throws OutOfScopeException if this method is called from a non-request
     thread, or if the request has completed.
 
 @since 3.0]]>
      </doc>
    </method>
    <method name="scopeRequest" return="java.util.concurrent.Callable&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="callable" type="java.util.concurrent.Callable&lt;T&gt;"/>
      <param name="seedMap" type="java.util.Map&lt;com.google.inject.Key&lt;?&gt;, java.lang.Object&gt;"/>
      <doc>
      <![CDATA[Scopes the given callable inside a request scope. This is not the same
 as the HTTP request scope, but is used if no HTTP request scope is in
 progress. In this way, keys can be scoped as @RequestScoped and exist
 in non-HTTP requests (for example: RPC requests) as well as in HTTP
 request threads.

 @param callable code to be executed which depends on the request scope.
     Typically in another thread, but not necessarily so.
 @param seedMap the initial set of scoped instances for Guice to seed the
     request scope with.  To seed a key with null, use {@code null} as
     the value.
 @return a callable that when called will run inside the a request scope
     that exposes the instances in the {@code seedMap} as scoped keys.
 @since 3.0]]>
      </doc>
    </method>
    <field name="REQUEST" type="com.google.inject.Scope"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[HTTP servlet request scope.]]>
      </doc>
    </field>
    <field name="SESSION" type="com.google.inject.Scope"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[HTTP session scope.]]>
      </doc>
    </field>
    <doc>
    <![CDATA[Servlet scopes.

 @author crazybob@google.com (Bob Lee)]]>
    </doc>
  </class>
  <!-- end class com.google.inject.servlet.ServletScopes -->
  <!-- start class com.google.inject.servlet.SessionScoped -->
  <class name="SessionScoped"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.lang.annotation.Annotation"/>
    <doc>
    <![CDATA[Apply this to implementation classes when you want one instance per session.

 @see com.google.inject.Scopes#SINGLETON
 @author crazybob@google.com (Bob Lee)]]>
    </doc>
  </class>
  <!-- end class com.google.inject.servlet.SessionScoped -->
  <!-- start class com.google.inject.servlet.UriPatternType -->
  <class name="UriPatternType" extends="java.lang.Enum&lt;com.google.inject.servlet.UriPatternType&gt;"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="values" return="com.google.inject.servlet.UriPatternType[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="com.google.inject.servlet.UriPatternType"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <doc>
    <![CDATA[An enumeration of the available URI-pattern matching styles
 
 @since 3.0]]>
    </doc>
  </class>
  <!-- end class com.google.inject.servlet.UriPatternType -->
</package>
<package name="com.google.inject.spi">
  <!-- start interface com.google.inject.spi.BindingScopingVisitor -->
  <interface name="BindingScopingVisitor"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="visitEagerSingleton" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Visit an eager singleton or single instance. This scope strategy is found on both module and
 injector bindings.]]>
      </doc>
    </method>
    <method name="visitScope" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="scope" type="com.google.inject.Scope"/>
      <doc>
      <![CDATA[Visit a scope instance. This scope strategy is found on both module and injector bindings.]]>
      </doc>
    </method>
    <method name="visitScopeAnnotation" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="scopeAnnotation" type="java.lang.Class&lt;? extends java.lang.annotation.Annotation&gt;"/>
      <doc>
      <![CDATA[Visit a scope annotation. This scope strategy is found only on module bindings. The instance
 that implements this scope is registered by {@link com.google.inject.Binder#bindScope(Class,
 Scope) Binder.bindScope()}.]]>
      </doc>
    </method>
    <method name="visitNoScoping" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Visit an unspecified or unscoped strategy. On a module, this strategy indicates that the
 injector should use scoping annotations to find a scope. On an injector, it indicates that
 no scope is applied to the binding. An unscoped binding will behave like a scoped one when it
 is linked to a scoped binding.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Visits each of the strategies used to scope an injection.

 @param <V> any type to be returned by the visit method. Use {@link Void} with
     {@code return null} if no return type is needed.
 @since 2.0]]>
    </doc>
  </interface>
  <!-- end interface com.google.inject.spi.BindingScopingVisitor -->
  <!-- start interface com.google.inject.spi.BindingTargetVisitor -->
  <interface name="BindingTargetVisitor"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="visit" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="binding" type="com.google.inject.spi.InstanceBinding&lt;? extends T&gt;"/>
      <doc>
      <![CDATA[Visit a instance binding. The same instance is returned for every injection. This target is
 found in both module and injector bindings.]]>
      </doc>
    </method>
    <method name="visit" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="binding" type="com.google.inject.spi.ProviderInstanceBinding&lt;? extends T&gt;"/>
      <doc>
      <![CDATA[Visit a provider instance binding. The provider's {@code get} method is invoked to resolve
 injections. This target is found in both module and injector bindings.]]>
      </doc>
    </method>
    <method name="visit" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="binding" type="com.google.inject.spi.ProviderKeyBinding&lt;? extends T&gt;"/>
      <doc>
      <![CDATA[Visit a provider key binding. To resolve injections, the provider key is first resolved, then
 that provider's {@code get} method is invoked. This target is found in both module and injector
 bindings.]]>
      </doc>
    </method>
    <method name="visit" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="binding" type="com.google.inject.spi.LinkedKeyBinding&lt;? extends T&gt;"/>
      <doc>
      <![CDATA[Visit a linked key binding. The other key's binding is used to resolve injections. This
 target is found in both module and injector bindings.]]>
      </doc>
    </method>
    <method name="visit" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="binding" type="com.google.inject.spi.ExposedBinding&lt;? extends T&gt;"/>
      <doc>
      <![CDATA[Visit a binding to a key exposed from an enclosed private environment. This target is only
 found in injector bindings.]]>
      </doc>
    </method>
    <method name="visit" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="binding" type="com.google.inject.spi.UntargettedBinding&lt;? extends T&gt;"/>
      <doc>
      <![CDATA[Visit an untargetted binding. This target is found only on module bindings. It indicates
 that the injector should use its implicit binding strategies to resolve injections.]]>
      </doc>
    </method>
    <method name="visit" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="binding" type="com.google.inject.spi.ConstructorBinding&lt;? extends T&gt;"/>
      <doc>
      <![CDATA[Visit a constructor binding. To resolve injections, an instance is instantiated by invoking
 {@code constructor}. This target is found only on injector bindings.]]>
      </doc>
    </method>
    <method name="visit" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="binding" type="com.google.inject.spi.ConvertedConstantBinding&lt;? extends T&gt;"/>
      <doc>
      <![CDATA[Visit a binding created from converting a bound instance to a new type. The source binding
 has the same binding annotation but a different type. This target is found only on injector
 bindings.]]>
      </doc>
    </method>
    <method name="visit" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="binding" type="com.google.inject.spi.ProviderBinding&lt;? extends T&gt;"/>
      <doc>
      <![CDATA[Visit a binding to a {@link com.google.inject.Provider} that delegates to the binding for the
 provided type. This target is found only on injector bindings.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Visits each of the strategies used to find an instance to satisfy an injection.

 @param <V> any type to be returned by the visit method. Use {@link Void} with
     {@code return null} if no return type is needed.
 @since 2.0]]>
    </doc>
  </interface>
  <!-- end interface com.google.inject.spi.BindingTargetVisitor -->
  <!-- start interface com.google.inject.spi.ConstructorBinding -->
  <interface name="ConstructorBinding"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.inject.Binding&lt;T&gt;"/>
    <implements name="com.google.inject.spi.HasDependencies"/>
    <method name="getConstructor" return="com.google.inject.spi.InjectionPoint"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the constructor this binding injects.]]>
      </doc>
    </method>
    <method name="getInjectableMembers" return="java.util.Set&lt;com.google.inject.spi.InjectionPoint&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns all instance method and field injection points on {@code type}.

 @return a possibly empty set of injection points. The set has a specified iteration order. All
      fields are returned and then all methods. Within the fields, supertype fields are returned
      before subtype fields. Similarly, supertype methods are returned before subtype methods.]]>
      </doc>
    </method>
    <method name="getMethodInterceptors" return="java.util.Map&lt;java.lang.reflect.Method, java.util.List&lt;org.aopalliance.intercept.MethodInterceptor&gt;&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the interceptors applied to each method, in the order that they will be applied.

 @return a possibly empty map]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A binding to the constructor of a concrete clss. To resolve injections, an instance is
 instantiated by invoking the constructor.

 @author jessewilson@google.com (Jesse Wilson)
 @since 2.0]]>
    </doc>
  </interface>
  <!-- end interface com.google.inject.spi.ConstructorBinding -->
  <!-- start interface com.google.inject.spi.ConvertedConstantBinding -->
  <interface name="ConvertedConstantBinding"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.inject.Binding&lt;T&gt;"/>
    <implements name="com.google.inject.spi.HasDependencies"/>
    <method name="getValue" return="T"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the converted value.]]>
      </doc>
    </method>
    <method name="getTypeConverterBinding" return="com.google.inject.spi.TypeConverterBinding"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the type converter binding used to convert the constant.
 
 @since 3.0]]>
      </doc>
    </method>
    <method name="getSourceKey" return="com.google.inject.Key&lt;java.lang.String&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the key for the source binding. That binding can e retrieved from an injector using
 {@link com.google.inject.Injector#getBinding(Key) Injector.getBinding(key)}.]]>
      </doc>
    </method>
    <method name="getDependencies" return="java.util.Set&lt;com.google.inject.spi.Dependency&lt;?&gt;&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a singleton set containing only the converted key.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A binding created from converting a bound instance to a new type. The source binding has the same
 binding annotation but a different type.

 @author jessewilson@google.com (Jesse Wilson)
 @since 2.0]]>
    </doc>
  </interface>
  <!-- end interface com.google.inject.spi.ConvertedConstantBinding -->
  <!-- start class com.google.inject.spi.DefaultBindingScopingVisitor -->
  <class name="DefaultBindingScopingVisitor" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.inject.spi.BindingScopingVisitor&lt;V&gt;"/>
    <constructor name="DefaultBindingScopingVisitor"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="visitOther" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Default visit implementation. Returns {@code null}.]]>
      </doc>
    </method>
    <method name="visitEagerSingleton" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="visitScope" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="scope" type="com.google.inject.Scope"/>
    </method>
    <method name="visitScopeAnnotation" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="scopeAnnotation" type="java.lang.Class&lt;? extends java.lang.annotation.Annotation&gt;"/>
    </method>
    <method name="visitNoScoping" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[No-op visitor for subclassing. All interface methods simply delegate to
 {@link #visitOther()}, returning its result.

 @param <V> any type to be returned by the visit method. Use {@link Void} with
     {@code return null} if no return type is needed.
 
 @author jessewilson@google.com (Jesse Wilson)
 @since 2.0]]>
    </doc>
  </class>
  <!-- end class com.google.inject.spi.DefaultBindingScopingVisitor -->
  <!-- start class com.google.inject.spi.DefaultBindingTargetVisitor -->
  <class name="DefaultBindingTargetVisitor" extends="java.lang.Object"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.inject.spi.BindingTargetVisitor&lt;T, V&gt;"/>
    <constructor name="DefaultBindingTargetVisitor"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="visitOther" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="binding" type="com.google.inject.Binding&lt;? extends T&gt;"/>
      <doc>
      <![CDATA[Default visit implementation. Returns {@code null}.]]>
      </doc>
    </method>
    <method name="visit" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="instanceBinding" type="com.google.inject.spi.InstanceBinding&lt;? extends T&gt;"/>
    </method>
    <method name="visit" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="providerInstanceBinding" type="com.google.inject.spi.ProviderInstanceBinding&lt;? extends T&gt;"/>
    </method>
    <method name="visit" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="providerKeyBinding" type="com.google.inject.spi.ProviderKeyBinding&lt;? extends T&gt;"/>
    </method>
    <method name="visit" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="linkedKeyBinding" type="com.google.inject.spi.LinkedKeyBinding&lt;? extends T&gt;"/>
    </method>
    <method name="visit" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="exposedBinding" type="com.google.inject.spi.ExposedBinding&lt;? extends T&gt;"/>
    </method>
    <method name="visit" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="untargettedBinding" type="com.google.inject.spi.UntargettedBinding&lt;? extends T&gt;"/>
    </method>
    <method name="visit" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="constructorBinding" type="com.google.inject.spi.ConstructorBinding&lt;? extends T&gt;"/>
    </method>
    <method name="visit" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="convertedConstantBinding" type="com.google.inject.spi.ConvertedConstantBinding&lt;? extends T&gt;"/>
    </method>
    <method name="visit" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="providerBinding" type="com.google.inject.spi.ProviderBinding&lt;? extends T&gt;"/>
    </method>
    <doc>
    <![CDATA[No-op visitor for subclassing. All interface methods simply delegate to {@link
 #visitOther(Binding)}, returning its result.

 @param <V> any type to be returned by the visit method. Use {@link Void} with
     {@code return null} if no return type is needed.

 @author jessewilson@google.com (Jesse Wilson)
 @since 2.0]]>
    </doc>
  </class>
  <!-- end class com.google.inject.spi.DefaultBindingTargetVisitor -->
  <!-- start class com.google.inject.spi.DefaultElementVisitor -->
  <class name="DefaultElementVisitor" extends="java.lang.Object"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.inject.spi.ElementVisitor&lt;V&gt;"/>
    <constructor name="DefaultElementVisitor"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="visitOther" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="element" type="com.google.inject.spi.Element"/>
      <doc>
      <![CDATA[Default visit implementation. Returns {@code null}.]]>
      </doc>
    </method>
    <method name="visit" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="message" type="com.google.inject.spi.Message"/>
    </method>
    <method name="visit" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="binding" type="com.google.inject.Binding&lt;T&gt;"/>
    </method>
    <method name="visit" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="interceptorBinding" type="com.google.inject.spi.InterceptorBinding"/>
    </method>
    <method name="visit" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="scopeBinding" type="com.google.inject.spi.ScopeBinding"/>
    </method>
    <method name="visit" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="typeConverterBinding" type="com.google.inject.spi.TypeConverterBinding"/>
    </method>
    <method name="visit" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="providerLookup" type="com.google.inject.spi.ProviderLookup&lt;T&gt;"/>
    </method>
    <method name="visit" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="injectionRequest" type="com.google.inject.spi.InjectionRequest&lt;?&gt;"/>
    </method>
    <method name="visit" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="staticInjectionRequest" type="com.google.inject.spi.StaticInjectionRequest"/>
    </method>
    <method name="visit" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="privateElements" type="com.google.inject.spi.PrivateElements"/>
    </method>
    <method name="visit" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="lookup" type="com.google.inject.spi.MembersInjectorLookup&lt;T&gt;"/>
    </method>
    <method name="visit" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="binding" type="com.google.inject.spi.TypeListenerBinding"/>
    </method>
    <method name="visit" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="option" type="com.google.inject.spi.DisableCircularProxiesOption"/>
    </method>
    <method name="visit" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="option" type="com.google.inject.spi.RequireExplicitBindingsOption"/>
    </method>
    <doc>
    <![CDATA[No-op visitor for subclassing. All interface methods simply delegate to
 {@link #visitOther(Element)}, returning its result.

 @param <V> any type to be returned by the visit method. Use {@link Void} with
     {@code return null} if no return type is needed.

 @author sberlin@gmail.com (Sam Berlin)
 @since 2.0]]>
    </doc>
  </class>
  <!-- end class com.google.inject.spi.DefaultElementVisitor -->
  <!-- start class com.google.inject.spi.Dependency -->
  <class name="Dependency" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="get" return="com.google.inject.spi.Dependency&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="com.google.inject.Key&lt;T&gt;"/>
      <doc>
      <![CDATA[Returns a new dependency that is not attached to an injection point. The returned dependency is
 nullable.]]>
      </doc>
    </method>
    <method name="forInjectionPoints" return="java.util.Set&lt;com.google.inject.spi.Dependency&lt;?&gt;&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="injectionPoints" type="java.util.Set&lt;com.google.inject.spi.InjectionPoint&gt;"/>
      <doc>
      <![CDATA[Returns the dependencies from the given injection points.]]>
      </doc>
    </method>
    <method name="getKey" return="com.google.inject.Key&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the key to the binding that satisfies this dependency.]]>
      </doc>
    </method>
    <method name="isNullable" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns true if null is a legal value for this dependency.]]>
      </doc>
    </method>
    <method name="getInjectionPoint" return="com.google.inject.spi.InjectionPoint"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the injection point to which this dependency belongs, or null if this dependency isn't
 attached to a particular injection point.]]>
      </doc>
    </method>
    <method name="getParameterIndex" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the index of this dependency in the injection point's parameter list, or {@code -1} if
 this dependency does not belong to a parameter list. Only method and constuctor dependencies
 are elements in a parameter list.]]>
      </doc>
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="o" type="java.lang.Object"/>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[A variable that can be resolved by an injector.

 <p>Use {@link #get} to build a freestanding dependency, or {@link InjectionPoint} to build one
 that's attached to a constructor, method or field.

 @author crazybob@google.com (Bob Lee)
 @author jessewilson@google.com (Jesse Wilson)
 @since 2.0]]>
    </doc>
  </class>
  <!-- end class com.google.inject.spi.Dependency -->
  <!-- start class com.google.inject.spi.DisableCircularProxiesOption -->
  <class name="DisableCircularProxiesOption" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.inject.spi.Element"/>
    <method name="getSource" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="applyTo"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="binder" type="com.google.inject.Binder"/>
    </method>
    <method name="acceptVisitor" return="T"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="visitor" type="com.google.inject.spi.ElementVisitor&lt;T&gt;"/>
    </method>
    <doc>
    <![CDATA[A request to disable circular proxies.

 @author sameb@google.com (Sam Berlin)
 @since 3.0]]>
    </doc>
  </class>
  <!-- end class com.google.inject.spi.DisableCircularProxiesOption -->
  <!-- start interface com.google.inject.spi.Element -->
  <interface name="Element"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="getSource" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns an arbitrary object containing information about the "place" where this element was
 configured. Used by Guice in the production of descriptive error messages.

 <p>Tools might specially handle types they know about; {@code StackTraceElement} is a good
 example. Tools should simply call {@code toString()} on the source object if the type is
 unfamiliar.]]>
      </doc>
    </method>
    <method name="acceptVisitor" return="T"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="visitor" type="com.google.inject.spi.ElementVisitor&lt;T&gt;"/>
      <doc>
      <![CDATA[Accepts an element visitor. Invokes the visitor method specific to this element's type.

 @param visitor to call back on]]>
      </doc>
    </method>
    <method name="applyTo"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="binder" type="com.google.inject.Binder"/>
      <doc>
      <![CDATA[Writes this module element to the given binder (optional operation).

 @param binder to apply configuration element to
 @throws UnsupportedOperationException if the {@code applyTo} method is not supported by this
     element.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A core component of a module or injector.

 <p>The elements of a module can be inspected, validated and rewritten. Use {@link
 Elements#getElements(com.google.inject.Module[]) Elements.getElements()} to read the elements
 from a module, and {@link Elements#getModule(Iterable) Elements.getModule()} to rewrite them.
 This can be used for static analysis and generation of Guice modules.

 <p>The elements of an injector can be inspected and exercised. Use {@link
 com.google.inject.Injector#getBindings Injector.getBindings()} to reflect on Guice injectors.

 @author jessewilson@google.com (Jesse Wilson)
 @author crazybob@google.com (Bob Lee)
 @since 2.0]]>
    </doc>
  </interface>
  <!-- end interface com.google.inject.spi.Element -->
  <!-- start class com.google.inject.spi.Elements -->
  <class name="Elements" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="Elements"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getElements" return="java.util.List&lt;com.google.inject.spi.Element&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="modules" type="com.google.inject.Module[]"/>
      <doc>
      <![CDATA[Records the elements executed by {@code modules}.]]>
      </doc>
    </method>
    <method name="getElements" return="java.util.List&lt;com.google.inject.spi.Element&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="stage" type="com.google.inject.Stage"/>
      <param name="modules" type="com.google.inject.Module[]"/>
      <doc>
      <![CDATA[Records the elements executed by {@code modules}.]]>
      </doc>
    </method>
    <method name="getElements" return="java.util.List&lt;com.google.inject.spi.Element&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="modules" type="java.lang.Iterable&lt;? extends com.google.inject.Module&gt;"/>
      <doc>
      <![CDATA[Records the elements executed by {@code modules}.]]>
      </doc>
    </method>
    <method name="getElements" return="java.util.List&lt;com.google.inject.spi.Element&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="stage" type="com.google.inject.Stage"/>
      <param name="modules" type="java.lang.Iterable&lt;? extends com.google.inject.Module&gt;"/>
      <doc>
      <![CDATA[Records the elements executed by {@code modules}.]]>
      </doc>
    </method>
    <method name="getModule" return="com.google.inject.Module"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="elements" type="java.lang.Iterable&lt;? extends com.google.inject.spi.Element&gt;"/>
      <doc>
      <![CDATA[Returns the module composed of {@code elements}.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Exposes elements of a module so they can be inspected, validated or {@link
 Element#applyTo(Binder) rewritten}.

 @author jessewilson@google.com (Jesse Wilson)
 @since 2.0]]>
    </doc>
  </class>
  <!-- end class com.google.inject.spi.Elements -->
  <!-- start interface com.google.inject.spi.ElementVisitor -->
  <interface name="ElementVisitor"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="visit" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="binding" type="com.google.inject.Binding&lt;T&gt;"/>
      <doc>
      <![CDATA[Visit a mapping from a key (type and optional annotation) to the strategy for getting
 instances of the type.]]>
      </doc>
    </method>
    <method name="visit" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="binding" type="com.google.inject.spi.InterceptorBinding"/>
      <doc>
      <![CDATA[Visit a registration of interceptors for matching methods of matching classes.]]>
      </doc>
    </method>
    <method name="visit" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="binding" type="com.google.inject.spi.ScopeBinding"/>
      <doc>
      <![CDATA[Visit a registration of a scope annotation with the scope that implements it.]]>
      </doc>
    </method>
    <method name="visit" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="binding" type="com.google.inject.spi.TypeConverterBinding"/>
      <doc>
      <![CDATA[Visit a registration of type converters for matching target types.]]>
      </doc>
    </method>
    <method name="visit" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="request" type="com.google.inject.spi.InjectionRequest&lt;?&gt;"/>
      <doc>
      <![CDATA[Visit a request to inject the instance fields and methods of an instance.]]>
      </doc>
    </method>
    <method name="visit" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="request" type="com.google.inject.spi.StaticInjectionRequest"/>
      <doc>
      <![CDATA[Visit a request to inject the static fields and methods of type.]]>
      </doc>
    </method>
    <method name="visit" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="lookup" type="com.google.inject.spi.ProviderLookup&lt;T&gt;"/>
      <doc>
      <![CDATA[Visit a lookup of the provider for a type.]]>
      </doc>
    </method>
    <method name="visit" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="lookup" type="com.google.inject.spi.MembersInjectorLookup&lt;T&gt;"/>
      <doc>
      <![CDATA[Visit a lookup of the members injector.]]>
      </doc>
    </method>
    <method name="visit" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="message" type="com.google.inject.spi.Message"/>
      <doc>
      <![CDATA[Visit an error message and the context in which it occured.]]>
      </doc>
    </method>
    <method name="visit" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="elements" type="com.google.inject.spi.PrivateElements"/>
      <doc>
      <![CDATA[Visit a collection of configuration elements for a {@linkplain com.google.inject.PrivateBinder
 private binder}.]]>
      </doc>
    </method>
    <method name="visit" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="binding" type="com.google.inject.spi.TypeListenerBinding"/>
      <doc>
      <![CDATA[Visit an injectable type listener binding.]]>
      </doc>
    </method>
    <method name="visit" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="option" type="com.google.inject.spi.RequireExplicitBindingsOption"/>
      <doc>
      <![CDATA[Visit a require explicit bindings command.
 
 @since 3.0]]>
      </doc>
    </method>
    <method name="visit" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="option" type="com.google.inject.spi.DisableCircularProxiesOption"/>
      <doc>
      <![CDATA[Visit a disable circular proxies command.
 
 @since 3.0]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Visit elements.

 @param <V> any type to be returned by the visit method. Use {@link Void} with
     {@code return null} if no return type is needed.
 
 @since 2.0]]>
    </doc>
  </interface>
  <!-- end interface com.google.inject.spi.ElementVisitor -->
  <!-- start interface com.google.inject.spi.ExposedBinding -->
  <interface name="ExposedBinding"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.inject.Binding&lt;T&gt;"/>
    <implements name="com.google.inject.spi.HasDependencies"/>
    <method name="getPrivateElements" return="com.google.inject.spi.PrivateElements"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the enclosed environment that holds the original binding.]]>
      </doc>
    </method>
    <method name="applyTo"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="binder" type="com.google.inject.Binder"/>
      <doc>
      <![CDATA[Unsupported. Always throws {@link UnsupportedOperationException}.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A binding to a key exposed from an enclosed private environment.

 @author jessewilson@google.com (Jesse Wilson)
 @since 2.0]]>
    </doc>
  </interface>
  <!-- end interface com.google.inject.spi.ExposedBinding -->
  <!-- start interface com.google.inject.spi.HasDependencies -->
  <interface name="HasDependencies"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="getDependencies" return="java.util.Set&lt;com.google.inject.spi.Dependency&lt;?&gt;&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the known dependencies for this type. If this has dependencies whose values are not
 known statically, a dependency for the {@link com.google.inject.Injector Injector} will be
 included in the returned set.
 
 @return a possibly empty set]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Implemented by {@link com.google.inject.Binding bindings}, {@link com.google.inject.Provider
 providers} and instances that expose their dependencies explicitly.

 @author jessewilson@google.com (Jesse Wilson)
 @since 2.0]]>
    </doc>
  </interface>
  <!-- end interface com.google.inject.spi.HasDependencies -->
  <!-- start interface com.google.inject.spi.InjectionListener -->
  <interface name="InjectionListener"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="afterInjection"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="injectee" type="I"/>
      <doc>
      <![CDATA[Invoked by Guice after it injects the fields and methods of instance.

 @param injectee instance that Guice injected dependencies into]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Listens for injections into instances of type {@code I}. Useful for performing further
 injections, post-injection initialization, and more.

 @author crazybob@google.com (Bob Lee)
 @author jessewilson@google.com (Jesse Wilson)
 @since 2.0]]>
    </doc>
  </interface>
  <!-- end interface com.google.inject.spi.InjectionListener -->
  <!-- start class com.google.inject.spi.InjectionPoint -->
  <class name="InjectionPoint" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="getMember" return="java.lang.reflect.Member"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the injected constructor, field, or method.]]>
      </doc>
    </method>
    <method name="getDependencies" return="java.util.List&lt;com.google.inject.spi.Dependency&lt;?&gt;&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the dependencies for this injection point. If the injection point is for a method or
 constructor, the dependencies will correspond to that member's parameters. Field injection
 points always have a single dependency for the field itself.

 @return a possibly-empty list]]>
      </doc>
    </method>
    <method name="isOptional" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns true if this injection point shall be skipped if the injector cannot resolve bindings
 for all required dependencies. Both explicit bindings (as specified in a module), and implicit
 bindings ({@literal @}{@link com.google.inject.ImplementedBy ImplementedBy}, default
 constructors etc.) may be used to satisfy optional injection points.]]>
      </doc>
    </method>
    <method name="isToolable" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns true if the element is annotated with {@literal @}{@link Toolable}.
 
 @since 3.0]]>
      </doc>
    </method>
    <method name="getDeclaringType" return="com.google.inject.TypeLiteral&lt;?&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the generic type that defines this injection point. If the member exists on a
 parameterized type, the result will include more type information than the member's {@link
 Member#getDeclaringClass() raw declaring class}.
 
 @since 3.0]]>
      </doc>
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="o" type="java.lang.Object"/>
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="forConstructor" return="com.google.inject.spi.InjectionPoint"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="constructor" type="java.lang.reflect.Constructor&lt;T&gt;"/>
      <doc>
      <![CDATA[Returns a new injection point for the specified constructor. If the declaring type of {@code
 constructor} is parameterized (such as {@code List<T>}), prefer the overload that includes a
 type literal.

 @param constructor any single constructor present on {@code type}.
 
 @since 3.0]]>
      </doc>
    </method>
    <method name="forConstructor" return="com.google.inject.spi.InjectionPoint"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="constructor" type="java.lang.reflect.Constructor&lt;T&gt;"/>
      <param name="type" type="com.google.inject.TypeLiteral&lt;? extends T&gt;"/>
      <doc>
      <![CDATA[Returns a new injection point for the specified constructor of {@code type}.

 @param constructor any single constructor present on {@code type}.
 @param type the concrete type that defines {@code constructor}.
 
 @since 3.0]]>
      </doc>
    </method>
    <method name="forConstructorOf" return="com.google.inject.spi.InjectionPoint"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="com.google.inject.TypeLiteral&lt;?&gt;"/>
      <doc>
      <![CDATA[Returns a new injection point for the injectable constructor of {@code type}.

 @param type a concrete type with exactly one constructor annotated {@literal @}{@link Inject},
     or a no-arguments constructor that is not private.
 @throws ConfigurationException if there is no injectable constructor, more than one injectable
     constructor, or if parameters of the injectable constructor are malformed, such as a
     parameter with multiple binding annotations.]]>
      </doc>
    </method>
    <method name="forConstructorOf" return="com.google.inject.spi.InjectionPoint"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="java.lang.Class&lt;?&gt;"/>
      <doc>
      <![CDATA[Returns a new injection point for the injectable constructor of {@code type}.

 @param type a concrete type with exactly one constructor annotated {@literal @}{@link Inject},
     or a no-arguments constructor that is not private.
 @throws ConfigurationException if there is no injectable constructor, more than one injectable
     constructor, or if parameters of the injectable constructor are malformed, such as a
     parameter with multiple binding annotations.]]>
      </doc>
    </method>
    <method name="forStaticMethodsAndFields" return="java.util.Set&lt;com.google.inject.spi.InjectionPoint&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="com.google.inject.TypeLiteral&lt;?&gt;"/>
      <doc>
      <![CDATA[Returns all static method and field injection points on {@code type}.

 @return a possibly empty set of injection points. The set has a specified iteration order. All
      fields are returned and then all methods. Within the fields, supertype fields are returned
      before subtype fields. Similarly, supertype methods are returned before subtype methods.
 @throws ConfigurationException if there is a malformed injection point on {@code type}, such as
      a field with multiple binding annotations. The exception's {@link
      ConfigurationException#getPartialValue() partial value} is a {@code Set<InjectionPoint>}
      of the valid injection points.]]>
      </doc>
    </method>
    <method name="forStaticMethodsAndFields" return="java.util.Set&lt;com.google.inject.spi.InjectionPoint&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="java.lang.Class&lt;?&gt;"/>
      <doc>
      <![CDATA[Returns all static method and field injection points on {@code type}.

 @return a possibly empty set of injection points. The set has a specified iteration order. All
      fields are returned and then all methods. Within the fields, supertype fields are returned
      before subtype fields. Similarly, supertype methods are returned before subtype methods.
 @throws ConfigurationException if there is a malformed injection point on {@code type}, such as
      a field with multiple binding annotations. The exception's {@link
      ConfigurationException#getPartialValue() partial value} is a {@code Set<InjectionPoint>}
      of the valid injection points.]]>
      </doc>
    </method>
    <method name="forInstanceMethodsAndFields" return="java.util.Set&lt;com.google.inject.spi.InjectionPoint&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="com.google.inject.TypeLiteral&lt;?&gt;"/>
      <doc>
      <![CDATA[Returns all instance method and field injection points on {@code type}.

 @return a possibly empty set of injection points. The set has a specified iteration order. All
      fields are returned and then all methods. Within the fields, supertype fields are returned
      before subtype fields. Similarly, supertype methods are returned before subtype methods.
 @throws ConfigurationException if there is a malformed injection point on {@code type}, such as
      a field with multiple binding annotations. The exception's {@link
      ConfigurationException#getPartialValue() partial value} is a {@code Set<InjectionPoint>}
      of the valid injection points.]]>
      </doc>
    </method>
    <method name="forInstanceMethodsAndFields" return="java.util.Set&lt;com.google.inject.spi.InjectionPoint&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="java.lang.Class&lt;?&gt;"/>
      <doc>
      <![CDATA[Returns all instance method and field injection points on {@code type}.

 @return a possibly empty set of injection points. The set has a specified iteration order. All
      fields are returned and then all methods. Within the fields, supertype fields are returned
      before subtype fields. Similarly, supertype methods are returned before subtype methods.
 @throws ConfigurationException if there is a malformed injection point on {@code type}, such as
      a field with multiple binding annotations. The exception's {@link
      ConfigurationException#getPartialValue() partial value} is a {@code Set<InjectionPoint>}
      of the valid injection points.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A constructor, field or method that can receive injections. Typically this is a member with the
 {@literal @}{@link Inject} annotation. For non-private, no argument constructors, the member may
 omit the annotation.

 @author crazybob@google.com (Bob Lee)
 @since 2.0]]>
    </doc>
  </class>
  <!-- end class com.google.inject.spi.InjectionPoint -->
  <!-- start class com.google.inject.spi.InjectionRequest -->
  <class name="InjectionRequest" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.inject.spi.Element"/>
    <constructor name="InjectionRequest" type="java.lang.Object, com.google.inject.TypeLiteral&lt;T&gt;, T"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getSource" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getInstance" return="T"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getType" return="com.google.inject.TypeLiteral&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getInjectionPoints" return="java.util.Set&lt;com.google.inject.spi.InjectionPoint&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="ConfigurationException" type="com.google.inject.ConfigurationException"/>
      <doc>
      <![CDATA[Returns the instance methods and fields of {@code instance} that will be injected to fulfill
 this request.

 @return a possibly empty set of injection points. The set has a specified iteration order. All
      fields are returned and then all methods. Within the fields, supertype fields are returned
      before subtype fields. Similarly, supertype methods are returned before subtype methods.
 @throws ConfigurationException if there is a malformed injection point on the class of {@code
      instance}, such as a field with multiple binding annotations. The exception's {@link
      ConfigurationException#getPartialValue() partial value} is a {@code Set<InjectionPoint>}
      of the valid injection points.]]>
      </doc>
    </method>
    <method name="acceptVisitor" return="R"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="visitor" type="com.google.inject.spi.ElementVisitor&lt;R&gt;"/>
    </method>
    <method name="applyTo"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="binder" type="com.google.inject.Binder"/>
    </method>
    <doc>
    <![CDATA[A request to inject the instance fields and methods of an instance. Requests are created
 explicitly in a module using {@link com.google.inject.Binder#requestInjection(Object)
 requestInjection()} statements:
 <pre>
     requestInjection(serviceInstance);</pre>

 @author mikeward@google.com (Mike Ward)
 @since 2.0]]>
    </doc>
  </class>
  <!-- end class com.google.inject.spi.InjectionRequest -->
  <!-- start interface com.google.inject.spi.InstanceBinding -->
  <interface name="InstanceBinding"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.inject.Binding&lt;T&gt;"/>
    <implements name="com.google.inject.spi.HasDependencies"/>
    <method name="getInstance" return="T"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the user-supplied instance.]]>
      </doc>
    </method>
    <method name="getInjectionPoints" return="java.util.Set&lt;com.google.inject.spi.InjectionPoint&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the field and method injection points of the instance, injected at injector-creation
 time only.

 @return a possibly empty set]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A binding to a single instance. The same instance is returned for every injection.

 @author jessewilson@google.com (Jesse Wilson)
 @since 2.0]]>
    </doc>
  </interface>
  <!-- end interface com.google.inject.spi.InstanceBinding -->
  <!-- start class com.google.inject.spi.InterceptorBinding -->
  <class name="InterceptorBinding" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.inject.spi.Element"/>
    <method name="getSource" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getClassMatcher" return="com.google.inject.matcher.Matcher&lt;? super java.lang.Class&lt;?&gt;&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getMethodMatcher" return="com.google.inject.matcher.Matcher&lt;? super java.lang.reflect.Method&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getInterceptors" return="java.util.List&lt;org.aopalliance.intercept.MethodInterceptor&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="acceptVisitor" return="T"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="visitor" type="com.google.inject.spi.ElementVisitor&lt;T&gt;"/>
    </method>
    <method name="applyTo"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="binder" type="com.google.inject.Binder"/>
    </method>
    <doc>
    <![CDATA[Registration of interceptors for matching methods of matching classes. Instances are created
 explicitly in a module using {@link com.google.inject.Binder#bindInterceptor(
 Matcher, Matcher, MethodInterceptor[]) bindInterceptor()} statements:
 <pre>
     bindInterceptor(Matchers.subclassesOf(MyAction.class),
         Matchers.annotatedWith(Transactional.class),
         new MyTransactionInterceptor());</pre>

 or from an injectable type listener using {@link TypeEncounter#bindInterceptor(Matcher,
 org.aopalliance.intercept.MethodInterceptor[]) TypeEncounter.bindInterceptor()}.

 @author jessewilson@google.com (Jesse Wilson)
 @since 2.0]]>
    </doc>
  </class>
  <!-- end class com.google.inject.spi.InterceptorBinding -->
  <!-- start interface com.google.inject.spi.LinkedKeyBinding -->
  <interface name="LinkedKeyBinding"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.inject.Binding&lt;T&gt;"/>
    <method name="getLinkedKey" return="com.google.inject.Key&lt;? extends T&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the linked key used to resolve injections. That binding can be retrieved from an
 injector using {@link com.google.inject.Injector#getBinding(Key) Injector.getBinding(key)}.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A binding to a linked key. The other key's binding is used to resolve injections.

 @author jessewilson@google.com (Jesse Wilson)
 @since 2.0]]>
    </doc>
  </interface>
  <!-- end interface com.google.inject.spi.LinkedKeyBinding -->
  <!-- start class com.google.inject.spi.MembersInjectorLookup -->
  <class name="MembersInjectorLookup" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.inject.spi.Element"/>
    <constructor name="MembersInjectorLookup" type="java.lang.Object, com.google.inject.TypeLiteral&lt;T&gt;"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getSource" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getType" return="com.google.inject.TypeLiteral&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the type containing the members to be injected.]]>
      </doc>
    </method>
    <method name="acceptVisitor" return="T"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="visitor" type="com.google.inject.spi.ElementVisitor&lt;T&gt;"/>
    </method>
    <method name="initializeDelegate"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="delegate" type="com.google.inject.MembersInjector&lt;T&gt;"/>
      <doc>
      <![CDATA[Sets the actual members injector.

 @throws IllegalStateException if the delegate is already set]]>
      </doc>
    </method>
    <method name="applyTo"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="binder" type="com.google.inject.Binder"/>
    </method>
    <method name="getDelegate" return="com.google.inject.MembersInjector&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the delegate members injector, or {@code null} if it has not yet been initialized.
 The delegate will be initialized when this element is processed, or otherwise used to create
 an injector.]]>
      </doc>
    </method>
    <method name="getMembersInjector" return="com.google.inject.MembersInjector&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the looked up members injector. The result is not valid until this lookup has been
 initialized, which usually happens when the injector is created. The members injector will
 throw an {@code IllegalStateException} if you try to use it beforehand.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A lookup of the members injector for a type. Lookups are created explicitly in a module using
 {@link com.google.inject.Binder#getMembersInjector(Class) getMembersInjector()} statements:
 <pre>
     MembersInjector&lt;PaymentService&gt; membersInjector
         = getMembersInjector(PaymentService.class);</pre>

 @author crazybob@google.com (Bob Lee)
 @since 2.0]]>
    </doc>
  </class>
  <!-- end class com.google.inject.spi.MembersInjectorLookup -->
  <!-- start class com.google.inject.spi.Message -->
  <class name="Message" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="java.io.Serializable"/>
    <implements name="com.google.inject.spi.Element"/>
    <constructor name="Message" type="java.util.List&lt;java.lang.Object&gt;, java.lang.String, java.lang.Throwable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@since 2.0]]>
      </doc>
    </constructor>
    <constructor name="Message" type="java.lang.Object, java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="Message" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getSource" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getSources" return="java.util.List&lt;java.lang.Object&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@since 2.0]]>
      </doc>
    </method>
    <method name="getMessage" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the error message text.]]>
      </doc>
    </method>
    <method name="acceptVisitor" return="T"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="visitor" type="com.google.inject.spi.ElementVisitor&lt;T&gt;"/>
      <doc>
      <![CDATA[@since 2.0]]>
      </doc>
    </method>
    <method name="getCause" return="java.lang.Throwable"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the throwable that caused this message, or {@code null} if this
 message was not caused by a throwable.

 @since 2.0]]>
      </doc>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="o" type="java.lang.Object"/>
    </method>
    <method name="applyTo"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="binder" type="com.google.inject.Binder"/>
      <doc>
      <![CDATA[@since 2.0]]>
      </doc>
    </method>
    <doc>
    <![CDATA[An error message and the context in which it occured. Messages are usually created internally by
 Guice and its extensions. Messages can be created explicitly in a module using {@link
 com.google.inject.Binder#addError(Throwable) addError()} statements:
 <pre>
     try {
       bindPropertiesFromFile();
     } catch (IOException e) {
       addError(e);
     }</pre>

 @author crazybob@google.com (Bob Lee)]]>
    </doc>
  </class>
  <!-- end class com.google.inject.spi.Message -->
  <!-- start interface com.google.inject.spi.PrivateElements -->
  <interface name="PrivateElements"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.inject.spi.Element"/>
    <method name="getElements" return="java.util.List&lt;com.google.inject.spi.Element&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the configuration information in this private environment.]]>
      </doc>
    </method>
    <method name="getInjector" return="com.google.inject.Injector"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the child injector that hosts these private elements, or null if the elements haven't
 been used to create an injector.]]>
      </doc>
    </method>
    <method name="getExposedKeys" return="java.util.Set&lt;com.google.inject.Key&lt;?&gt;&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the unique exposed keys for these private elements.]]>
      </doc>
    </method>
    <method name="getExposedSource" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="com.google.inject.Key&lt;?&gt;"/>
      <doc>
      <![CDATA[Returns an arbitrary object containing information about the "place" where this key was
 exposed. Used by Guice in the production of descriptive error messages.

 <p>Tools might specially handle types they know about; {@code StackTraceElement} is a good
 example. Tools should simply call {@code toString()} on the source object if the type is
 unfamiliar.

 @param key one of the keys exposed by this module.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A private collection of elements that are hidden from the enclosing injector or module by
 default. See {@link com.google.inject.PrivateModule PrivateModule} for details.

 @author jessewilson@google.com (Jesse Wilson)
 @since 2.0]]>
    </doc>
  </interface>
  <!-- end interface com.google.inject.spi.PrivateElements -->
  <!-- start interface com.google.inject.spi.ProviderBinding -->
  <interface name="ProviderBinding"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.inject.Binding&lt;T&gt;"/>
    <method name="getProvidedKey" return="com.google.inject.Key&lt;?&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the key whose binding is used to {@link Provider#get provide instances}. That binding
 can be retrieved from an injector using {@link com.google.inject.Injector#getBinding(Key)
 Injector.getBinding(providedKey)}]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A binding to a {@link Provider} that delegates to the binding for the provided type. This binding
 is used whenever a {@code Provider<T>} is injected (as opposed to injecting {@code T} directly).

 @author jessewilson@google.com (Jesse Wilson)
 @since 2.0]]>
    </doc>
  </interface>
  <!-- end interface com.google.inject.spi.ProviderBinding -->
  <!-- start interface com.google.inject.spi.ProviderInstanceBinding -->
  <interface name="ProviderInstanceBinding"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.inject.Binding&lt;T&gt;"/>
    <implements name="com.google.inject.spi.HasDependencies"/>
    <method name="getProviderInstance" return="com.google.inject.Provider&lt;? extends T&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the user-supplied, unscoped provider.]]>
      </doc>
    </method>
    <method name="getInjectionPoints" return="java.util.Set&lt;com.google.inject.spi.InjectionPoint&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the field and method injection points of the provider, injected at injector-creation
 time only.

 @return a possibly empty set]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A binding to a provider instance. The provider's {@code get} method is invoked to resolve
 injections.

 @author jessewilson@google.com (Jesse Wilson)
 @since 2.0]]>
    </doc>
  </interface>
  <!-- end interface com.google.inject.spi.ProviderInstanceBinding -->
  <!-- start interface com.google.inject.spi.ProviderKeyBinding -->
  <interface name="ProviderKeyBinding"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.inject.Binding&lt;T&gt;"/>
    <method name="getProviderKey" return="com.google.inject.Key&lt;? extends javax.inject.Provider&lt;? extends T&gt;&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the key used to resolve the provider's binding. That binding can be retrieved from an
 injector using {@link com.google.inject.Injector#getBinding(Key)
 Injector.getBinding(providerKey)}]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A binding to a provider key. To resolve injections, the provider key is first resolved, then that
 provider's {@code get} method is invoked.

 @author jessewilson@google.com (Jesse Wilson)
 @since 2.0]]>
    </doc>
  </interface>
  <!-- end interface com.google.inject.spi.ProviderKeyBinding -->
  <!-- start class com.google.inject.spi.ProviderLookup -->
  <class name="ProviderLookup" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.inject.spi.Element"/>
    <constructor name="ProviderLookup" type="java.lang.Object, com.google.inject.Key&lt;T&gt;"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getSource" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getKey" return="com.google.inject.Key&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="acceptVisitor" return="T"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="visitor" type="com.google.inject.spi.ElementVisitor&lt;T&gt;"/>
    </method>
    <method name="initializeDelegate"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="delegate" type="com.google.inject.Provider&lt;T&gt;"/>
      <doc>
      <![CDATA[Sets the actual provider.

 @throws IllegalStateException if the delegate is already set]]>
      </doc>
    </method>
    <method name="applyTo"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="binder" type="com.google.inject.Binder"/>
    </method>
    <method name="getDelegate" return="com.google.inject.Provider&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the delegate provider, or {@code null} if it has not yet been initialized. The delegate
 will be initialized when this element is processed, or otherwise used to create an injector.]]>
      </doc>
    </method>
    <method name="getProvider" return="com.google.inject.Provider&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the looked up provider. The result is not valid until this lookup has been initialized,
 which usually happens when the injector is created. The provider will throw an {@code
 IllegalStateException} if you try to use it beforehand.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A lookup of the provider for a type. Lookups are created explicitly in a module using
 {@link com.google.inject.Binder#getProvider(Class) getProvider()} statements:
 <pre>
     Provider&lt;PaymentService&gt; paymentServiceProvider
         = getProvider(PaymentService.class);</pre>

 @author jessewilson@google.com (Jesse Wilson)
 @since 2.0]]>
    </doc>
  </class>
  <!-- end class com.google.inject.spi.ProviderLookup -->
  <!-- start interface com.google.inject.spi.ProviderWithDependencies -->
  <interface name="ProviderWithDependencies"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.inject.Provider&lt;T&gt;"/>
    <implements name="com.google.inject.spi.HasDependencies"/>
    <doc>
    <![CDATA[A provider with dependencies on other injected types. If a {@link Provider} has dependencies that
 aren't specified in injections, this interface should be used to expose all dependencies.

 @since 2.0]]>
    </doc>
  </interface>
  <!-- end interface com.google.inject.spi.ProviderWithDependencies -->
  <!-- start interface com.google.inject.spi.ProviderWithExtensionVisitor -->
  <interface name="ProviderWithExtensionVisitor"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.inject.Provider&lt;T&gt;"/>
    <method name="acceptExtensionVisitor" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="visitor" type="com.google.inject.spi.BindingTargetVisitor&lt;B, V&gt;"/>
      <param name="binding" type="com.google.inject.spi.ProviderInstanceBinding&lt;? extends B&gt;"/>
      <doc>
      <![CDATA[Instructs the extension determine if the visitor is an instance of a custom
 extension visitor, and if so, visit it using that method. If the visitor is
 not an instance of the custom extension visitor, this method <b>MUST</b>
 call visitor.visit(binding).
 <p> 
 Due to issues with generics, the type parameters of this method do not
 relate to the type of the provider. In practice, the 'B' type will always
 be a supertype of 'T'.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A Provider that is part of an extension which supports a custom
 BindingTargetVisitor.
 <p> 
 When an extension binds a provider instance, the provider can implement this
 interface to allow users using the
 {@link Binding#acceptTargetVisitor(BindingTargetVisitor)} method to visit a
 custom visitor designed for that extension. A typical implementation within
 the extension would look like
 <pre> 
 &lt;V, B> V acceptExtensionVisitor(BindingTargetVisitor&lt;B, V> visitor, ProviderInstanceBinding&lt;? extends B> binding) {
   if(visitor instanceof MyCustomExtensionVisitor) {
     return ((MyCustomExtensionVisitor&lt;B, V>)visitor).visitCustomExtension(customProperties, binding);
   } else {
     return visitor.visit(binding);
   }
 }</pre> 
 'MyCustomExtensionVisitor' in the example above would be an interface the
 extension provides that users can implement in order to be notified of custom
 extension information. These visitor interfaces must extend from
 BindingTargetVisitor.

 @since 3.0
 @author sameb@google.com (Sam Berlin)]]>
    </doc>
  </interface>
  <!-- end interface com.google.inject.spi.ProviderWithExtensionVisitor -->
  <!-- start class com.google.inject.spi.RequireExplicitBindingsOption -->
  <class name="RequireExplicitBindingsOption" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.inject.spi.Element"/>
    <method name="getSource" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="applyTo"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="binder" type="com.google.inject.Binder"/>
    </method>
    <method name="acceptVisitor" return="T"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="visitor" type="com.google.inject.spi.ElementVisitor&lt;T&gt;"/>
    </method>
    <doc>
    <![CDATA[A request to require explicit bindings.

 @author sameb@google.com (Sam Berlin)
 @since 3.0]]>
    </doc>
  </class>
  <!-- end class com.google.inject.spi.RequireExplicitBindingsOption -->
  <!-- start class com.google.inject.spi.ScopeBinding -->
  <class name="ScopeBinding" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.inject.spi.Element"/>
    <method name="getSource" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getAnnotationType" return="java.lang.Class&lt;? extends java.lang.annotation.Annotation&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getScope" return="com.google.inject.Scope"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="acceptVisitor" return="T"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="visitor" type="com.google.inject.spi.ElementVisitor&lt;T&gt;"/>
    </method>
    <method name="applyTo"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="binder" type="com.google.inject.Binder"/>
    </method>
    <doc>
    <![CDATA[Registration of a scope annotation with the scope that implements it. Instances are created
 explicitly in a module using {@link com.google.inject.Binder#bindScope(Class, Scope) bindScope()}
 statements:
 <pre>
     Scope recordScope = new RecordScope();
     bindScope(RecordScoped.class, new RecordScope());</pre>

 @author jessewilson@google.com (Jesse Wilson)
 @since 2.0]]>
    </doc>
  </class>
  <!-- end class com.google.inject.spi.ScopeBinding -->
  <!-- start class com.google.inject.spi.StaticInjectionRequest -->
  <class name="StaticInjectionRequest" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.inject.spi.Element"/>
    <method name="getSource" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getType" return="java.lang.Class&lt;?&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getInjectionPoints" return="java.util.Set&lt;com.google.inject.spi.InjectionPoint&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="ConfigurationException" type="com.google.inject.ConfigurationException"/>
      <doc>
      <![CDATA[Returns the static methods and fields of {@code type} that will be injected to fulfill this
 request.

 @return a possibly empty set of injection points. The set has a specified iteration order. All
      fields are returned and then all methods. Within the fields, supertype fields are returned
      before subtype fields. Similarly, supertype methods are returned before subtype methods.
 @throws ConfigurationException if there is a malformed injection point on {@code type}, such as
      a field with multiple binding annotations. The exception's {@link
      ConfigurationException#getPartialValue() partial value} is a {@code Set<InjectionPoint>}
      of the valid injection points.]]>
      </doc>
    </method>
    <method name="applyTo"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="binder" type="com.google.inject.Binder"/>
    </method>
    <method name="acceptVisitor" return="T"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="visitor" type="com.google.inject.spi.ElementVisitor&lt;T&gt;"/>
    </method>
    <doc>
    <![CDATA[A request to inject the static fields and methods of a type. Requests are created
 explicitly in a module using {@link com.google.inject.Binder#requestStaticInjection(Class[])
 requestStaticInjection()} statements:
 <pre>
     requestStaticInjection(MyLegacyService.class);</pre>

 @author jessewilson@google.com (Jesse Wilson)
 @since 2.0]]>
    </doc>
  </class>
  <!-- end class com.google.inject.spi.StaticInjectionRequest -->
  <!-- start class com.google.inject.spi.Toolable -->
  <class name="Toolable"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.lang.annotation.Annotation"/>
    <doc>
    <![CDATA[Instructs an {@link Injector} running in {@link Stage#TOOL} that a method should be injected.
 This is typically useful for for extensions to Guice that perform additional validation in an
 injected method or field.  This only applies to objects that are already constructed when
 bindings are created (ie., something bound using {@link
 com.google.inject.binder.LinkedBindingBuilder#toProvider toProvider}, {@link
 com.google.inject.binder.LinkedBindingBuilder#toInstance toInstance}, or {@link
 com.google.inject.Binder#requestInjection requestInjection}.
 
 @author sberlin@gmail.com (Sam Berlin)
 @since 3.0]]>
    </doc>
  </class>
  <!-- end class com.google.inject.spi.Toolable -->
  <!-- start interface com.google.inject.spi.TypeConverter -->
  <interface name="TypeConverter"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="convert" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="java.lang.String"/>
      <param name="toType" type="com.google.inject.TypeLiteral&lt;?&gt;"/>
      <doc>
      <![CDATA[Converts a string value. Throws an exception if a conversion error occurs.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Converts constant string values to a different type.

 @author crazybob@google.com (Bob Lee)
 @since 2.0]]>
    </doc>
  </interface>
  <!-- end interface com.google.inject.spi.TypeConverter -->
  <!-- start class com.google.inject.spi.TypeConverterBinding -->
  <class name="TypeConverterBinding" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.inject.spi.Element"/>
    <constructor name="TypeConverterBinding" type="java.lang.Object, com.google.inject.matcher.Matcher&lt;? super com.google.inject.TypeLiteral&lt;?&gt;&gt;, com.google.inject.spi.TypeConverter"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@since 3.0]]>
      </doc>
    </constructor>
    <method name="getSource" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getTypeMatcher" return="com.google.inject.matcher.Matcher&lt;? super com.google.inject.TypeLiteral&lt;?&gt;&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getTypeConverter" return="com.google.inject.spi.TypeConverter"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="acceptVisitor" return="T"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="visitor" type="com.google.inject.spi.ElementVisitor&lt;T&gt;"/>
    </method>
    <method name="applyTo"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="binder" type="com.google.inject.Binder"/>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Registration of type converters for matching target types. Instances are created
 explicitly in a module using {@link com.google.inject.Binder#convertToTypes(Matcher,
 TypeConverter) convertToTypes()} statements:
 <pre>
     convertToTypes(Matchers.only(TypeLiteral.get(DateTime.class)), new DateTimeConverter());</pre>

 @author jessewilson@google.com (Jesse Wilson)
 @since 2.0]]>
    </doc>
  </class>
  <!-- end class com.google.inject.spi.TypeConverterBinding -->
  <!-- start interface com.google.inject.spi.TypeEncounter -->
  <interface name="TypeEncounter"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="addError"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="message" type="java.lang.String"/>
      <param name="arguments" type="java.lang.Object[]"/>
      <doc>
      <![CDATA[Records an error message for type {@code I} which will be presented to the user at a later
 time. Unlike throwing an exception, this enable us to continue configuring the Injector and
 discover more errors. Uses {@link String#format(String, Object[])} to insert the arguments
 into the message.]]>
      </doc>
    </method>
    <method name="addError"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="t" type="java.lang.Throwable"/>
      <doc>
      <![CDATA[Records an exception for type {@code I}, the full details of which will be logged, and the
 message of which will be presented to the user at a later time. If your type listener calls
 something that you worry may fail, you should catch the exception and pass it to this method.]]>
      </doc>
    </method>
    <method name="addError"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="message" type="com.google.inject.spi.Message"/>
      <doc>
      <![CDATA[Records an error message to be presented to the user at a later time.]]>
      </doc>
    </method>
    <method name="getProvider" return="com.google.inject.Provider&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="com.google.inject.Key&lt;T&gt;"/>
      <doc>
      <![CDATA[Returns the provider used to obtain instances for the given injection key. The returned
 provider will not be valid until the injector has been created. The provider will throw an
 {@code IllegalStateException} if you try to use it beforehand.]]>
      </doc>
    </method>
    <method name="getProvider" return="com.google.inject.Provider&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="java.lang.Class&lt;T&gt;"/>
      <doc>
      <![CDATA[Returns the provider used to obtain instances for the given injection type. The returned
 provider will not be valid until the injetor has been created. The provider will throw an
 {@code IllegalStateException} if you try to use it beforehand.]]>
      </doc>
    </method>
    <method name="getMembersInjector" return="com.google.inject.MembersInjector&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="typeLiteral" type="com.google.inject.TypeLiteral&lt;T&gt;"/>
      <doc>
      <![CDATA[Returns the members injector used to inject dependencies into methods and fields on instances
 of the given type {@code T}. The returned members injector will not be valid until the main
 injector has been created. The members injector will throw an {@code IllegalStateException}
 if you try to use it beforehand.

 @param typeLiteral type to get members injector for]]>
      </doc>
    </method>
    <method name="getMembersInjector" return="com.google.inject.MembersInjector&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="java.lang.Class&lt;T&gt;"/>
      <doc>
      <![CDATA[Returns the members injector used to inject dependencies into methods and fields on instances
 of the given type {@code T}. The returned members injector will not be valid until the main
 injector has been created. The members injector will throw an {@code IllegalStateException}
 if you try to use it beforehand.

 @param type type to get members injector for]]>
      </doc>
    </method>
    <method name="register"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="membersInjector" type="com.google.inject.MembersInjector&lt;? super I&gt;"/>
      <doc>
      <![CDATA[Registers a members injector for type {@code I}. Guice will use the members injector after its
 performed its own injections on an instance of {@code I}.]]>
      </doc>
    </method>
    <method name="register"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="listener" type="com.google.inject.spi.InjectionListener&lt;? super I&gt;"/>
      <doc>
      <![CDATA[Registers an injection listener for type {@code I}. Guice will notify the listener after all
 injections have been performed on an instance of {@code I}.]]>
      </doc>
    </method>
    <method name="bindInterceptor"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="methodMatcher" type="com.google.inject.matcher.Matcher&lt;? super java.lang.reflect.Method&gt;"/>
      <param name="interceptors" type="org.aopalliance.intercept.MethodInterceptor[]"/>
      <doc>
      <![CDATA[Binds method interceptor[s] to methods matched in type {@code I} and its supertypes. A
 method is eligible for interception if:

 <ul>
  <li>Guice created the instance the method is on</li>
  <li>Neither the enclosing type nor the method is final</li>
  <li>And the method is package-private or more accessible</li>
 </ul>

 @param methodMatcher matches methods the interceptor should apply to. For
     example: {@code annotatedWith(Transactional.class)}.
 @param interceptors to bind]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Context of an injectable type encounter. Enables reporting errors, registering injection
 listeners and binding method interceptors for injectable type {@code I}. It is an error to use
 an encounter after the {@link TypeListener#hear(TypeLiteral, TypeEncounter) hear()} method has
 returned.

 @param <I> the injectable type encountered
 @since 2.0]]>
    </doc>
  </interface>
  <!-- end interface com.google.inject.spi.TypeEncounter -->
  <!-- start interface com.google.inject.spi.TypeListener -->
  <interface name="TypeListener"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="hear"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="com.google.inject.TypeLiteral&lt;I&gt;"/>
      <param name="encounter" type="com.google.inject.spi.TypeEncounter&lt;I&gt;"/>
      <doc>
      <![CDATA[Invoked when Guice encounters a new type eligible for constructor or members injection.
 Called during injector creation (or afterwords if Guice encounters a type at run time and
 creates a JIT binding).

 @param type encountered by Guice
 @param encounter context of this encounter, enables reporting errors, registering injection
     listeners and binding method interceptors for {@code type}.

 @param <I> the injectable type]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Listens for Guice to encounter injectable types. If a given type has its constructor injected in
 one situation but only its methods and fields injected in another, Guice will notify this
 listener once.

 <p>Useful for extra type checking, {@linkplain TypeEncounter#register(InjectionListener)
 registering injection listeners}, and {@linkplain TypeEncounter#bindInterceptor(
 com.google.inject.matcher.Matcher, org.aopalliance.intercept.MethodInterceptor[])
 binding method interceptors}.
 
 @since 2.0]]>
    </doc>
  </interface>
  <!-- end interface com.google.inject.spi.TypeListener -->
  <!-- start class com.google.inject.spi.TypeListenerBinding -->
  <class name="TypeListenerBinding" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.inject.spi.Element"/>
    <method name="getListener" return="com.google.inject.spi.TypeListener"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the registered listener.]]>
      </doc>
    </method>
    <method name="getTypeMatcher" return="com.google.inject.matcher.Matcher&lt;? super com.google.inject.TypeLiteral&lt;?&gt;&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the type matcher which chooses which types the listener should be notified of.]]>
      </doc>
    </method>
    <method name="getSource" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="acceptVisitor" return="T"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="visitor" type="com.google.inject.spi.ElementVisitor&lt;T&gt;"/>
    </method>
    <method name="applyTo"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="binder" type="com.google.inject.Binder"/>
    </method>
    <doc>
    <![CDATA[Binds types (picked using a Matcher) to an type listener. Registrations are created explicitly in
 a module using {@link com.google.inject.Binder#bindListener(Matcher, TypeListener)} statements:

 <pre>
     register(only(new TypeLiteral&lt;PaymentService&lt;CreditCard>>() {}), listener);</pre>

 @author jessewilson@google.com (Jesse Wilson)
 @since 2.0]]>
    </doc>
  </class>
  <!-- end class com.google.inject.spi.TypeListenerBinding -->
  <!-- start interface com.google.inject.spi.UntargettedBinding -->
  <interface name="UntargettedBinding"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.inject.Binding&lt;T&gt;"/>
    <doc>
    <![CDATA[An untargetted binding. This binding indicates that the injector should use its implicit binding
 strategies to resolve injections.

 @author jessewilson@google.com (Jesse Wilson)
 @since 2.0]]>
    </doc>
  </interface>
  <!-- end interface com.google.inject.spi.UntargettedBinding -->
</package>
<package name="com.google.inject.spring">
  <!-- start class com.google.inject.spring.SpringIntegration -->
  <class name="SpringIntegration" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="fromSpring" return="com.google.inject.Provider&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="java.lang.Class&lt;T&gt;"/>
      <param name="name" type="java.lang.String"/>
      <doc>
      <![CDATA[Creates a provider which looks up objects from Spring using the given name.
 Expects a binding to {@link
 org.springframework.beans.factory.BeanFactory}. Example usage:

 <pre>
 bind(DataSource.class)
   .toProvider(fromSpring(DataSource.class, "dataSource"));
 </pre>]]>
      </doc>
    </method>
    <method name="bindAll"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="binder" type="com.google.inject.Binder"/>
      <param name="beanFactory" type="ListableBeanFactory"/>
      <doc>
      <![CDATA[Binds all Spring beans from the given factory by name. For a Spring bean
 named "foo", this method creates a binding to the bean's type and
 {@code @Named("foo")}.

 @see com.google.inject.name.Named
 @see com.google.inject.name.Names#named(String)]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Integrates Guice with Spring.

 @author crazybob@google.com (Bob Lee)]]>
    </doc>
  </class>
  <!-- end class com.google.inject.spring.SpringIntegration -->
</package>
<package name="com.google.inject.struts2">
  <!-- start class com.google.inject.struts2.GuiceObjectFactory -->
  <class name="GuiceObjectFactory" extends="ObjectFactory"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="Use {@link com.google.inject.servlet.Struts2Factory} instead.">
    <constructor name="GuiceObjectFactory"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="isNoArgConstructorRequired" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getClassInstance" return="java.lang.Class"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <exception name="ClassNotFoundException" type="java.lang.ClassNotFoundException"/>
    </method>
    <method name="buildBean" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="clazz" type="java.lang.Class"/>
      <param name="extraContext" type="java.util.Map"/>
    </method>
    <method name="buildInterceptor" return="Interceptor"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="interceptorConfig" type="InterceptorConfig"/>
      <param name="interceptorRefParams" type="java.util.Map"/>
      <exception name="ConfigurationException" type="ConfigurationException"/>
    </method>
    <doc>
    <![CDATA[@deprecated Use {@link com.google.inject.servlet.Struts2Factory} instead.]]>
    </doc>
  </class>
  <!-- end class com.google.inject.struts2.GuiceObjectFactory -->
  <!-- start class com.google.inject.struts2.Struts2Factory -->
  <class name="Struts2Factory" extends="ObjectFactory"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="Struts2Factory"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="isNoArgConstructorRequired" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getClassInstance" return="java.lang.Class&lt;?&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <exception name="ClassNotFoundException" type="java.lang.ClassNotFoundException"/>
    </method>
    <method name="buildBean" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="clazz" type="java.lang.Class"/>
      <param name="extraContext" type="java.util.Map&lt;java.lang.String, java.lang.Object&gt;"/>
    </method>
    <method name="buildInterceptor" return="Interceptor"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="interceptorConfig" type="InterceptorConfig"/>
      <param name="interceptorRefParams" type="java.util.Map"/>
      <exception name="ConfigurationException" type="ConfigurationException"/>
    </method>
    <doc>
    <![CDATA[Cleanup up version from Bob's GuiceObjectFactory. Now works properly with
 GS2 and fixes several bugs.

 @author dhanji@gmail.com
 @author benmccann.com]]>
    </doc>
  </class>
  <!-- end class com.google.inject.struts2.Struts2Factory -->
  <!-- start class com.google.inject.struts2.Struts2GuicePluginModule -->
  <class name="Struts2GuicePluginModule" extends="com.google.inject.AbstractModule"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="Struts2GuicePluginModule"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="configure"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Initializes the Struts 2 Guice Plugin.
 Must be added to the injector returned by
     {@link GuiceServletContextListener.getInjector()}.

 @author benmccann.com]]>
    </doc>
  </class>
  <!-- end class com.google.inject.struts2.Struts2GuicePluginModule -->
</package>
<package name="com.google.inject.throwingproviders">
  <!-- start interface com.google.inject.throwingproviders.CheckedProvider -->
  <interface name="CheckedProvider"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="get" return="T"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="Exception" type="java.lang.Exception"/>
    </method>
    <doc>
    <![CDATA[Alternative to the Guice {@link com.google.inject.Provider} that throws
 a checked Exception. Users may not inject {@code T} directly.

 <p>This interface must be extended to use application-specific exception types.
 Such subinterfaces may not define new methods, but may narrow the exception type.
 <pre>
 public interface RemoteProvider&lt;T&gt; extends CheckedProvider&lt;T&gt; { 
   T get() throws CustomExceptionOne, CustomExceptionTwo;
 }
 </pre>

 <p>When this type is bound using {@link ThrowingProviderBinder}, the value returned
 or exception thrown by {@link #get} will be scoped. As a consequence, {@link #get}
 will invoked at most once within each scope.
 
 @since 3.0]]>
    </doc>
  </interface>
  <!-- end interface com.google.inject.throwingproviders.CheckedProvider -->
  <!-- start class com.google.inject.throwingproviders.CheckedProvides -->
  <class name="CheckedProvides"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.lang.annotation.Annotation"/>
    <doc>
    <![CDATA[Annotates methods of a {@link Module} to create a {@link CheckedProvider}
 method binding that can throw exceptions. The method's return type is bound
 to a {@link CheckedProvider} that can be injected. Guice will pass
 dependencies to the method as parameters. Install {@literal @}CheckedProvides
 methods by using
 {@link ThrowingProviderBinder#forModule(com.google.inject.Module)} on the
 module where the methods are declared.
 
 @author sameb@google.com (Sam Berlin)
 @since 3.0]]>
    </doc>
  </class>
  <!-- end class com.google.inject.throwingproviders.CheckedProvides -->
  <!-- start interface com.google.inject.throwingproviders.ThrowingProvider -->
  <interface name="ThrowingProvider"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="use {@link CheckedProvider} instead.">
    <implements name="com.google.inject.throwingproviders.CheckedProvider&lt;T&gt;"/>
    <method name="get" return="T"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="Exception" type="java.lang.Exception"/>
    </method>
    <doc>
    <![CDATA[Alternative to the Guice {@link com.google.inject.Provider} that throws
 a checked Exception. Users may not inject {@code T} directly.

 <p>This interface must be extended to use application-specific exception types.
 Such subinterfaces may not define new methods:
 <pre>
 public interface RemoteProvider&lt;T&gt; extends ThrowingProvider&lt;T, RemoteException&gt; { }
 </pre>

 <p>When this type is bound using {@link ThrowingProviderBinder}, the value returned
 or exception thrown by {@link #get} will be scoped. As a consequence, {@link #get}
 will invoked at most once within each scope.

 @author jmourits@google.com (Jerome Mourits)
 @author jessewilson@google.com (Jesse Wilson)
 @deprecated use {@link CheckedProvider} instead.]]>
    </doc>
  </interface>
  <!-- end interface com.google.inject.throwingproviders.ThrowingProvider -->
  <!-- start class com.google.inject.throwingproviders.ThrowingProviderBinder -->
  <class name="ThrowingProviderBinder" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="create" return="com.google.inject.throwingproviders.ThrowingProviderBinder"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="binder" type="com.google.inject.Binder"/>
    </method>
    <method name="forModule" return="com.google.inject.Module"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="module" type="com.google.inject.Module"/>
      <doc>
      <![CDATA[Returns a module that installs {@literal @}{@link CheckedProvides} methods.
 
 @since 3.0]]>
      </doc>
    </method>
    <method name="bind" return="com.google.inject.throwingproviders.ThrowingProviderBinder.SecondaryBinder&lt;P&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="interfaceType" type="java.lang.Class&lt;P&gt;"/>
      <param name="valueType" type="java.lang.reflect.Type"/>
    </method>
    <doc>
    <![CDATA[<p>Builds a binding for a {@link CheckedProvider}.
 
 <p>You can use a fluent API and custom providers:
 <pre><code>ThrowingProviderBinder.create(binder())
    .bind(RemoteProvider.class, Customer.class)
    .to(RemoteCustomerProvider.class)
    .in(RequestScope.class);
 </code></pre>
 or, you can use throwing provider methods:
 <pre><code>class MyModule extends AbstractModule {
   configure() {
     ThrowingProviderBinder.install(this, binder());
   }
   
   {@literal @}CheckedProvides(RemoteProvider.class)
   {@literal @}RequestScope
   Customer provideCustomer(FlakyCustomerCreator creator) throws RemoteException {
     return creator.getCustomerOrThrow();
   }
 }
 </code></pre>
 
 @author jmourits@google.com (Jerome Mourits)
 @author jessewilson@google.com (Jesse Wilson)]]>
    </doc>
  </class>
  <!-- end class com.google.inject.throwingproviders.ThrowingProviderBinder -->
  <!-- start class com.google.inject.throwingproviders.ThrowingProviderBinder.SecondaryBinder -->
  <class name="ThrowingProviderBinder.SecondaryBinder" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="ThrowingProviderBinder.SecondaryBinder" type="java.lang.Class&lt;P&gt;, java.lang.reflect.Type"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="annotatedWith" return="com.google.inject.throwingproviders.ThrowingProviderBinder.SecondaryBinder&lt;P&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="annotationType" type="java.lang.Class&lt;? extends java.lang.annotation.Annotation&gt;"/>
    </method>
    <method name="annotatedWith" return="com.google.inject.throwingproviders.ThrowingProviderBinder.SecondaryBinder&lt;P&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="annotation" type="java.lang.annotation.Annotation"/>
    </method>
    <method name="to" return="com.google.inject.binder.ScopedBindingBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="target" type="P extends com.google.inject.throwingproviders.CheckedProvider"/>
    </method>
    <method name="to" return="com.google.inject.binder.ScopedBindingBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="targetType" type="java.lang.Class&lt;? extends P&gt;"/>
    </method>
    <method name="to" return="com.google.inject.binder.ScopedBindingBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="targetKey" type="com.google.inject.Key&lt;? extends P&gt;"/>
    </method>
  </class>
  <!-- end class com.google.inject.throwingproviders.ThrowingProviderBinder.SecondaryBinder -->
</package>
<package name="com.google.inject.tools.jmx">
  <!-- start interface com.google.inject.tools.jmx.ManagedBindingMBean -->
  <interface name="ManagedBindingMBean"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="getSource" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the source of this binding.]]>
      </doc>
    </method>
    <method name="getProvider" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the provider to which this binding is bound.]]>
      </doc>
    </method>
    <method name="getKey" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the binding key.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[JMX interface to bindings.

 @author crazybob@google.com (Bob Lee)]]>
    </doc>
  </interface>
  <!-- end interface com.google.inject.tools.jmx.ManagedBindingMBean -->
  <!-- start class com.google.inject.tools.jmx.Manager -->
  <class name="Manager" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="Manager"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="manage"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="domain" type="java.lang.String"/>
      <param name="injector" type="com.google.inject.Injector"/>
      <doc>
      <![CDATA[Registers all the bindings of an Injector with the platform MBean server.
 Consider using the name of your root {@link Module} class as the domain.]]>
      </doc>
    </method>
    <method name="manage"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="server" type="javax.management.MBeanServer"/>
      <param name="domain" type="java.lang.String"/>
      <param name="injector" type="com.google.inject.Injector"/>
      <doc>
      <![CDATA[Registers all the bindings of an Injector with the given MBean server.
 Consider using the name of your root {@link Module} class as the domain.]]>
      </doc>
    </method>
    <method name="main"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="args" type="java.lang.String[]"/>
      <exception name="Exception" type="java.lang.Exception"/>
      <doc>
      <![CDATA[Run with no arguments for usage instructions.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Provides a JMX interface to Guice.

 @author crazybob@google.com (Bob Lee)]]>
    </doc>
  </class>
  <!-- end class com.google.inject.tools.jmx.Manager -->
</package>
<package name="com.google.inject.util">
  <!-- start class com.google.inject.util.Modules -->
  <class name="Modules" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="override" return="com.google.inject.util.Modules.OverriddenModuleBuilder"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="modules" type="com.google.inject.Module[]"/>
      <doc>
      <![CDATA[Returns a builder that creates a module that overlays override modules over the given
 modules. If a key is bound in both sets of modules, only the binding from the override modules
 is kept. If a single {@link PrivateModule} is supplied or all elements are from
 a single {@link PrivateBinder}, then this will overwrite the private bindings.
 Otherwise, private bindings will not be overwritten unless they are exposed. 
 This can be used to replace the bindings of a production module with test bindings:
 <pre>
 Module functionalTestModule
     = Modules.override(new ProductionModule()).with(new TestModule());
 </pre>

 <p>Prefer to write smaller modules that can be reused and tested without overrides.

 @param modules the modules whose bindings are open to be overridden]]>
      </doc>
    </method>
    <method name="override" return="com.google.inject.util.Modules.OverriddenModuleBuilder"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="modules" type="java.lang.Iterable&lt;? extends com.google.inject.Module&gt;"/>
      <doc>
      <![CDATA[Returns a builder that creates a module that overlays override modules over the given
 modules. If a key is bound in both sets of modules, only the binding from the override modules
 is kept. If a single {@link PrivateModule} is supplied or all elements are from
 a single {@link PrivateBinder}, then this will overwrite the private bindings.
 Otherwise, private bindings will not be overwritten unless they are exposed. 
 This can be used to replace the bindings of a production module with test bindings:
 <pre>
 Module functionalTestModule
     = Modules.override(getProductionModules()).with(getTestModules());
 </pre>

 <p>Prefer to write smaller modules that can be reused and tested without overrides.

 @param modules the modules whose bindings are open to be overridden]]>
      </doc>
    </method>
    <method name="combine" return="com.google.inject.Module"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="modules" type="com.google.inject.Module[]"/>
      <doc>
      <![CDATA[Returns a new module that installs all of {@code modules}.]]>
      </doc>
    </method>
    <method name="combine" return="com.google.inject.Module"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="modules" type="java.lang.Iterable&lt;? extends com.google.inject.Module&gt;"/>
      <doc>
      <![CDATA[Returns a new module that installs all of {@code modules}.]]>
      </doc>
    </method>
    <field name="EMPTY_MODULE" type="com.google.inject.Module"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[Static utility methods for creating and working with instances of {@link Module}.

 @author jessewilson@google.com (Jesse Wilson)
 @since 2.0]]>
    </doc>
  </class>
  <!-- end class com.google.inject.util.Modules -->
  <!-- start interface com.google.inject.util.Modules.OverriddenModuleBuilder -->
  <interface name="Modules.OverriddenModuleBuilder"    abstract="true"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="with" return="com.google.inject.Module"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="overrides" type="com.google.inject.Module[]"/>
      <doc>
      <![CDATA[See the EDSL example at {@link Modules#override(Module[]) override()}.]]>
      </doc>
    </method>
    <method name="with" return="com.google.inject.Module"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="overrides" type="java.lang.Iterable&lt;? extends com.google.inject.Module&gt;"/>
      <doc>
      <![CDATA[See the EDSL example at {@link Modules#override(Module[]) override()}.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[See the EDSL example at {@link Modules#override(Module[]) override()}.]]>
    </doc>
  </interface>
  <!-- end interface com.google.inject.util.Modules.OverriddenModuleBuilder -->
  <!-- start class com.google.inject.util.Providers -->
  <class name="Providers" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="of" return="com.google.inject.Provider&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="instance" type="T"/>
      <doc>
      <![CDATA[Returns a provider which always provides {@code instance}.  This should not
 be necessary to use in your application, but is helpful for several types
 of unit tests.

 @param instance the instance that should always be provided.  This is also
     permitted to be null, to enable aggressive testing, although in real
     life a Guice-supplied Provider will never return null.]]>
      </doc>
    </method>
    <method name="guicify" return="com.google.inject.Provider&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="provider" type="javax.inject.Provider&lt;T&gt;"/>
      <doc>
      <![CDATA[Returns a Guice-friendly {@code com.google.inject.Provider} for the given
 JSR-330 {@code javax.inject.Provider}. The converse method is unnecessary,
 since Guice providers directly implement the JSR-330 interface.
 
 @since 3.0]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Static utility methods for creating and working with instances of
 {@link Provider}.

 @author Kevin Bourrillion (kevinb9n@gmail.com)
 @since 2.0]]>
    </doc>
  </class>
  <!-- end class com.google.inject.util.Providers -->
  <!-- start class com.google.inject.util.Types -->
  <class name="Types" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="newParameterizedType" return="java.lang.reflect.ParameterizedType"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="rawType" type="java.lang.reflect.Type"/>
      <param name="typeArguments" type="java.lang.reflect.Type[]"/>
      <doc>
      <![CDATA[Returns a new parameterized type, applying {@code typeArguments} to
 {@code rawType}. The returned type does not have an owner type.

 @return a {@link java.io.Serializable serializable} parameterized type.]]>
      </doc>
    </method>
    <method name="newParameterizedTypeWithOwner" return="java.lang.reflect.ParameterizedType"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="ownerType" type="java.lang.reflect.Type"/>
      <param name="rawType" type="java.lang.reflect.Type"/>
      <param name="typeArguments" type="java.lang.reflect.Type[]"/>
      <doc>
      <![CDATA[Returns a new parameterized type, applying {@code typeArguments} to
 {@code rawType} and enclosed by {@code ownerType}.

 @return a {@link java.io.Serializable serializable} parameterized type.]]>
      </doc>
    </method>
    <method name="arrayOf" return="java.lang.reflect.GenericArrayType"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="componentType" type="java.lang.reflect.Type"/>
      <doc>
      <![CDATA[Returns an array type whose elements are all instances of
 {@code componentType}.

 @return a {@link java.io.Serializable serializable} generic array type.]]>
      </doc>
    </method>
    <method name="subtypeOf" return="java.lang.reflect.WildcardType"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="bound" type="java.lang.reflect.Type"/>
      <doc>
      <![CDATA[Returns a type that represents an unknown type that extends {@code bound}.
 For example, if {@code bound} is {@code CharSequence.class}, this returns
 {@code ? extends CharSequence}. If {@code bound} is {@code Object.class},
 this returns {@code ?}, which is shorthand for {@code ? extends Object}.]]>
      </doc>
    </method>
    <method name="supertypeOf" return="java.lang.reflect.WildcardType"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="bound" type="java.lang.reflect.Type"/>
      <doc>
      <![CDATA[Returns a type that represents an unknown supertype of {@code bound}. For
 example, if {@code bound} is {@code String.class}, this returns {@code ?
 super String}.]]>
      </doc>
    </method>
    <method name="listOf" return="java.lang.reflect.ParameterizedType"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="elementType" type="java.lang.reflect.Type"/>
      <doc>
      <![CDATA[Returns a type modelling a {@link List} whose elements are of type
 {@code elementType}.

 @return a {@link java.io.Serializable serializable} parameterized type.]]>
      </doc>
    </method>
    <method name="setOf" return="java.lang.reflect.ParameterizedType"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="elementType" type="java.lang.reflect.Type"/>
      <doc>
      <![CDATA[Returns a type modelling a {@link Set} whose elements are of type
 {@code elementType}.

 @return a {@link java.io.Serializable serializable} parameterized type.]]>
      </doc>
    </method>
    <method name="mapOf" return="java.lang.reflect.ParameterizedType"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="keyType" type="java.lang.reflect.Type"/>
      <param name="valueType" type="java.lang.reflect.Type"/>
      <doc>
      <![CDATA[Returns a type modelling a {@link Map} whose keys are of type
 {@code keyType} and whose values are of type {@code valueType}.

 @return a {@link java.io.Serializable serializable} parameterized type.]]>
      </doc>
    </method>
    <method name="providerOf" return="java.lang.reflect.ParameterizedType"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="providedType" type="java.lang.reflect.Type"/>
      <doc>
      <![CDATA[Returns a type modelling a {@link Provider} that provides elements of type
 {@code elementType}.

 @return a {@link java.io.Serializable serializable} parameterized type.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Static methods for working with types.

 @author crazybob@google.com (Bob Lee)
 @since 2.0]]>
    </doc>
  </class>
  <!-- end class com.google.inject.util.Types -->
</package>

</api>
