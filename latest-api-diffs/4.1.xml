<?xml version="1.0" encoding="iso-8859-1" standalone="no"?>
<!-- Generated by the JDiff Javadoc doclet -->
<!-- (http://www.jdiff.org) -->
<!-- on Fri Jun 17 16:00:51 EDT 2016 -->

<api
  xmlns:xsi='http://www.w3.org/2001/XMLSchema-instance'
  xsi:noNamespaceSchemaLocation='api.xsd'
  name="4.1"
  jdversion="1.1.1">

<!--  Command line arguments =  -doclet jdiff.JDiff -docletpath /tmp/moe_git_clone_googlecode_6763913321787039468/lib/build/jdiff/jdiff.jar:/tmp/moe_git_clone_googlecode_6763913321787039468/lib/build/jdiff/xerces.jar -classpath /tmp/moe_git_clone_googlecode_6763913321787039468/lib/aopalliance.jar:/tmp/moe_git_clone_googlecode_6763913321787039468/lib/guava-19.0.jar:/tmp/moe_git_clone_googlecode_6763913321787039468/lib/javax.inject.jar:/tmp/moe_git_clone_googlecode_6763913321787039468/lib/build/asm-5.0.3.jar:/tmp/moe_git_clone_googlecode_6763913321787039468/lib/build/bnd-0.0.384.jar:/tmp/moe_git_clone_googlecode_6763913321787039468/lib/build/cglib-3.2.jar:/tmp/moe_git_clone_googlecode_6763913321787039468/lib/build/commons-logging-1.0.4.jar:/tmp/moe_git_clone_googlecode_6763913321787039468/lib/build/easymock.jar:/tmp/moe_git_clone_googlecode_6763913321787039468/lib/build/felix-2.0.5.jar:/tmp/moe_git_clone_googlecode_6763913321787039468/lib/build/guava-testlib-19.0.jar:/tmp/moe_git_clone_googlecode_6763913321787039468/lib/build/jarjar-1.1.jar:/tmp/moe_git_clone_googlecode_6763913321787039468/lib/build/javax.inject-tck.jar:/tmp/moe_git_clone_googlecode_6763913321787039468/lib/build/jsr305.jar:/tmp/moe_git_clone_googlecode_6763913321787039468/lib/build/junit.jar:/tmp/moe_git_clone_googlecode_6763913321787039468/lib/build/munge.jar:/tmp/moe_git_clone_googlecode_6763913321787039468/lib/build/safesax.jar:/tmp/moe_git_clone_googlecode_6763913321787039468/lib/build/spring-beans.jar:/tmp/moe_git_clone_googlecode_6763913321787039468/lib/build/spring-core.jar:/tmp/moe_git_clone_googlecode_6763913321787039468/extensions/dagger-adapter/lib/dagger-2.4.jar:/tmp/moe_git_clone_googlecode_6763913321787039468/extensions/persist/lib/antlr-2.7.5h3.jar:/tmp/moe_git_clone_googlecode_6763913321787039468/extensions/persist/lib/aopalliance.jar:/tmp/moe_git_clone_googlecode_6763913321787039468/extensions/persist/lib/cglib-nodep-3.0.jar:/tmp/moe_git_clone_googlecode_6763913321787039468/extensions/persist/lib/commons-collections.jar:/tmp/moe_git_clone_googlecode_6763913321787039468/extensions/persist/lib/commons-io.jar:/tmp/moe_git_clone_googlecode_6763913321787039468/extensions/persist/lib/commons-logging-1.0.4.jar:/tmp/moe_git_clone_googlecode_6763913321787039468/extensions/persist/lib/db4o-6.4.14.8131-java5.jar:/tmp/moe_git_clone_googlecode_6763913321787039468/extensions/persist/lib/dom4j-1.6.1.jar:/tmp/moe_git_clone_googlecode_6763913321787039468/extensions/persist/lib/easymock.jar:/tmp/moe_git_clone_googlecode_6763913321787039468/extensions/persist/lib/ejb3-persistence.jar:/tmp/moe_git_clone_googlecode_6763913321787039468/extensions/persist/lib/hibernate-annotations.jar:/tmp/moe_git_clone_googlecode_6763913321787039468/extensions/persist/lib/hibernate-entitymanager.jar:/tmp/moe_git_clone_googlecode_6763913321787039468/extensions/persist/lib/hibernate-search.jar:/tmp/moe_git_clone_googlecode_6763913321787039468/extensions/persist/lib/hibernate3.jar:/tmp/moe_git_clone_googlecode_6763913321787039468/extensions/persist/lib/hsqldb.jar:/tmp/moe_git_clone_googlecode_6763913321787039468/extensions/persist/lib/javassist.jar:/tmp/moe_git_clone_googlecode_6763913321787039468/extensions/persist/lib/jaxen-1.1-beta-7.jar:/tmp/moe_git_clone_googlecode_6763913321787039468/extensions/persist/lib/jboss-archive-browsing.jar:/tmp/moe_git_clone_googlecode_6763913321787039468/extensions/persist/lib/jta.jar:/tmp/moe_git_clone_googlecode_6763913321787039468/extensions/persist/lib/log4j-1.2.14.jar:/tmp/moe_git_clone_googlecode_6763913321787039468/extensions/persist/lib/ognl-2.6.7.jar:/tmp/moe_git_clone_googlecode_6763913321787039468/extensions/persist/lib/oro-2.0.8.jar:/tmp/moe_git_clone_googlecode_6763913321787039468/extensions/persist/lib/servlet-api-2.5.jar:/tmp/moe_git_clone_googlecode_6763913321787039468/extensions/persist/lib/xwork-2.0.4.jar:/tmp/moe_git_clone_googlecode_6763913321787039468/extensions/struts2/lib/ant-1.6.5.jar:/tmp/moe_git_clone_googlecode_6763913321787039468/extensions/struts2/lib/commons-fileupload-1.2.1.jar:/tmp/moe_git_clone_googlecode_6763913321787039468/extensions/struts2/lib/commons-io-1.3.2.jar:/tmp/moe_git_clone_googlecode_6763913321787039468/extensions/struts2/lib/commons-logging-1.0.4.jar:/tmp/moe_git_clone_googlecode_6763913321787039468/extensions/struts2/lib/core-3.1.1.jar:/tmp/moe_git_clone_googlecode_6763913321787039468/extensions/struts2/lib/freemarker-2.3.16.jar:/tmp/moe_git_clone_googlecode_6763913321787039468/extensions/struts2/lib/javassist.jar:/tmp/moe_git_clone_googlecode_6763913321787039468/extensions/struts2/lib/jetty-6.1.0.jar:/tmp/moe_git_clone_googlecode_6763913321787039468/extensions/struts2/lib/jetty-util-6.1.0.jar:/tmp/moe_git_clone_googlecode_6763913321787039468/extensions/struts2/lib/jsp-2.1.jar:/tmp/moe_git_clone_googlecode_6763913321787039468/extensions/struts2/lib/jsp-api-2.1.jar:/tmp/moe_git_clone_googlecode_6763913321787039468/extensions/struts2/lib/ognl-3.0.jar:/tmp/moe_git_clone_googlecode_6763913321787039468/extensions/struts2/lib/servlet-api-2.5.jar:/tmp/moe_git_clone_googlecode_6763913321787039468/extensions/struts2/lib/struts2-core-2.2.1.jar:/tmp/moe_git_clone_googlecode_6763913321787039468/extensions/struts2/lib/xwork-core-2.2.1.jar:/tmp/moe_git_clone_googlecode_6763913321787039468/build/classes -doclet jdiff.JDiff -docletpath /tmp/moe_git_clone_googlecode_6763913321787039468/lib/build/jdiff/jdiff.jar:/tmp/moe_git_clone_googlecode_6763913321787039468/lib/build/jdiff/xerces.jar -apidir build/docs/latest-api-diffs -apiname 4.1 -->
<package name="com.google.inject">
  <!-- start class com.google.inject.AbstractModule -->
  <class name="AbstractModule" extends="java.lang.Object"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.inject.Module"/>
    <constructor name="AbstractModule"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="configure"
      abstract="false" native="false" synchronized="true"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="builder" type="com.google.inject.Binder"/>
    </method>
    <method name="configure"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Configures a {@link Binder} via the exposed methods.]]>
      </doc>
    </method>
    <method name="binder" return="com.google.inject.Binder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets direct access to the underlying {@code Binder}.]]>
      </doc>
    </method>
    <method name="bindScope"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="scopeAnnotation" type="java.lang.Class&lt;? extends java.lang.annotation.Annotation&gt;"/>
      <param name="scope" type="com.google.inject.Scope"/>
      <doc>
      <![CDATA[@see Binder#bindScope(Class, Scope)]]>
      </doc>
    </method>
    <method name="bind" return="com.google.inject.binder.LinkedBindingBuilder&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="key" type="com.google.inject.Key&lt;T&gt;"/>
      <doc>
      <![CDATA[@see Binder#bind(Key)]]>
      </doc>
    </method>
    <method name="bind" return="com.google.inject.binder.AnnotatedBindingBuilder&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="typeLiteral" type="com.google.inject.TypeLiteral&lt;T&gt;"/>
      <doc>
      <![CDATA[@see Binder#bind(TypeLiteral)]]>
      </doc>
    </method>
    <method name="bind" return="com.google.inject.binder.AnnotatedBindingBuilder&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="clazz" type="java.lang.Class&lt;T&gt;"/>
      <doc>
      <![CDATA[@see Binder#bind(Class)]]>
      </doc>
    </method>
    <method name="bindConstant" return="com.google.inject.binder.AnnotatedConstantBindingBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@see Binder#bindConstant()]]>
      </doc>
    </method>
    <method name="install"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="module" type="com.google.inject.Module"/>
      <doc>
      <![CDATA[@see Binder#install(Module)]]>
      </doc>
    </method>
    <method name="addError"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="message" type="java.lang.String"/>
      <param name="arguments" type="java.lang.Object[]"/>
      <doc>
      <![CDATA[@see Binder#addError(String, Object[])]]>
      </doc>
    </method>
    <method name="addError"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="t" type="java.lang.Throwable"/>
      <doc>
      <![CDATA[@see Binder#addError(Throwable)]]>
      </doc>
    </method>
    <method name="addError"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="message" type="com.google.inject.spi.Message"/>
      <doc>
      <![CDATA[@see Binder#addError(Message)
 @since 2.0]]>
      </doc>
    </method>
    <method name="requestInjection"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="instance" type="java.lang.Object"/>
      <doc>
      <![CDATA[@see Binder#requestInjection(Object)
 @since 2.0]]>
      </doc>
    </method>
    <method name="requestStaticInjection"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="types" type="java.lang.Class[]"/>
      <doc>
      <![CDATA[@see Binder#requestStaticInjection(Class[])]]>
      </doc>
    </method>
    <method name="bindInterceptor"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="classMatcher" type="com.google.inject.matcher.Matcher&lt;? super java.lang.Class&lt;?&gt;&gt;"/>
      <param name="methodMatcher" type="com.google.inject.matcher.Matcher&lt;? super java.lang.reflect.Method&gt;"/>
      <param name="interceptors" type="org.aopalliance.intercept.MethodInterceptor[]"/>
      <doc>
      <![CDATA[@see Binder#bindInterceptor(com.google.inject.matcher.Matcher,
  com.google.inject.matcher.Matcher,
  org.aopalliance.intercept.MethodInterceptor[])]]>
      </doc>
    </method>
    <method name="requireBinding"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="key" type="com.google.inject.Key&lt;?&gt;"/>
      <doc>
      <![CDATA[Adds a dependency from this module to {@code key}. When the injector is
 created, Guice will report an error if {@code key} cannot be injected.
 Note that this requirement may be satisfied by implicit binding, such as
 a public no-arguments constructor.

 @since 2.0]]>
      </doc>
    </method>
    <method name="requireBinding"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="type" type="java.lang.Class&lt;?&gt;"/>
      <doc>
      <![CDATA[Adds a dependency from this module to {@code type}. When the injector is
 created, Guice will report an error if {@code type} cannot be injected.
 Note that this requirement may be satisfied by implicit binding, such as
 a public no-arguments constructor.

 @since 2.0]]>
      </doc>
    </method>
    <method name="getProvider" return="com.google.inject.Provider&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="key" type="com.google.inject.Key&lt;T&gt;"/>
      <doc>
      <![CDATA[@see Binder#getProvider(Key)
 @since 2.0]]>
      </doc>
    </method>
    <method name="getProvider" return="com.google.inject.Provider&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="type" type="java.lang.Class&lt;T&gt;"/>
      <doc>
      <![CDATA[@see Binder#getProvider(Class)
 @since 2.0]]>
      </doc>
    </method>
    <method name="convertToTypes"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="typeMatcher" type="com.google.inject.matcher.Matcher&lt;? super com.google.inject.TypeLiteral&lt;?&gt;&gt;"/>
      <param name="converter" type="com.google.inject.spi.TypeConverter"/>
      <doc>
      <![CDATA[@see Binder#convertToTypes
 @since 2.0]]>
      </doc>
    </method>
    <method name="currentStage" return="com.google.inject.Stage"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@see Binder#currentStage() 
 @since 2.0]]>
      </doc>
    </method>
    <method name="getMembersInjector" return="com.google.inject.MembersInjector&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="type" type="java.lang.Class&lt;T&gt;"/>
      <doc>
      <![CDATA[@see Binder#getMembersInjector(Class)
 @since 2.0]]>
      </doc>
    </method>
    <method name="getMembersInjector" return="com.google.inject.MembersInjector&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="type" type="com.google.inject.TypeLiteral&lt;T&gt;"/>
      <doc>
      <![CDATA[@see Binder#getMembersInjector(TypeLiteral)
 @since 2.0]]>
      </doc>
    </method>
    <method name="bindListener"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="typeMatcher" type="com.google.inject.matcher.Matcher&lt;? super com.google.inject.TypeLiteral&lt;?&gt;&gt;"/>
      <param name="listener" type="com.google.inject.spi.TypeListener"/>
      <doc>
      <![CDATA[@see Binder#bindListener(com.google.inject.matcher.Matcher,
  com.google.inject.spi.TypeListener)
 @since 2.0]]>
      </doc>
    </method>
    <method name="bindListener"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="bindingMatcher" type="com.google.inject.matcher.Matcher&lt;? super com.google.inject.Binding&lt;?&gt;&gt;"/>
      <param name="listener" type="com.google.inject.spi.ProvisionListener[]"/>
      <doc>
      <![CDATA[@see Binder#bindListener(Matcher, ProvisionListener...)
 @since 4.0]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A support class for {@link Module}s which reduces repetition and results in
 a more readable configuration. Simply extend this class, implement {@link
 #configure()}, and call the inherited methods which mirror those found in
 {@link Binder}. For example:

 <pre>
 public class MyModule extends AbstractModule {
   protected void configure() {
     bind(Service.class).to(ServiceImpl.class).in(Singleton.class);
     bind(CreditCardPaymentService.class);
     bind(PaymentService.class).to(CreditCardPaymentService.class);
     bindConstant().annotatedWith(Names.named("port")).to(8080);
   }
 }
 </pre>

 @author crazybob@google.com (Bob Lee)]]>
    </doc>
  </class>
  <!-- end class com.google.inject.AbstractModule -->
  <!-- start interface com.google.inject.Binder -->
  <interface name="Binder"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="bindInterceptor"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="classMatcher" type="com.google.inject.matcher.Matcher&lt;? super java.lang.Class&lt;?&gt;&gt;"/>
      <param name="methodMatcher" type="com.google.inject.matcher.Matcher&lt;? super java.lang.reflect.Method&gt;"/>
      <param name="interceptors" type="org.aopalliance.intercept.MethodInterceptor[]"/>
      <doc>
      <![CDATA[Binds method interceptor[s] to methods matched by class and method matchers. A method is
 eligible for interception if:

 <ul>
  <li>Guice created the instance the method is on</li>
  <li>Neither the enclosing type nor the method is final</li>
  <li>And the method is package-private, protected, or public</li>
 </ul>

 @param classMatcher matches classes the interceptor should apply to. For
     example: {@code only(Runnable.class)}.
 @param methodMatcher matches methods the interceptor should apply to. For
     example: {@code annotatedWith(Transactional.class)}.
 @param interceptors to bind.  The interceptors are called in the order they
     are given.]]>
      </doc>
    </method>
    <method name="bindScope"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="annotationType" type="java.lang.Class&lt;? extends java.lang.annotation.Annotation&gt;"/>
      <param name="scope" type="com.google.inject.Scope"/>
      <doc>
      <![CDATA[Binds a scope to an annotation.]]>
      </doc>
    </method>
    <method name="bind" return="com.google.inject.binder.LinkedBindingBuilder&lt;T&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="com.google.inject.Key&lt;T&gt;"/>
      <doc>
      <![CDATA[See the EDSL examples at {@link Binder}.]]>
      </doc>
    </method>
    <method name="bind" return="com.google.inject.binder.AnnotatedBindingBuilder&lt;T&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="typeLiteral" type="com.google.inject.TypeLiteral&lt;T&gt;"/>
      <doc>
      <![CDATA[See the EDSL examples at {@link Binder}.]]>
      </doc>
    </method>
    <method name="bind" return="com.google.inject.binder.AnnotatedBindingBuilder&lt;T&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="java.lang.Class&lt;T&gt;"/>
      <doc>
      <![CDATA[See the EDSL examples at {@link Binder}.]]>
      </doc>
    </method>
    <method name="bindConstant" return="com.google.inject.binder.AnnotatedConstantBindingBuilder"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[See the EDSL examples at {@link Binder}.]]>
      </doc>
    </method>
    <method name="requestInjection"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="com.google.inject.TypeLiteral&lt;T&gt;"/>
      <param name="instance" type="T"/>
      <doc>
      <![CDATA[Upon successful creation, the {@link Injector} will inject instance fields
 and methods of the given object.

 @param type of instance
 @param instance for which members will be injected
 @since 2.0]]>
      </doc>
    </method>
    <method name="requestInjection"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="instance" type="java.lang.Object"/>
      <doc>
      <![CDATA[Upon successful creation, the {@link Injector} will inject instance fields
 and methods of the given object.

 @param instance for which members will be injected
 @since 2.0]]>
      </doc>
    </method>
    <method name="requestStaticInjection"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="types" type="java.lang.Class[]"/>
      <doc>
      <![CDATA[Upon successful creation, the {@link Injector} will inject static fields
 and methods in the given classes.

 @param types for which static members will be injected]]>
      </doc>
    </method>
    <method name="install"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="module" type="com.google.inject.Module"/>
      <doc>
      <![CDATA[Uses the given module to configure more bindings.]]>
      </doc>
    </method>
    <method name="currentStage" return="com.google.inject.Stage"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the current stage.]]>
      </doc>
    </method>
    <method name="addError"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="message" type="java.lang.String"/>
      <param name="arguments" type="java.lang.Object[]"/>
      <doc>
      <![CDATA[Records an error message which will be presented to the user at a later
 time. Unlike throwing an exception, this enable us to continue
 configuring the Injector and discover more errors. Uses {@link
 String#format(String, Object[])} to insert the arguments into the
 message.]]>
      </doc>
    </method>
    <method name="addError"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="t" type="java.lang.Throwable"/>
      <doc>
      <![CDATA[Records an exception, the full details of which will be logged, and the
 message of which will be presented to the user at a later
 time. If your Module calls something that you worry may fail, you should
 catch the exception and pass it into this.]]>
      </doc>
    </method>
    <method name="addError"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="message" type="com.google.inject.spi.Message"/>
      <doc>
      <![CDATA[Records an error message to be presented to the user at a later time.

 @since 2.0]]>
      </doc>
    </method>
    <method name="getProvider" return="com.google.inject.Provider&lt;T&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="com.google.inject.Key&lt;T&gt;"/>
      <doc>
      <![CDATA[Returns the provider used to obtain instances for the given injection key.
 The returned provider will not be valid until the {@link Injector} has been
 created. The provider will throw an {@code IllegalStateException} if you
 try to use it beforehand.

 @since 2.0]]>
      </doc>
    </method>
    <method name="getProvider" return="com.google.inject.Provider&lt;T&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="dependency" type="com.google.inject.spi.Dependency&lt;T&gt;"/>
      <doc>
      <![CDATA[Returns the provider used to obtain instances for the given injection key.
 The returned provider will be attached to the injection point and will
 follow the nullability specified in the dependency.
 Additionally, the returned provider will not be valid until the {@link Injector} 
 has been created. The provider will throw an {@code IllegalStateException} if you
 try to use it beforehand.

 @since 4.0]]>
      </doc>
    </method>
    <method name="getProvider" return="com.google.inject.Provider&lt;T&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="java.lang.Class&lt;T&gt;"/>
      <doc>
      <![CDATA[Returns the provider used to obtain instances for the given injection type.
 The returned provider will not be valid until the {@link Injector} has been
 created. The provider will throw an {@code IllegalStateException} if you
 try to use it beforehand.

 @since 2.0]]>
      </doc>
    </method>
    <method name="getMembersInjector" return="com.google.inject.MembersInjector&lt;T&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="typeLiteral" type="com.google.inject.TypeLiteral&lt;T&gt;"/>
      <doc>
      <![CDATA[Returns the members injector used to inject dependencies into methods and fields on instances
 of the given type {@code T}. The returned members injector will not be valid until the main
 {@link Injector} has been created. The members injector will throw an {@code
 IllegalStateException} if you try to use it beforehand.

 @param typeLiteral type to get members injector for
 @since 2.0]]>
      </doc>
    </method>
    <method name="getMembersInjector" return="com.google.inject.MembersInjector&lt;T&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="java.lang.Class&lt;T&gt;"/>
      <doc>
      <![CDATA[Returns the members injector used to inject dependencies into methods and fields on instances
 of the given type {@code T}. The returned members injector will not be valid until the main
 {@link Injector} has been created. The members injector will throw an {@code
 IllegalStateException} if you try to use it beforehand.

 @param type type to get members injector for
 @since 2.0]]>
      </doc>
    </method>
    <method name="convertToTypes"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="typeMatcher" type="com.google.inject.matcher.Matcher&lt;? super com.google.inject.TypeLiteral&lt;?&gt;&gt;"/>
      <param name="converter" type="com.google.inject.spi.TypeConverter"/>
      <doc>
      <![CDATA[Binds a type converter. The injector will use the given converter to
 convert string constants to matching types as needed.

 @param typeMatcher matches types the converter can handle
 @param converter converts values
 @since 2.0]]>
      </doc>
    </method>
    <method name="bindListener"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="typeMatcher" type="com.google.inject.matcher.Matcher&lt;? super com.google.inject.TypeLiteral&lt;?&gt;&gt;"/>
      <param name="listener" type="com.google.inject.spi.TypeListener"/>
      <doc>
      <![CDATA[Registers a listener for injectable types. Guice will notify the listener when it encounters
 injectable types matched by the given type matcher.

 @param typeMatcher that matches injectable types the listener should be notified of
 @param listener for injectable types matched by typeMatcher
 @since 2.0]]>
      </doc>
    </method>
    <method name="bindListener"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="bindingMatcher" type="com.google.inject.matcher.Matcher&lt;? super com.google.inject.Binding&lt;?&gt;&gt;"/>
      <param name="listeners" type="com.google.inject.spi.ProvisionListener[]"/>
      <doc>
      <![CDATA[Registers listeners for provisioned objects. Guice will notify the
 listeners just before and after the object is provisioned. Provisioned
 objects that are also injectable (everything except objects provided
 through Providers) can also be notified through TypeListeners registered in
 {@link #bindListener}.
 
 @param bindingMatcher that matches bindings of provisioned objects the listener
          should be notified of
 @param listeners for provisioned objects matched by bindingMatcher 
 @since 4.0]]>
      </doc>
    </method>
    <method name="withSource" return="com.google.inject.Binder"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="source" type="java.lang.Object"/>
      <doc>
      <![CDATA[Returns a binder that uses {@code source} as the reference location for
 configuration errors. This is typically a {@link StackTraceElement}
 for {@code .java} source but it could any binding source, such as the
 path to a {@code .properties} file.

 @param source any object representing the source location and has a
     concise {@link Object#toString() toString()} value
 @return a binder that shares its configuration with this binder
 @since 2.0]]>
      </doc>
    </method>
    <method name="skipSources" return="com.google.inject.Binder"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="classesToSkip" type="java.lang.Class[]"/>
      <doc>
      <![CDATA[Returns a binder that skips {@code classesToSkip} when identify the
 calling code. The caller's {@link StackTraceElement} is used to locate
 the source of configuration errors.

 @param classesToSkip library classes that create bindings on behalf of
      their clients.
 @return a binder that shares its configuration with this binder.
 @since 2.0]]>
      </doc>
    </method>
    <method name="newPrivateBinder" return="com.google.inject.PrivateBinder"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a new private child environment for bindings and other configuration. The returned
 binder can be used to add and configuration information in this environment. See {@link
 PrivateModule} for details.

 @return a binder that inherits configuration from this binder. Only exposed configuration on
      the returned binder will be visible to this binder.
 @since 2.0]]>
      </doc>
    </method>
    <method name="requireExplicitBindings"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Instructs the Injector that bindings must be listed in a Module in order to
 be injected. Classes that are not explicitly bound in a module cannot be
 injected. Bindings created through a linked binding
 (<code>bind(Foo.class).to(FooImpl.class)</code>) are allowed, but the
 implicit binding (<code>FooImpl</code>) cannot be directly injected unless
 it is also explicitly bound (<code>bind(FooImpl.class)</code>).
 <p>
 Tools can still retrieve bindings for implicit bindings (bindings created
 through a linked binding) if explicit bindings are required, however
 {@link Binding#getProvider} will fail.
 <p>
 By default, explicit bindings are not required.
 <p>
 If a parent injector requires explicit bindings, then all child injectors
 (and private modules within that injector) also require explicit bindings.
 If a parent does not require explicit bindings, a child injector or private
 module may optionally declare itself as requiring explicit bindings. If it
 does, the behavior is limited only to that child or any grandchildren. No
 siblings of the child will require explicit bindings.
 <p>
 In the absence of an explicit binding for the target, linked bindings in
 child injectors create a binding for the target in the parent. Since this
 behavior can be surprising, it causes an error instead if explicit bindings
 are required. To avoid this error, add an explicit binding for the target,
 either in the child or the parent.
 
 @since 3.0]]>
      </doc>
    </method>
    <method name="disableCircularProxies"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Prevents Guice from injecting dependencies that form a cycle, unless broken by a
 {@link Provider}. By default, circular dependencies are not disabled.
 <p>
 If a parent injector disables circular dependencies, then all child injectors (and private
 modules within that injector) also disable circular dependencies. If a parent does not disable
 circular dependencies, a child injector or private module may optionally declare itself as
 disabling circular dependencies. If it does, the behavior is limited only to that child or any
 grandchildren. No siblings of the child will disable circular dependencies.

 @since 3.0]]>
      </doc>
    </method>
    <method name="requireAtInjectOnConstructors"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Requires that a {@literal @}{@link Inject} annotation exists on a constructor in order for
 Guice to consider it an eligible injectable class. By default, Guice will inject classes that
 have a no-args constructor if no {@literal @}{@link Inject} annotation exists on any
 constructor.
 <p>
 If the class is bound using {@link LinkedBindingBuilder#toConstructor}, Guice will still inject
 that constructor regardless of annotations.

 @since 4.0]]>
      </doc>
    </method>
    <method name="requireExactBindingAnnotations"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Requires that Guice finds an exactly matching binding annotation.  This disables the
 error-prone feature in Guice where it can substitute a binding for
 <code>{@literal @}Named Foo</code> when attempting to inject
 <code>{@literal @}Named("foo") Foo</code>.

 @since 4.0]]>
      </doc>
    </method>
    <method name="scanModulesForAnnotatedMethods"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="scanner" type="com.google.inject.spi.ModuleAnnotatedMethodScanner"/>
      <doc>
      <![CDATA[Adds a scanner that will look in all installed modules for annotations the scanner can parse,
 and binds them like {@literal @}Provides methods. Scanners apply to all modules installed in
 the injector. Scanners installed in child injectors or private modules do not impact modules in
 siblings or parents, however scanners installed in parents do apply to all child injectors and
 private modules.

 @since 4.0]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Collects configuration information (primarily <i>bindings</i>) which will be
 used to create an {@link Injector}. Guice provides this object to your
 application's {@link Module} implementors so they may each contribute
 their own bindings and other registrations.

 <h3>The Guice Binding EDSL</h3>

 Guice uses an <i>embedded domain-specific language</i>, or EDSL, to help you
 create bindings simply and readably.  This approach is great for overall
 usability, but it does come with a small cost: <b>it is difficult to
 learn how to use the Binding EDSL by reading
 method-level javadocs</b>.  Instead, you should consult the series of
 examples below.  To save space, these examples omit the opening
 {@code binder}, just as you will if your module extends
 {@link AbstractModule}.

 <pre>
     bind(ServiceImpl.class);</pre>

 This statement does essentially nothing; it "binds the {@code ServiceImpl}
 class to itself" and does not change Guice's default behavior.  You may still
 want to use this if you prefer your {@link Module} class to serve as an
 explicit <i>manifest</i> for the services it provides.  Also, in rare cases,
 Guice may be unable to validate a binding at injector creation time unless it
 is given explicitly.

 <pre>
     bind(Service.class).to(ServiceImpl.class);</pre>

 Specifies that a request for a {@code Service} instance with no binding
 annotations should be treated as if it were a request for a
 {@code ServiceImpl} instance. This <i>overrides</i> the function of any
 {@link ImplementedBy @ImplementedBy} or {@link ProvidedBy @ProvidedBy}
 annotations found on {@code Service}, since Guice will have already
 "moved on" to {@code ServiceImpl} before it reaches the point when it starts
 looking for these annotations.

 <pre>
     bind(Service.class).toProvider(ServiceProvider.class);</pre>

 In this example, {@code ServiceProvider} must extend or implement
 {@code Provider<Service>}. This binding specifies that Guice should resolve
 an unannotated injection request for {@code Service} by first resolving an
 instance of {@code ServiceProvider} in the regular way, then calling
 {@link Provider#get get()} on the resulting Provider instance to obtain the
 {@code Service} instance.

 <p>The {@link Provider} you use here does not have to be a "factory"; that
 is, a provider which always <i>creates</i> each instance it provides.
 However, this is generally a good practice to follow.  You can then use
 Guice's concept of {@link Scope scopes} to guide when creation should happen
 -- "letting Guice work for you".

 <pre>
     bind(Service.class).annotatedWith(Red.class).to(ServiceImpl.class);</pre>

 Like the previous example, but only applies to injection requests that use
 the binding annotation {@code @Red}.  If your module also includes bindings
 for particular <i>values</i> of the {@code @Red} annotation (see below),
 then this binding will serve as a "catch-all" for any values of {@code @Red}
 that have no exact match in the bindings.
 
 <pre>
     bind(ServiceImpl.class).in(Singleton.class);
     // or, alternatively
     bind(ServiceImpl.class).in(Scopes.SINGLETON);</pre>

 Either of these statements places the {@code ServiceImpl} class into
 singleton scope.  Guice will create only one instance of {@code ServiceImpl}
 and will reuse it for all injection requests of this type.  Note that it is
 still possible to bind another instance of {@code ServiceImpl} if the second
 binding is qualified by an annotation as in the previous example.  Guice is
 not overly concerned with <i>preventing</i> you from creating multiple
 instances of your "singletons", only with <i>enabling</i> your application to
 share only one instance if that's all you tell Guice you need.

 <p><b>Note:</b> a scope specified in this way <i>overrides</i> any scope that
 was specified with an annotation on the {@code ServiceImpl} class.
 
 <p>Besides {@link Singleton}/{@link Scopes#SINGLETON}, there are
 servlet-specific scopes available in
 {@code com.google.inject.servlet.ServletScopes}, and your Modules can
 contribute their own custom scopes for use here as well.

 <pre>
     bind(new TypeLiteral&lt;PaymentService&lt;CreditCard>>() {})
         .to(CreditCardPaymentService.class);</pre>

 This admittedly odd construct is the way to bind a parameterized type. It
 tells Guice how to honor an injection request for an element of type
 {@code PaymentService<CreditCard>}. The class
 {@code CreditCardPaymentService} must implement the
 {@code PaymentService<CreditCard>} interface.  Guice cannot currently bind or
 inject a generic type, such as {@code Set<E>}; all type parameters must be
 fully specified.

 <pre>
     bind(Service.class).toInstance(new ServiceImpl());
     // or, alternatively
     bind(Service.class).toInstance(SomeLegacyRegistry.getService());</pre>

 In this example, your module itself, <i>not Guice</i>, takes responsibility
 for obtaining a {@code ServiceImpl} instance, then asks Guice to always use
 this single instance to fulfill all {@code Service} injection requests.  When
 the {@link Injector} is created, it will automatically perform field
 and method injection for this instance, but any injectable constructor on
 {@code ServiceImpl} is simply ignored.  Note that using this approach results
 in "eager loading" behavior that you can't control.

 <pre>
     bindConstant().annotatedWith(ServerHost.class).to(args[0]);</pre>

 Sets up a constant binding. Constant injections must always be annotated.
 When a constant binding's value is a string, it is eligile for conversion to
 all primitive types, to {@link Enum#valueOf(Class, String) all enums}, and to
 {@link Class#forName class literals}. Conversions for other types can be
 configured using {@link #convertToTypes(Matcher, TypeConverter)
 convertToTypes()}.

 <pre>
   {@literal @}Color("red") Color red; // A member variable (field)
    . . .
     red = MyModule.class.getDeclaredField("red").getAnnotation(Color.class);
     bind(Service.class).annotatedWith(red).to(RedService.class);</pre>

 If your binding annotation has parameters you can apply different bindings to
 different specific values of your annotation.  Getting your hands on the
 right instance of the annotation is a bit of a pain -- one approach, shown
 above, is to apply a prototype annotation to a field in your module class, so
 that you can read this annotation instance and give it to Guice.

 <pre>
     bind(Service.class)
         .annotatedWith(Names.named("blue"))
         .to(BlueService.class);</pre>

 Differentiating by names is a common enough use case that we provided a
 standard annotation, {@link com.google.inject.name.Named @Named}.  Because of
 Guice's library support, binding by name is quite easier than in the
 arbitrary binding annotation case we just saw.  However, remember that these
 names will live in a single flat namespace with all the other names used in
 your application.

 <pre>
     Constructor<T> loneCtor = getLoneCtorFromServiceImplViaReflection();
     bind(ServiceImpl.class)
         .toConstructor(loneCtor);</pre>

 In this example, we directly tell Guice which constructor to use in a concrete
 class implementation. It means that we do not need to place {@literal @}Inject
 on any of the constructors and that Guice treats the provided constructor as though
 it were annotated so. It is useful for cases where you cannot modify existing
 classes and is a bit simpler than using a {@link Provider}.

 <p>The above list of examples is far from exhaustive.  If you can think of
 how the concepts of one example might coexist with the concepts from another,
 you can most likely weave the two together.  If the two concepts make no
 sense with each other, you most likely won't be able to do it.  In a few
 cases Guice will let something bogus slip by, and will then inform you of
 the problems at runtime, as soon as you try to create your Injector.

 <p>The other methods of Binder such as {@link #bindScope},
 {@link #bindInterceptor}, {@link #install}, {@link #requestStaticInjection},
 {@link #addError} and {@link #currentStage} are not part of the Binding EDSL;
 you can learn how to use these in the usual way, from the method
 documentation.

 @author crazybob@google.com (Bob Lee)
 @author jessewilson@google.com (Jesse Wilson)
 @author kevinb@google.com (Kevin Bourrillion)]]>
    </doc>
  </interface>
  <!-- end interface com.google.inject.Binder -->
  <!-- start interface com.google.inject.Binding -->
  <interface name="Binding"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.inject.spi.Element"/>
    <method name="getKey" return="com.google.inject.Key&lt;T&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the key for this binding.]]>
      </doc>
    </method>
    <method name="getProvider" return="com.google.inject.Provider&lt;T&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the scoped provider guice uses to fulfill requests for this
 binding.

 @throws UnsupportedOperationException when invoked on a {@link Binding}
      created via {@link com.google.inject.spi.Elements#getElements}. This
      method is only supported on {@link Binding}s returned from an injector.]]>
      </doc>
    </method>
    <method name="acceptTargetVisitor" return="V"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="visitor" type="com.google.inject.spi.BindingTargetVisitor&lt;? super T, V&gt;"/>
      <doc>
      <![CDATA[Accepts a target visitor. Invokes the visitor method specific to this binding's target.

 @param visitor to call back on
 @since 2.0]]>
      </doc>
    </method>
    <method name="acceptScopingVisitor" return="V"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="visitor" type="com.google.inject.spi.BindingScopingVisitor&lt;V&gt;"/>
      <doc>
      <![CDATA[Accepts a scoping visitor. Invokes the visitor method specific to this binding's scoping.

 @param visitor to call back on
 @since 2.0]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A mapping from a key (type and optional annotation) to the strategy for getting instances of the
 type. This interface is part of the introspection API and is intended primarily for use by 
 tools.

 <p>Bindings are created in several ways:
 <ul>
     <li>Explicitly in a module, via {@code bind()} and {@code bindConstant()}
         statements:
 <pre>
     bind(Service.class).annotatedWith(Red.class).to(ServiceImpl.class);
     bindConstant().annotatedWith(ServerHost.class).to(args[0]);</pre></li>
     <li>Implicitly by the Injector by following a type's {@link ImplementedBy
         pointer} {@link ProvidedBy annotations} or by using its {@link Inject annotated} or
         default constructor.</li>
     <li>By converting a bound instance to a different type.</li>
     <li>For {@link Provider providers}, by delegating to the binding for the provided type.</li>
 </ul>


 <p>They exist on both modules and on injectors, and their behaviour is different for each:
 <ul>
     <li><strong>Module bindings</strong> are incomplete and cannot be used to provide instances.
         This is because the applicable scopes and interceptors may not be known until an injector
         is created. From a tool's perspective, module bindings are like the injector's source
         code. They can be inspected or rewritten, but this analysis must be done statically.</li>
     <li><strong>Injector bindings</strong> are complete and valid and can be used to provide
         instances. From a tools' perspective, injector bindings are like reflection for an
         injector. They have full runtime information, including the complete graph of injections
         necessary to satisfy a binding.</li>
 </ul>

 @param <T> the bound type. The injected is always assignable to this type.

 @author crazybob@google.com (Bob Lee)
 @author jessewilson@google.com (Jesse Wilson)]]>
    </doc>
  </interface>
  <!-- end interface com.google.inject.Binding -->
  <!-- start class com.google.inject.BindingAnnotation -->
  <class name="BindingAnnotation"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.lang.annotation.Annotation"/>
    <doc>
    <![CDATA[Annotates annotations which are used for binding. Only one such annotation
 may apply to a single injection point. You must also annotate binder
 annotations with {@code @Retention(RUNTIME)}. For example:

 <pre>
   {@code @}Retention(RUNTIME)
   {@code @}Target({ FIELD, PARAMETER, METHOD })
   {@code @}BindingAnnotation
   public {@code @}interface Transactional {}
 </pre>

 @author crazybob@google.com (Bob Lee)]]>
    </doc>
  </class>
  <!-- end class com.google.inject.BindingAnnotation -->
  <!-- start class com.google.inject.ConfigurationException -->
  <class name="ConfigurationException" extends="java.lang.RuntimeException"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="ConfigurationException" type="java.lang.Iterable&lt;com.google.inject.spi.Message&gt;"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a ConfigurationException containing {@code messages}.]]>
      </doc>
    </constructor>
    <method name="withPartialValue" return="com.google.inject.ConfigurationException"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="partialValue" type="java.lang.Object"/>
      <doc>
      <![CDATA[Returns a copy of this configuration exception with the specified partial value.]]>
      </doc>
    </method>
    <method name="getErrorMessages" return="java.util.Collection&lt;com.google.inject.spi.Message&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns messages for the errors that caused this exception.]]>
      </doc>
    </method>
    <method name="getPartialValue" return="E"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a value that was only partially computed due to this exception. The caller can use
 this while collecting additional configuration problems.

 @return the partial value, or {@code null} if none was set. The type of the partial value is
      specified by the throwing method.]]>
      </doc>
    </method>
    <method name="getMessage" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Thrown when a programming error such as a misplaced annotation, illegal binding, or unsupported
 scope is found. Clients should catch this exception, log it, and stop execution.

 @author jessewilson@google.com (Jesse Wilson)
 @since 2.0]]>
    </doc>
  </class>
  <!-- end class com.google.inject.ConfigurationException -->
  <!-- start class com.google.inject.CreationException -->
  <class name="CreationException" extends="java.lang.RuntimeException"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="CreationException" type="java.util.Collection&lt;com.google.inject.spi.Message&gt;"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a CreationException containing {@code messages}.]]>
      </doc>
    </constructor>
    <method name="getErrorMessages" return="java.util.Collection&lt;com.google.inject.spi.Message&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns messages for the errors that caused this exception.]]>
      </doc>
    </method>
    <method name="getMessage" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Thrown when errors occur while creating a {@link Injector}. Includes a list of encountered
 errors. Clients should catch this exception, log it, and stop execution.

 @author crazybob@google.com (Bob Lee)]]>
    </doc>
  </class>
  <!-- end class com.google.inject.CreationException -->
  <!-- start class com.google.inject.Exposed -->
  <class name="Exposed"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.lang.annotation.Annotation"/>
    <doc>
    <![CDATA[Acccompanies a {@literal @}{@link com.google.inject.Provides Provides} method annotation in a
 private module to indicate that the provided binding is exposed.

 @author jessewilson@google.com (Jesse Wilson)
 @since 2.0]]>
    </doc>
  </class>
  <!-- end class com.google.inject.Exposed -->
  <!-- start class com.google.inject.Guice -->
  <class name="Guice" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="createInjector" return="com.google.inject.Injector"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="modules" type="com.google.inject.Module[]"/>
      <doc>
      <![CDATA[Creates an injector for the given set of modules. This is equivalent to
 calling {@link #createInjector(Stage, Module...)} with Stage.DEVELOPMENT.

 @throws CreationException if one or more errors occur during injector
     construction]]>
      </doc>
    </method>
    <method name="createInjector" return="com.google.inject.Injector"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="modules" type="java.lang.Iterable&lt;? extends com.google.inject.Module&gt;"/>
      <doc>
      <![CDATA[Creates an injector for the given set of modules. This is equivalent to
 calling {@link #createInjector(Stage, Iterable)} with Stage.DEVELOPMENT.

 @throws CreationException if one or more errors occur during injector
     creation]]>
      </doc>
    </method>
    <method name="createInjector" return="com.google.inject.Injector"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="stage" type="com.google.inject.Stage"/>
      <param name="modules" type="com.google.inject.Module[]"/>
      <doc>
      <![CDATA[Creates an injector for the given set of modules, in a given development
 stage.

 @throws CreationException if one or more errors occur during injector
     creation.]]>
      </doc>
    </method>
    <method name="createInjector" return="com.google.inject.Injector"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="stage" type="com.google.inject.Stage"/>
      <param name="modules" type="java.lang.Iterable&lt;? extends com.google.inject.Module&gt;"/>
      <doc>
      <![CDATA[Creates an injector for the given set of modules, in a given development
 stage.

 @throws CreationException if one or more errors occur during injector
     construction]]>
      </doc>
    </method>
    <doc>
    <![CDATA[The entry point to the Guice framework. Creates {@link Injector}s from
 {@link Module}s.

 <p>Guice supports a model of development that draws clear boundaries between
 APIs, Implementations of these APIs, Modules which configure these
 implementations, and finally Applications which consist of a collection of
 Modules. It is the Application, which typically defines your {@code main()}
 method, that bootstraps the Guice Injector using the {@code Guice} class, as
 in this example:
 <pre>
     public class FooApplication {
       public static void main(String[] args) {
         Injector injector = Guice.createInjector(
             new ModuleA(),
             new ModuleB(),
             . . .
             new FooApplicationFlagsModule(args)
         );

         // Now just bootstrap the application and you're done
         FooStarter starter = injector.getInstance(FooStarter.class);
         starter.runApplication();
       }
     }
 </pre>]]>
    </doc>
  </class>
  <!-- end class com.google.inject.Guice -->
  <!-- start class com.google.inject.ImplementedBy -->
  <class name="ImplementedBy"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.lang.annotation.Annotation"/>
    <doc>
    <![CDATA[A pointer to the default implementation of a type.

 @author crazybob@google.com (Bob Lee)]]>
    </doc>
  </class>
  <!-- end class com.google.inject.ImplementedBy -->
  <!-- start class com.google.inject.Inject -->
  <class name="Inject"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.lang.annotation.Annotation"/>
    <doc>
    <![CDATA[Annotates members of your implementation class (constructors, methods
 and fields) into which the {@link Injector} should inject values.
 The Injector fulfills injection requests for:

 <ul>
 <li>Every instance it constructs. The class being constructed must have
 exactly one of its constructors marked with {@code @Inject} or must have a
 constructor taking no parameters. The Injector then proceeds to perform
 field and method injections.
 
 <li>Pre-constructed instances passed to {@link Injector#injectMembers},
 {@link com.google.inject.binder.LinkedBindingBuilder#toInstance(Object)} and
 {@link com.google.inject.binder.LinkedBindingBuilder#toProvider(javax.inject.Provider)}.
 In this case all constructors are, of course, ignored.

 <li>Static fields and methods of classes which any {@link Module} has
 specifically requested static injection for, using
 {@link Binder#requestStaticInjection}.
 </ul>

 In all cases, a member can be injected regardless of its Java access
 specifier (private, default, protected, public).

 @author crazybob@google.com (Bob Lee)]]>
    </doc>
  </class>
  <!-- end class com.google.inject.Inject -->
  <!-- start interface com.google.inject.Injector -->
  <interface name="Injector"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="injectMembers"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="instance" type="java.lang.Object"/>
      <doc>
      <![CDATA[Injects dependencies into the fields and methods of {@code instance}. Ignores the presence or
 absence of an injectable constructor.

 <p>Whenever Guice creates an instance, it performs this injection automatically (after first
 performing constructor injection), so if you're able to let Guice create all your objects for
 you, you'll never need to use this method.

 @param instance to inject members on

 @see Binder#getMembersInjector(Class) for a preferred alternative that supports checks before
  run time]]>
      </doc>
    </method>
    <method name="getMembersInjector" return="com.google.inject.MembersInjector&lt;T&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="typeLiteral" type="com.google.inject.TypeLiteral&lt;T&gt;"/>
      <doc>
      <![CDATA[Returns the members injector used to inject dependencies into methods and fields on instances
 of the given type {@code T}.

 @param typeLiteral type to get members injector for
 @see Binder#getMembersInjector(TypeLiteral) for an alternative that offers up front error
  detection
 @since 2.0]]>
      </doc>
    </method>
    <method name="getMembersInjector" return="com.google.inject.MembersInjector&lt;T&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="java.lang.Class&lt;T&gt;"/>
      <doc>
      <![CDATA[Returns the members injector used to inject dependencies into methods and fields on instances
 of the given type {@code T}. When feasible, use {@link Binder#getMembersInjector(TypeLiteral)}
 instead to get increased up front error detection.

 @param type type to get members injector for
 @see Binder#getMembersInjector(Class) for an alternative that offers up front error
  detection
 @since 2.0]]>
      </doc>
    </method>
    <method name="getBindings" return="java.util.Map&lt;com.google.inject.Key&lt;?&gt;, com.google.inject.Binding&lt;?&gt;&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns this injector's <strong>explicit</strong> bindings.

 <p>The returned map does not include bindings inherited from a {@link #getParent() parent
 injector}, should one exist. The returned map is guaranteed to iterate (for example, with
 its {@link Map#entrySet()} iterator) in the order of insertion. In other words, the order in
 which bindings appear in user Modules.

 <p>This method is part of the Guice SPI and is intended for use by tools and extensions.]]>
      </doc>
    </method>
    <method name="getAllBindings" return="java.util.Map&lt;com.google.inject.Key&lt;?&gt;, com.google.inject.Binding&lt;?&gt;&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a snapshot of this injector's bindings, <strong>both explicit and
 just-in-time</strong>. The returned map is immutable; it contains only the bindings that were
 present when {@code getAllBindings()} was invoked. Subsequent calls may return a map with
 additional just-in-time bindings.

 <p>The returned map does not include bindings inherited from a {@link #getParent() parent
 injector}, should one exist.

 <p>This method is part of the Guice SPI and is intended for use by tools and extensions.
 
 @since 3.0]]>
      </doc>
    </method>
    <method name="getBinding" return="com.google.inject.Binding&lt;T&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="com.google.inject.Key&lt;T&gt;"/>
      <doc>
      <![CDATA[Returns the binding for the given injection key. This will be an explicit bindings if the key
 was bound explicitly by a module, or an implicit binding otherwise. The implicit binding will
 be created if necessary.

 <p>This method is part of the Guice SPI and is intended for use by tools and extensions.

 @throws ConfigurationException if this injector cannot find or create the binding.]]>
      </doc>
    </method>
    <method name="getBinding" return="com.google.inject.Binding&lt;T&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="java.lang.Class&lt;T&gt;"/>
      <doc>
      <![CDATA[Returns the binding for the given type. This will be an explicit bindings if the injection key
 was bound explicitly by a module, or an implicit binding otherwise. The implicit binding will
 be created if necessary.

 <p>This method is part of the Guice SPI and is intended for use by tools and extensions.

 @throws ConfigurationException if this injector cannot find or create the binding.
 @since 2.0]]>
      </doc>
    </method>
    <method name="getExistingBinding" return="com.google.inject.Binding&lt;T&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="com.google.inject.Key&lt;T&gt;"/>
      <doc>
      <![CDATA[Returns the binding if it already exists, or null if does not exist. Unlike
 {@link #getBinding(Key)}, this does not attempt to create just-in-time bindings
 for keys that aren't bound.
 
 <p> This method is part of the Guice SPI and is intended for use by tools and extensions.
 
 @since 3.0]]>
      </doc>
    </method>
    <method name="findBindingsByType" return="java.util.List&lt;com.google.inject.Binding&lt;T&gt;&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="com.google.inject.TypeLiteral&lt;T&gt;"/>
      <doc>
      <![CDATA[Returns all explicit bindings for {@code type}.

 <p>This method is part of the Guice SPI and is intended for use by tools and extensions.]]>
      </doc>
    </method>
    <method name="getProvider" return="com.google.inject.Provider&lt;T&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="com.google.inject.Key&lt;T&gt;"/>
      <doc>
      <![CDATA[Returns the provider used to obtain instances for the given injection key. When feasible, avoid
 using this method, in favor of having Guice inject your dependencies ahead of time.

 @throws ConfigurationException if this injector cannot find or create the provider.
 @see Binder#getProvider(Key) for an alternative that offers up front error detection]]>
      </doc>
    </method>
    <method name="getProvider" return="com.google.inject.Provider&lt;T&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="java.lang.Class&lt;T&gt;"/>
      <doc>
      <![CDATA[Returns the provider used to obtain instances for the given type. When feasible, avoid
 using this method, in favor of having Guice inject your dependencies ahead of time.

 @throws ConfigurationException if this injector cannot find or create the provider.
 @see Binder#getProvider(Class) for an alternative that offers up front error detection]]>
      </doc>
    </method>
    <method name="getInstance" return="T"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="com.google.inject.Key&lt;T&gt;"/>
      <doc>
      <![CDATA[Returns the appropriate instance for the given injection key; equivalent to {@code
 getProvider(key).get()}. When feasible, avoid using this method, in favor of having Guice
 inject your dependencies ahead of time.

 @throws ConfigurationException if this injector cannot find or create the provider.
 @throws ProvisionException if there was a runtime failure while providing an instance.]]>
      </doc>
    </method>
    <method name="getInstance" return="T"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="java.lang.Class&lt;T&gt;"/>
      <doc>
      <![CDATA[Returns the appropriate instance for the given injection type; equivalent to {@code
 getProvider(type).get()}. When feasible, avoid using this method, in favor of having Guice
 inject your dependencies ahead of time.

 @throws ConfigurationException if this injector cannot find or create the provider.
 @throws ProvisionException if there was a runtime failure while providing an instance.]]>
      </doc>
    </method>
    <method name="getParent" return="com.google.inject.Injector"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns this injector's parent, or {@code null} if this is a top-level injector.

 @since 2.0]]>
      </doc>
    </method>
    <method name="createChildInjector" return="com.google.inject.Injector"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="modules" type="java.lang.Iterable&lt;? extends com.google.inject.Module&gt;"/>
      <doc>
      <![CDATA[Returns a new injector that inherits all state from this injector. All bindings, scopes,
 interceptors and type converters are inherited -- they are visible to the child injector.
 Elements of the child injector are not visible to its parent.

 <p>Just-in-time bindings created for child injectors will be created in an ancestor injector
 whenever possible. This allows for scoped instances to be shared between injectors. Use
 explicit bindings to prevent bindings from being shared with the parent injector.  Optional
 injections in just-in-time bindings (created in the parent injector) may be silently
 ignored if the optional dependencies are from the child injector.

 <p>No key may be bound by both an injector and one of its ancestors. This includes just-in-time
 bindings. The lone exception is the key for {@code Injector.class}, which is bound by each
 injector to itself.

 @since 2.0]]>
      </doc>
    </method>
    <method name="createChildInjector" return="com.google.inject.Injector"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="modules" type="com.google.inject.Module[]"/>
      <doc>
      <![CDATA[Returns a new injector that inherits all state from this injector. All bindings, scopes,
 interceptors and type converters are inherited -- they are visible to the child injector.
 Elements of the child injector are not visible to its parent.

 <p>Just-in-time bindings created for child injectors will be created in an ancestor injector
 whenever possible. This allows for scoped instances to be shared between injectors. Use
 explicit bindings to prevent bindings from being shared with the parent injector.

 <p>No key may be bound by both an injector and one of its ancestors. This includes just-in-time
 bindings. The lone exception is the key for {@code Injector.class}, which is bound by each
 injector to itself.

 @since 2.0]]>
      </doc>
    </method>
    <method name="getScopeBindings" return="java.util.Map&lt;java.lang.Class&lt;? extends java.lang.annotation.Annotation&gt;, com.google.inject.Scope&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a map containing all scopes in the injector. The maps keys are scoping annotations
 like {@code Singleton.class}, and the values are scope instances, such as {@code
 Scopes.SINGLETON}. The returned map is immutable.

 <p>This method is part of the Guice SPI and is intended for use by tools and extensions.
 
 @since 3.0]]>
      </doc>
    </method>
    <method name="getTypeConverterBindings" return="java.util.Set&lt;com.google.inject.spi.TypeConverterBinding&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a set containing all type converter bindings in the injector. The returned set is
 immutable.

 <p>This method is part of the Guice SPI and is intended for use by tools and extensions.
 
 @since 3.0]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Builds the graphs of objects that make up your application. The injector tracks the dependencies
 for each type and uses bindings to inject them. This is the core of Guice, although you rarely
 interact with it directly. This "behind-the-scenes" operation is what distinguishes dependency
 injection from its cousin, the service locator pattern.

 <p>Contains several default bindings:

 <ul>
 <li>This {@link Injector} instance itself
 <li>A {@code Provider<T>} for each binding of type {@code T}
 <li>The {@link java.util.logging.Logger} for the class being injected
 <li>The {@link Stage} in which the Injector was created
 </ul>

 Injectors are created using the facade class {@link Guice}.

 <p>An injector can also {@link #injectMembers(Object) inject the dependencies} of
 already-constructed instances. This can be used to interoperate with objects created by other
 frameworks or services.

 <p>Injectors can be {@link #createChildInjector(Iterable) hierarchical}. Child injectors inherit
 the configuration of their parent injectors, but the converse does not hold.

 <p>The injector's {@link #getBindings() internal bindings} are available for introspection. This
 enables tools and extensions to operate on an injector reflectively.

 @author crazybob@google.com (Bob Lee)
 @author jessewilson@google.com (Jesse Wilson)]]>
    </doc>
  </interface>
  <!-- end interface com.google.inject.Injector -->
  <!-- start class com.google.inject.Key -->
  <class name="Key" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="Key" type="java.lang.Class&lt;? extends java.lang.annotation.Annotation&gt;"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a new key. Derives the type from this class's type parameter.

 <p>Clients create an empty anonymous subclass. Doing so embeds the type
 parameter in the anonymous class's type hierarchy so we can reconstitute it
 at runtime despite erasure.

 <p>Example usage for a binding of type {@code Foo} annotated with
 {@code @Bar}:

 <p>{@code new Key<Foo>(Bar.class) {}}.]]>
      </doc>
    </constructor>
    <constructor name="Key" type="java.lang.annotation.Annotation"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a new key. Derives the type from this class's type parameter.

 <p>Clients create an empty anonymous subclass. Doing so embeds the type
 parameter in the anonymous class's type hierarchy so we can reconstitute it
 at runtime despite erasure.

 <p>Example usage for a binding of type {@code Foo} annotated with
 {@code @Bar}:

 <p>{@code new Key<Foo>(new Bar()) {}}.]]>
      </doc>
    </constructor>
    <constructor name="Key"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a new key. Derives the type from this class's type parameter.

 <p>Clients create an empty anonymous subclass. Doing so embeds the type
 parameter in the anonymous class's type hierarchy so we can reconstitute it
 at runtime despite erasure.

 <p>Example usage for a binding of type {@code Foo}:

 <p>{@code new Key<Foo>() {}}.]]>
      </doc>
    </constructor>
    <method name="getTypeLiteral" return="com.google.inject.TypeLiteral&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the key type.]]>
      </doc>
    </method>
    <method name="getAnnotationType" return="java.lang.Class&lt;? extends java.lang.annotation.Annotation&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the annotation type.]]>
      </doc>
    </method>
    <method name="getAnnotation" return="java.lang.annotation.Annotation"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the annotation.]]>
      </doc>
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="o" type="java.lang.Object"/>
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="get" return="com.google.inject.Key&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="java.lang.Class&lt;T&gt;"/>
      <doc>
      <![CDATA[Gets a key for an injection type.]]>
      </doc>
    </method>
    <method name="get" return="com.google.inject.Key&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="java.lang.Class&lt;T&gt;"/>
      <param name="annotationType" type="java.lang.Class&lt;? extends java.lang.annotation.Annotation&gt;"/>
      <doc>
      <![CDATA[Gets a key for an injection type and an annotation type.]]>
      </doc>
    </method>
    <method name="get" return="com.google.inject.Key&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="java.lang.Class&lt;T&gt;"/>
      <param name="annotation" type="java.lang.annotation.Annotation"/>
      <doc>
      <![CDATA[Gets a key for an injection type and an annotation.]]>
      </doc>
    </method>
    <method name="get" return="com.google.inject.Key&lt;?&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="java.lang.reflect.Type"/>
      <doc>
      <![CDATA[Gets a key for an injection type.]]>
      </doc>
    </method>
    <method name="get" return="com.google.inject.Key&lt;?&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="java.lang.reflect.Type"/>
      <param name="annotationType" type="java.lang.Class&lt;? extends java.lang.annotation.Annotation&gt;"/>
      <doc>
      <![CDATA[Gets a key for an injection type and an annotation type.]]>
      </doc>
    </method>
    <method name="get" return="com.google.inject.Key&lt;?&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="java.lang.reflect.Type"/>
      <param name="annotation" type="java.lang.annotation.Annotation"/>
      <doc>
      <![CDATA[Gets a key for an injection type and an annotation.]]>
      </doc>
    </method>
    <method name="get" return="com.google.inject.Key&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="typeLiteral" type="com.google.inject.TypeLiteral&lt;T&gt;"/>
      <doc>
      <![CDATA[Gets a key for an injection type.]]>
      </doc>
    </method>
    <method name="get" return="com.google.inject.Key&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="typeLiteral" type="com.google.inject.TypeLiteral&lt;T&gt;"/>
      <param name="annotationType" type="java.lang.Class&lt;? extends java.lang.annotation.Annotation&gt;"/>
      <doc>
      <![CDATA[Gets a key for an injection type and an annotation type.]]>
      </doc>
    </method>
    <method name="get" return="com.google.inject.Key&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="typeLiteral" type="com.google.inject.TypeLiteral&lt;T&gt;"/>
      <param name="annotation" type="java.lang.annotation.Annotation"/>
      <doc>
      <![CDATA[Gets a key for an injection type and an annotation.]]>
      </doc>
    </method>
    <method name="ofType" return="com.google.inject.Key&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="java.lang.Class&lt;T&gt;"/>
      <doc>
      <![CDATA[Returns a new key of the specified type with the same annotation as this
 key.

 @since 3.0]]>
      </doc>
    </method>
    <method name="ofType" return="com.google.inject.Key&lt;?&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="java.lang.reflect.Type"/>
      <doc>
      <![CDATA[Returns a new key of the specified type with the same annotation as this
 key.

 @since 3.0]]>
      </doc>
    </method>
    <method name="ofType" return="com.google.inject.Key&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="com.google.inject.TypeLiteral&lt;T&gt;"/>
      <doc>
      <![CDATA[Returns a new key of the specified type with the same annotation as this
 key.

 @since 3.0]]>
      </doc>
    </method>
    <method name="hasAttributes" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns true if this key has annotation attributes.

 @since 3.0]]>
      </doc>
    </method>
    <method name="withoutAttributes" return="com.google.inject.Key&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns this key without annotation attributes, i.e. with only the
 annotation type.

 @since 3.0]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Binding key consisting of an injection type and an optional annotation.
 Matches the type and annotation at a point of injection.

 <p>For example, {@code Key.get(Service.class, Transactional.class)} will
 match:

 <pre>
   {@literal @}Inject
   public void setService({@literal @}Transactional Service service) {
     ...
   }
 </pre>

 <p>{@code Key} supports generic types via subclassing just like {@link
 TypeLiteral}.

 <p>Keys do not differentiate between primitive types (int, char, etc.) and
 their corresponding wrapper types (Integer, Character, etc.). Primitive
 types will be replaced with their wrapper types when keys are created.

 @author crazybob@google.com (Bob Lee)]]>
    </doc>
  </class>
  <!-- end class com.google.inject.Key -->
  <!-- start interface com.google.inject.MembersInjector -->
  <interface name="MembersInjector"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="injectMembers"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="instance" type="T"/>
      <doc>
      <![CDATA[Injects dependencies into the fields and methods of {@code instance}. Ignores the presence or
 absence of an injectable constructor.

 <p>Whenever Guice creates an instance, it performs this injection automatically (after first
 performing constructor injection), so if you're able to let Guice create all your objects for
 you, you'll never need to use this method.

 @param instance to inject members on. May be {@code null}.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Injects dependencies into the fields and methods on instances of type {@code T}. Ignores the
 presence or absence of an injectable constructor.

 @param <T> type to inject members of

 @author crazybob@google.com (Bob Lee)
 @author jessewilson@google.com (Jesse Wilson)
 @since 2.0]]>
    </doc>
  </interface>
  <!-- end interface com.google.inject.MembersInjector -->
  <!-- start interface com.google.inject.Module -->
  <interface name="Module"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="configure"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="binder" type="com.google.inject.Binder"/>
      <doc>
      <![CDATA[Contributes bindings and other configurations for this module to {@code binder}.

 <p><strong>Do not invoke this method directly</strong> to install submodules. Instead use
 {@link Binder#install(Module)}, which ensures that {@link Provides provider methods} are
 discovered.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A module contributes configuration information, typically interface
 bindings, which will be used to create an {@link Injector}. A Guice-based
 application is ultimately composed of little more than a set of
 {@code Module}s and some bootstrapping code.

 <p>Your Module classes can use a more streamlined syntax by extending
 {@link AbstractModule} rather than implementing this interface directly.

 <p>In addition to the bindings configured via {@link #configure}, bindings
 will be created for all methods annotated with {@literal @}{@link Provides}.
 Use scope and binding annotations on these methods to configure the
 bindings.]]>
    </doc>
  </interface>
  <!-- end interface com.google.inject.Module -->
  <!-- start class com.google.inject.OutOfScopeException -->
  <class name="OutOfScopeException" extends="java.lang.RuntimeException"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="OutOfScopeException" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="OutOfScopeException" type="java.lang.String, java.lang.Throwable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="OutOfScopeException" type="java.lang.Throwable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <doc>
    <![CDATA[Thrown from {@link Provider#get} when an attempt is made to access a scoped
 object while the scope in question is not currently active.

 @author kevinb@google.com (Kevin Bourrillion)
 @since 2.0]]>
    </doc>
  </class>
  <!-- end class com.google.inject.OutOfScopeException -->
  <!-- start interface com.google.inject.PrivateBinder -->
  <interface name="PrivateBinder"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.inject.Binder"/>
    <method name="expose"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="com.google.inject.Key&lt;?&gt;"/>
      <doc>
      <![CDATA[Makes the binding for {@code key} available to the enclosing environment]]>
      </doc>
    </method>
    <method name="expose" return="com.google.inject.binder.AnnotatedElementBuilder"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="java.lang.Class&lt;?&gt;"/>
      <doc>
      <![CDATA[Makes a binding for {@code type} available to the enclosing environment. Use {@link
 com.google.inject.binder.AnnotatedElementBuilder#annotatedWith(Class) annotatedWith()} to expose {@code type} with a
 binding annotation.]]>
      </doc>
    </method>
    <method name="expose" return="com.google.inject.binder.AnnotatedElementBuilder"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="com.google.inject.TypeLiteral&lt;?&gt;"/>
      <doc>
      <![CDATA[Makes a binding for {@code type} available to the enclosing environment. Use {@link
 AnnotatedElementBuilder#annotatedWith(Class) annotatedWith()} to expose {@code type} with a
 binding annotation.]]>
      </doc>
    </method>
    <method name="withSource" return="com.google.inject.PrivateBinder"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="source" type="java.lang.Object"/>
    </method>
    <method name="skipSources" return="com.google.inject.PrivateBinder"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="classesToSkip" type="java.lang.Class[]"/>
    </method>
    <doc>
    <![CDATA[Returns a binder whose configuration information is hidden from its environment by default. See
 {@link com.google.inject.PrivateModule PrivateModule} for details.
 
 @author jessewilson@google.com (Jesse Wilson)
 @since 2.0]]>
    </doc>
  </interface>
  <!-- end interface com.google.inject.PrivateBinder -->
  <!-- start class com.google.inject.PrivateModule -->
  <class name="PrivateModule" extends="java.lang.Object"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.inject.Module"/>
    <constructor name="PrivateModule"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="configure"
      abstract="false" native="false" synchronized="true"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="binder" type="com.google.inject.Binder"/>
    </method>
    <method name="configure"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates bindings and other configurations private to this module. Use {@link #expose(Class)
 expose()} to make the bindings in this module available externally.]]>
      </doc>
    </method>
    <method name="expose"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="protected"
      deprecated="not deprecated">
      <param name="key" type="com.google.inject.Key&lt;T&gt;"/>
      <doc>
      <![CDATA[Makes the binding for {@code key} available to other modules and the injector.]]>
      </doc>
    </method>
    <method name="expose" return="com.google.inject.binder.AnnotatedElementBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="protected"
      deprecated="not deprecated">
      <param name="type" type="java.lang.Class&lt;?&gt;"/>
      <doc>
      <![CDATA[Makes a binding for {@code type} available to other modules and the injector. Use {@link
 AnnotatedElementBuilder#annotatedWith(Class) annotatedWith()} to expose {@code type} with a
 binding annotation.]]>
      </doc>
    </method>
    <method name="expose" return="com.google.inject.binder.AnnotatedElementBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="protected"
      deprecated="not deprecated">
      <param name="type" type="com.google.inject.TypeLiteral&lt;?&gt;"/>
      <doc>
      <![CDATA[Makes a binding for {@code type} available to other modules and the injector. Use {@link
 AnnotatedElementBuilder#annotatedWith(Class) annotatedWith()} to expose {@code type} with a
 binding annotation.]]>
      </doc>
    </method>
    <method name="binder" return="com.google.inject.PrivateBinder"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the current binder.]]>
      </doc>
    </method>
    <method name="bindScope"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="protected"
      deprecated="not deprecated">
      <param name="scopeAnnotation" type="java.lang.Class&lt;? extends java.lang.annotation.Annotation&gt;"/>
      <param name="scope" type="com.google.inject.Scope"/>
      <doc>
      <![CDATA[@see Binder#bindScope(Class, Scope)]]>
      </doc>
    </method>
    <method name="bind" return="com.google.inject.binder.LinkedBindingBuilder&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="protected"
      deprecated="not deprecated">
      <param name="key" type="com.google.inject.Key&lt;T&gt;"/>
      <doc>
      <![CDATA[@see Binder#bind(Key)]]>
      </doc>
    </method>
    <method name="bind" return="com.google.inject.binder.AnnotatedBindingBuilder&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="protected"
      deprecated="not deprecated">
      <param name="typeLiteral" type="com.google.inject.TypeLiteral&lt;T&gt;"/>
      <doc>
      <![CDATA[@see Binder#bind(TypeLiteral)]]>
      </doc>
    </method>
    <method name="bind" return="com.google.inject.binder.AnnotatedBindingBuilder&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="protected"
      deprecated="not deprecated">
      <param name="clazz" type="java.lang.Class&lt;T&gt;"/>
      <doc>
      <![CDATA[@see Binder#bind(Class)]]>
      </doc>
    </method>
    <method name="bindConstant" return="com.google.inject.binder.AnnotatedConstantBindingBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@see Binder#bindConstant()]]>
      </doc>
    </method>
    <method name="install"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="protected"
      deprecated="not deprecated">
      <param name="module" type="com.google.inject.Module"/>
      <doc>
      <![CDATA[@see Binder#install(Module)]]>
      </doc>
    </method>
    <method name="addError"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="protected"
      deprecated="not deprecated">
      <param name="message" type="java.lang.String"/>
      <param name="arguments" type="java.lang.Object[]"/>
      <doc>
      <![CDATA[@see Binder#addError(String, Object[])]]>
      </doc>
    </method>
    <method name="addError"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="protected"
      deprecated="not deprecated">
      <param name="t" type="java.lang.Throwable"/>
      <doc>
      <![CDATA[@see Binder#addError(Throwable)]]>
      </doc>
    </method>
    <method name="addError"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="protected"
      deprecated="not deprecated">
      <param name="message" type="com.google.inject.spi.Message"/>
      <doc>
      <![CDATA[@see Binder#addError(Message)]]>
      </doc>
    </method>
    <method name="requestInjection"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="protected"
      deprecated="not deprecated">
      <param name="instance" type="java.lang.Object"/>
      <doc>
      <![CDATA[@see Binder#requestInjection(Object)]]>
      </doc>
    </method>
    <method name="requestStaticInjection"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="protected"
      deprecated="not deprecated">
      <param name="types" type="java.lang.Class[]"/>
      <doc>
      <![CDATA[@see Binder#requestStaticInjection(Class[])]]>
      </doc>
    </method>
    <method name="bindInterceptor"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="protected"
      deprecated="not deprecated">
      <param name="classMatcher" type="com.google.inject.matcher.Matcher&lt;? super java.lang.Class&lt;?&gt;&gt;"/>
      <param name="methodMatcher" type="com.google.inject.matcher.Matcher&lt;? super java.lang.reflect.Method&gt;"/>
      <param name="interceptors" type="org.aopalliance.intercept.MethodInterceptor[]"/>
      <doc>
      <![CDATA[@see Binder#bindInterceptor(com.google.inject.matcher.Matcher, com.google.inject.matcher.Matcher, org.aopalliance.intercept.MethodInterceptor[])]]>
      </doc>
    </method>
    <method name="requireBinding"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="protected"
      deprecated="not deprecated">
      <param name="key" type="com.google.inject.Key&lt;?&gt;"/>
      <doc>
      <![CDATA[Instructs Guice to require a binding to the given key.]]>
      </doc>
    </method>
    <method name="requireBinding"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="protected"
      deprecated="not deprecated">
      <param name="type" type="java.lang.Class&lt;?&gt;"/>
      <doc>
      <![CDATA[Instructs Guice to require a binding to the given type.]]>
      </doc>
    </method>
    <method name="getProvider" return="com.google.inject.Provider&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="protected"
      deprecated="not deprecated">
      <param name="key" type="com.google.inject.Key&lt;T&gt;"/>
      <doc>
      <![CDATA[@see Binder#getProvider(Key)]]>
      </doc>
    </method>
    <method name="getProvider" return="com.google.inject.Provider&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="protected"
      deprecated="not deprecated">
      <param name="type" type="java.lang.Class&lt;T&gt;"/>
      <doc>
      <![CDATA[@see Binder#getProvider(Class)]]>
      </doc>
    </method>
    <method name="convertToTypes"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="protected"
      deprecated="not deprecated">
      <param name="typeMatcher" type="com.google.inject.matcher.Matcher&lt;? super com.google.inject.TypeLiteral&lt;?&gt;&gt;"/>
      <param name="converter" type="com.google.inject.spi.TypeConverter"/>
      <doc>
      <![CDATA[@see Binder#convertToTypes(com.google.inject.matcher.Matcher, com.google.inject.spi.TypeConverter)]]>
      </doc>
    </method>
    <method name="currentStage" return="com.google.inject.Stage"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@see Binder#currentStage()]]>
      </doc>
    </method>
    <method name="getMembersInjector" return="com.google.inject.MembersInjector&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="type" type="java.lang.Class&lt;T&gt;"/>
      <doc>
      <![CDATA[@see Binder#getMembersInjector(Class)]]>
      </doc>
    </method>
    <method name="getMembersInjector" return="com.google.inject.MembersInjector&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="type" type="com.google.inject.TypeLiteral&lt;T&gt;"/>
      <doc>
      <![CDATA[@see Binder#getMembersInjector(TypeLiteral)]]>
      </doc>
    </method>
    <method name="bindListener"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="typeMatcher" type="com.google.inject.matcher.Matcher&lt;? super com.google.inject.TypeLiteral&lt;?&gt;&gt;"/>
      <param name="listener" type="com.google.inject.spi.TypeListener"/>
      <doc>
      <![CDATA[@see Binder#bindListener(com.google.inject.matcher.Matcher, com.google.inject.spi.TypeListener)]]>
      </doc>
    </method>
    <method name="bindListener"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="bindingMatcher" type="com.google.inject.matcher.Matcher&lt;? super com.google.inject.Binding&lt;?&gt;&gt;"/>
      <param name="listeners" type="com.google.inject.spi.ProvisionListener[]"/>
      <doc>
      <![CDATA[@see Binder#bindListener(Matcher, ProvisionListener...)
 @since 4.0]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A module whose configuration information is hidden from its environment by default. Only bindings
 that are explicitly exposed will be available to other modules and to the users of the injector.
 This module may expose the bindings it creates and the bindings of the modules it installs.

 <p>A private module can be nested within a regular module or within another private module using
 {@link Binder#install install()}.  Its bindings live in a new environment that inherits bindings,
 type converters, scopes, and interceptors from the surrounding ("parent") environment.  When you
 nest multiple private modules, the result is a tree of environments where the injector's
 environment is the root.

 <p>Guice EDSL bindings can be exposed with {@link #expose(Class) expose()}. {@literal @}{@link
 com.google.inject.Provides Provides} bindings can be exposed with the {@literal @}{@link
 Exposed} annotation:

 <pre>
 public class FooBarBazModule extends PrivateModule {
   protected void configure() {
     bind(Foo.class).to(RealFoo.class);
     expose(Foo.class);

     install(new TransactionalBarModule());
     expose(Bar.class).annotatedWith(Transactional.class);

     bind(SomeImplementationDetail.class);
     install(new MoreImplementationDetailsModule());
   }

   {@literal @}Provides {@literal @}Exposed
   public Baz provideBaz() {
     return new SuperBaz();
   }
 }
 </pre>

 <p>Private modules are implemented using {@link Injector#createChildInjector(Module[]) parent
 injectors}. When it can satisfy their dependencies, just-in-time bindings will be created in the
 root environment. Such bindings are shared among all environments in the tree.
 
 <p>The scope of a binding is constrained to its environment. A singleton bound in a private
 module will be unique to its environment. But a binding for the same type in a different private
 module will yield a different instance.

 <p>A shared binding that injects the {@code Injector} gets the root injector, which only has
 access to bindings in the root environment. An explicit binding that injects the {@code Injector}
 gets access to all bindings in the child environment.

 <p>To promote a just-in-time binding to an explicit binding, bind it:
 <pre>
   bind(FooImpl.class);
 </pre>

 @author jessewilson@google.com (Jesse Wilson)
 @since 2.0]]>
    </doc>
  </class>
  <!-- end class com.google.inject.PrivateModule -->
  <!-- start class com.google.inject.ProvidedBy -->
  <class name="ProvidedBy"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.lang.annotation.Annotation"/>
    <doc>
    <![CDATA[A pointer to the default provider type for a type.

 @author crazybob@google.com (Bob Lee)]]>
    </doc>
  </class>
  <!-- end class com.google.inject.ProvidedBy -->
  <!-- start interface com.google.inject.Provider -->
  <interface name="Provider"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="javax.inject.Provider&lt;T&gt;"/>
    <method name="get" return="T"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Provides an instance of {@code T}. Must never return {@code null}.

 @throws OutOfScopeException when an attempt is made to access a scoped object while the scope
     in question is not currently active
 @throws ProvisionException if an instance cannot be provided. Such exceptions include messages
     and throwables to describe why provision failed.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[An object capable of providing instances of type {@code T}. Providers are used in numerous ways
 by Guice:

 <ul>
 <li>When the default means for obtaining instances (an injectable or parameterless constructor)
 is insufficient for a particular binding, the module can specify a custom {@code Provider}
 instead, to control exactly how Guice creates or obtains instances for the binding.

 <li>An implementation class may always choose to have a {@code Provider<T>} instance injected,
 rather than having a {@code T} injected directly.  This may give you access to multiple
 instances, instances you wish to safely mutate and discard, instances which are out of scope
 (e.g. using a {@code @RequestScoped} object from within a {@code @SessionScoped} object), or
 instances that will be initialized lazily.

 <li>A custom {@link Scope} is implemented as a decorator of {@code Provider<T>}, which decides
 when to delegate to the backing provider and when to provide the instance some other way.

 <li>The {@link Injector} offers access to the {@code Provider<T>} it uses to fulfill requests
 for a given key, via the {@link Injector#getProvider} methods.
 </ul>

 @param <T> the type of object this provides

 @author crazybob@google.com (Bob Lee)]]>
    </doc>
  </interface>
  <!-- end interface com.google.inject.Provider -->
  <!-- start class com.google.inject.Provides -->
  <class name="Provides"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.lang.annotation.Annotation"/>
    <doc>
    <![CDATA[Annotates methods of a {@link Module} to create a provider method binding. The method's return
 type is bound to its returned value. Guice will pass dependencies to the method as parameters.

 @author crazybob@google.com (Bob Lee)
 @since 2.0]]>
    </doc>
  </class>
  <!-- end class com.google.inject.Provides -->
  <!-- start class com.google.inject.ProvisionException -->
  <class name="ProvisionException" extends="java.lang.RuntimeException"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="ProvisionException" type="java.lang.Iterable&lt;com.google.inject.spi.Message&gt;"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a ProvisionException containing {@code messages}.]]>
      </doc>
    </constructor>
    <constructor name="ProvisionException" type="java.lang.String, java.lang.Throwable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="ProvisionException" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getErrorMessages" return="java.util.Collection&lt;com.google.inject.spi.Message&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns messages for the errors that caused this exception.]]>
      </doc>
    </method>
    <method name="getMessage" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Indicates that there was a runtime failure while providing an instance.

 @author kevinb@google.com (Kevin Bourrillion)
 @author jessewilson@google.com (Jesse Wilson)
 @since 2.0]]>
    </doc>
  </class>
  <!-- end class com.google.inject.ProvisionException -->
  <!-- start interface com.google.inject.Scope -->
  <interface name="Scope"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="scope" return="com.google.inject.Provider&lt;T&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="com.google.inject.Key&lt;T&gt;"/>
      <param name="unscoped" type="com.google.inject.Provider&lt;T&gt;"/>
      <doc>
      <![CDATA[Scopes a provider. The returned provider returns objects from this scope.
 If an object does not exist in this scope, the provider can use the given
 unscoped provider to retrieve one.

 <p>Scope implementations are strongly encouraged to override
 {@link Object#toString} in the returned provider and include the backing
 provider's {@code toString()} output.

 @param key binding key
 @param unscoped locates an instance when one doesn't already exist in this
  scope.
 @return a new provider which only delegates to the given unscoped provider
  when an instance of the requested object doesn't already exist in this
  scope]]>
      </doc>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[A short but useful description of this scope.  For comparison, the standard
 scopes that ship with guice use the descriptions
 {@code "Scopes.SINGLETON"}, {@code "ServletScopes.SESSION"} and
 {@code "ServletScopes.REQUEST"}.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A scope is a level of visibility that instances provided by Guice may have.
 By default, an instance created by the {@link Injector} has <i>no scope</i>,
 meaning it has no state from the framework's perspective -- the
 {@code Injector} creates it, injects it once into the class that required it,
 and then immediately forgets it. Associating a scope with a particular
 binding allows the created instance to be "remembered" and possibly used
 again for other injections.

 <p>An example of a scope is {@link Scopes#SINGLETON}.

 @author crazybob@google.com (Bob Lee)]]>
    </doc>
  </interface>
  <!-- end interface com.google.inject.Scope -->
  <!-- start class com.google.inject.ScopeAnnotation -->
  <class name="ScopeAnnotation"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.lang.annotation.Annotation"/>
    <doc>
    <![CDATA[Annotates annotations which are used for scoping. Only one such annotation
 may apply to a single implementation class. You must also annotate scope
 annotations with {@code @Retention(RUNTIME)}. For example:

 <pre>
   {@code @}Retention(RUNTIME)
   {@code @}Target(TYPE, METHOD)
   {@code @}ScopeAnnotation
   public {@code @}interface SessionScoped {}
 </pre>

 @author crazybob@google.com (Bob Lee)]]>
    </doc>
  </class>
  <!-- end class com.google.inject.ScopeAnnotation -->
  <!-- start class com.google.inject.Scopes -->
  <class name="Scopes" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="isSingleton" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="binding" type="com.google.inject.Binding&lt;?&gt;"/>
      <doc>
      <![CDATA[Returns true if {@code binding} is singleton-scoped. If the binding is a {@link
 com.google.inject.spi.LinkedKeyBinding linked key binding} and belongs to an injector (ie. it
 was retrieved via {@link Injector#getBinding Injector.getBinding()}), then this method will
 also true if the target binding is singleton-scoped.

 @since 3.0]]>
      </doc>
    </method>
    <method name="isScoped" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="binding" type="com.google.inject.Binding&lt;?&gt;"/>
      <param name="scope" type="com.google.inject.Scope"/>
      <param name="scopeAnnotation" type="java.lang.Class&lt;? extends java.lang.annotation.Annotation&gt;"/>
      <doc>
      <![CDATA[Returns true if {@code binding} has the given scope. If the binding is a {@link
 com.google.inject.spi.LinkedKeyBinding linked key binding} and belongs to an injector (ie. it
 was retrieved via {@link Injector#getBinding Injector.getBinding()}), then this method will
 also true if the target binding has the given scope.

 @param binding binding to check
 @param scope scope implementation instance
 @param scopeAnnotation scope annotation class
 @since 4.0]]>
      </doc>
    </method>
    <method name="isCircularProxy" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="object" type="java.lang.Object"/>
      <doc>
      <![CDATA[Returns true if the object is a proxy for a circular dependency,
 constructed by Guice because it encountered a circular dependency. Scope
 implementations should be careful to <b>not cache circular proxies</b>,
 because the proxies are not intended for general purpose use. (They are
 designed just to fulfill the immediate injection, not all injections.
 Caching them can lead to IllegalArgumentExceptions or ClassCastExceptions.)

 @since 4.0]]>
      </doc>
    </method>
    <field name="SINGLETON" type="com.google.inject.Scope"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[One instance per {@link Injector}. Also see {@code @}{@link Singleton}.]]>
      </doc>
    </field>
    <field name="NO_SCOPE" type="com.google.inject.Scope"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[No scope; the same as not applying any scope at all.  Each time the
 Injector obtains an instance of an object with "no scope", it injects this
 instance then immediately forgets it.  When the next request for the same
 binding arrives it will need to obtain the instance over again.

 <p>This exists only in case a class has been annotated with a scope
 annotation such as {@link Singleton @Singleton}, and you need to override
 this to "no scope" in your binding.

 @since 2.0]]>
      </doc>
    </field>
    <doc>
    <![CDATA[Built-in scope implementations.

 @author crazybob@google.com (Bob Lee)]]>
    </doc>
  </class>
  <!-- end class com.google.inject.Scopes -->
  <!-- start class com.google.inject.Singleton -->
  <class name="Singleton"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.lang.annotation.Annotation"/>
    <doc>
    <![CDATA[Apply this to implementation classes when you want only one instance
 (per {@link Injector}) to be reused for all injections for that binding.

 @author crazybob@google.com (Bob Lee)]]>
    </doc>
  </class>
  <!-- end class com.google.inject.Singleton -->
  <!-- start class com.google.inject.Stage -->
  <class name="Stage" extends="java.lang.Enum&lt;com.google.inject.Stage&gt;"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="values" return="com.google.inject.Stage[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="com.google.inject.Stage"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <doc>
    <![CDATA[The stage we're running in.

 @author crazybob@google.com (Bob Lee)]]>
    </doc>
  </class>
  <!-- end class com.google.inject.Stage -->
  <!-- start class com.google.inject.TypeLiteral -->
  <class name="TypeLiteral" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="TypeLiteral"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a new type literal. Derives represented class from type
 parameter.

 <p>Clients create an empty anonymous subclass. Doing so embeds the type
 parameter in the anonymous class's type hierarchy so we can reconstitute it
 at runtime despite erasure.]]>
      </doc>
    </constructor>
    <method name="getRawType" return="java.lang.Class&lt;? super T&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the raw (non-generic) type for this type.
 
 @since 2.0]]>
      </doc>
    </method>
    <method name="getType" return="java.lang.reflect.Type"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets underlying {@code Type} instance.]]>
      </doc>
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="o" type="java.lang.Object"/>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="get" return="com.google.inject.TypeLiteral&lt;?&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="java.lang.reflect.Type"/>
      <doc>
      <![CDATA[Gets type literal for the given {@code Type} instance.]]>
      </doc>
    </method>
    <method name="get" return="com.google.inject.TypeLiteral&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="java.lang.Class&lt;T&gt;"/>
      <doc>
      <![CDATA[Gets type literal for the given {@code Class} instance.]]>
      </doc>
    </method>
    <method name="getSupertype" return="com.google.inject.TypeLiteral&lt;?&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="supertype" type="java.lang.Class&lt;?&gt;"/>
      <doc>
      <![CDATA[Returns the generic form of {@code supertype}. For example, if this is {@code
 ArrayList<String>}, this returns {@code Iterable<String>} given the input {@code
 Iterable.class}.

 @param supertype a superclass of, or interface implemented by, this.
 @since 2.0]]>
      </doc>
    </method>
    <method name="getFieldType" return="com.google.inject.TypeLiteral&lt;?&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="field" type="java.lang.reflect.Field"/>
      <doc>
      <![CDATA[Returns the resolved generic type of {@code field}.

 @param field a field defined by this or any superclass.
 @since 2.0]]>
      </doc>
    </method>
    <method name="getParameterTypes" return="java.util.List&lt;com.google.inject.TypeLiteral&lt;?&gt;&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="methodOrConstructor" type="java.lang.reflect.Member"/>
      <doc>
      <![CDATA[Returns the resolved generic parameter types of {@code methodOrConstructor}.

 @param methodOrConstructor a method or constructor defined by this or any supertype.
 @since 2.0]]>
      </doc>
    </method>
    <method name="getExceptionTypes" return="java.util.List&lt;com.google.inject.TypeLiteral&lt;?&gt;&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="methodOrConstructor" type="java.lang.reflect.Member"/>
      <doc>
      <![CDATA[Returns the resolved generic exception types thrown by {@code constructor}.

 @param methodOrConstructor a method or constructor defined by this or any supertype.
 @since 2.0]]>
      </doc>
    </method>
    <method name="getReturnType" return="com.google.inject.TypeLiteral&lt;?&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="method" type="java.lang.reflect.Method"/>
      <doc>
      <![CDATA[Returns the resolved generic return type of {@code method}.

 @param method a method defined by this or any supertype.
 @since 2.0]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Represents a generic type {@code T}. Java doesn't yet provide a way to
 represent generic types, so this class does. Forces clients to create a
 subclass of this class which enables retrieval the type information even at
 runtime.

 <p>For example, to create a type literal for {@code List<String>}, you can
 create an empty anonymous inner class:

 <p>
 {@code TypeLiteral<List<String>> list = new TypeLiteral<List<String>>() {};}

 <p>Along with modeling generic types, this class can resolve type parameters.
 For example, to figure out what type {@code keySet()} returns on a {@code
 Map<Integer, String>}, use this code:<pre>   {@code

   TypeLiteral<Map<Integer, String>> mapType
       = new TypeLiteral<Map<Integer, String>>() {};
   TypeLiteral<?> keySetType
       = mapType.getReturnType(Map.class.getMethod("keySet"));
   System.out.println(keySetType); // prints "Set<Integer>"}</pre>

 @author crazybob@google.com (Bob Lee)
 @author jessewilson@google.com (Jesse Wilson)]]>
    </doc>
  </class>
  <!-- end class com.google.inject.TypeLiteral -->
</package>
<package name="com.google.inject.assistedinject">
  <!-- start class com.google.inject.assistedinject.Assisted -->
  <class name="Assisted"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.lang.annotation.Annotation"/>
    <doc>
    <![CDATA[Annotates an injected parameter or field whose value comes from an argument to a factory method.

 @author jmourits@google.com (Jerome Mourits)
 @author jessewilson@google.com (Jesse Wilson)]]>
    </doc>
  </class>
  <!-- end class com.google.inject.assistedinject.Assisted -->
  <!-- start class com.google.inject.assistedinject.AssistedInject -->
  <class name="AssistedInject"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.lang.annotation.Annotation"/>
    <doc>
    <![CDATA[<p>
 When used in tandem with {@link FactoryModuleBuilder}, constructors annotated with 
 {@code @AssistedInject} indicate that multiple constructors can be injected, each with different
 parameters. AssistedInject annotations should not be mixed with {@literal @}{@link Inject}
 annotations. The assisted parameters must exactly match one corresponding factory method within
 the factory interface, but the parameters do not need to be in the same order. Constructors
 annotated with AssistedInject <b>are</b> created by Guice and receive all the benefits
 (such as AOP).
 
 <p>
 <strong>Obsolete Usage:</strong> When used in tandem with {@link FactoryProvider}, constructors
 annotated with {@code @AssistedInject} trigger a "backwards compatibility mode". The assisted
 parameters must exactly match one corresponding factory method within the factory interface and
 all must be in the same order as listed in the factory. In this backwards compatable mode,
 constructors annotated with AssistedInject <b>are not</b> created by Guice and thus receive
 none of the benefits.
 
 <p>
 Constructor parameters must be either supplied by the factory interface and marked with
 <code>@Assisted</code>, or they must be injectable.
 
 @author jmourits@google.com (Jerome Mourits)
 @author jessewilson@google.com (Jesse Wilson)]]>
    </doc>
  </class>
  <!-- end class com.google.inject.assistedinject.AssistedInject -->
  <!-- start interface com.google.inject.assistedinject.AssistedInjectBinding -->
  <interface name="AssistedInjectBinding"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="getKey" return="com.google.inject.Key&lt;T&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the {@link Key} for the factory binding.]]>
      </doc>
    </method>
    <method name="getAssistedMethods" return="java.util.Collection&lt;com.google.inject.assistedinject.AssistedMethod&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns an {@link AssistedMethod} for each method in the factory.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A binding for a factory created by FactoryModuleBuilder.
 
 @param <T> The fully qualified type of the factory.
  
 @since 3.0
 @author ramakrishna@google.com (Ramakrishna Rajanna)]]>
    </doc>
  </interface>
  <!-- end interface com.google.inject.assistedinject.AssistedInjectBinding -->
  <!-- start interface com.google.inject.assistedinject.AssistedInjectTargetVisitor -->
  <interface name="AssistedInjectTargetVisitor"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.inject.spi.BindingTargetVisitor&lt;T, V&gt;"/>
    <method name="visit" return="V"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="assistedInjectBinding" type="com.google.inject.assistedinject.AssistedInjectBinding&lt;? extends T&gt;"/>
      <doc>
      <![CDATA[Visits an {@link AssistedInjectBinding} created through {@link FactoryModuleBuilder}.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A visitor for the AssistedInject extension.
 <p>
 If your {@link BindingTargetVisitor} implements this interface, bindings created by using
 {@link FactoryModuleBuilder} will be visited through this interface.

 @since 3.0
 @author ramakrishna@google.com (Ramakrishna Rajanna)]]>
    </doc>
  </interface>
  <!-- end interface com.google.inject.assistedinject.AssistedInjectTargetVisitor -->
  <!-- start interface com.google.inject.assistedinject.AssistedMethod -->
  <interface name="AssistedMethod"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="getFactoryMethod" return="java.lang.reflect.Method"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the factory method that is being assisted.]]>
      </doc>
    </method>
    <method name="getImplementationType" return="com.google.inject.TypeLiteral&lt;?&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the implementation type that will be created when the method is
 used.]]>
      </doc>
    </method>
    <method name="getImplementationConstructor" return="java.lang.reflect.Constructor&lt;?&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the constructor that will be used to construct instances of the 
 implementation.]]>
      </doc>
    </method>
    <method name="getDependencies" return="java.util.Set&lt;com.google.inject.spi.Dependency&lt;?&gt;&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns all non-assisted dependencies required to construct and inject
 the implementation.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Details about how a method in an assisted inject factory will be assisted.
 
 @since 3.0
 @author ramakrishna@google.com (Ramakrishna Rajanna)]]>
    </doc>
  </interface>
  <!-- end interface com.google.inject.assistedinject.AssistedMethod -->
  <!-- start class com.google.inject.assistedinject.FactoryModuleBuilder -->
  <class name="FactoryModuleBuilder" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="FactoryModuleBuilder"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="implement" return="com.google.inject.assistedinject.FactoryModuleBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="source" type="java.lang.Class&lt;T&gt;"/>
      <param name="target" type="java.lang.Class&lt;? extends T&gt;"/>
      <doc>
      <![CDATA[See the factory configuration examples at {@link FactoryModuleBuilder}.]]>
      </doc>
    </method>
    <method name="implement" return="com.google.inject.assistedinject.FactoryModuleBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="source" type="java.lang.Class&lt;T&gt;"/>
      <param name="target" type="com.google.inject.TypeLiteral&lt;? extends T&gt;"/>
      <doc>
      <![CDATA[See the factory configuration examples at {@link FactoryModuleBuilder}.]]>
      </doc>
    </method>
    <method name="implement" return="com.google.inject.assistedinject.FactoryModuleBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="source" type="com.google.inject.TypeLiteral&lt;T&gt;"/>
      <param name="target" type="java.lang.Class&lt;? extends T&gt;"/>
      <doc>
      <![CDATA[See the factory configuration examples at {@link FactoryModuleBuilder}.]]>
      </doc>
    </method>
    <method name="implement" return="com.google.inject.assistedinject.FactoryModuleBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="source" type="com.google.inject.TypeLiteral&lt;T&gt;"/>
      <param name="target" type="com.google.inject.TypeLiteral&lt;? extends T&gt;"/>
      <doc>
      <![CDATA[See the factory configuration examples at {@link FactoryModuleBuilder}.]]>
      </doc>
    </method>
    <method name="implement" return="com.google.inject.assistedinject.FactoryModuleBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="source" type="java.lang.Class&lt;T&gt;"/>
      <param name="annotation" type="java.lang.annotation.Annotation"/>
      <param name="target" type="java.lang.Class&lt;? extends T&gt;"/>
      <doc>
      <![CDATA[See the factory configuration examples at {@link FactoryModuleBuilder}.]]>
      </doc>
    </method>
    <method name="implement" return="com.google.inject.assistedinject.FactoryModuleBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="source" type="java.lang.Class&lt;T&gt;"/>
      <param name="annotation" type="java.lang.annotation.Annotation"/>
      <param name="target" type="com.google.inject.TypeLiteral&lt;? extends T&gt;"/>
      <doc>
      <![CDATA[See the factory configuration examples at {@link FactoryModuleBuilder}.]]>
      </doc>
    </method>
    <method name="implement" return="com.google.inject.assistedinject.FactoryModuleBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="source" type="com.google.inject.TypeLiteral&lt;T&gt;"/>
      <param name="annotation" type="java.lang.annotation.Annotation"/>
      <param name="target" type="java.lang.Class&lt;? extends T&gt;"/>
      <doc>
      <![CDATA[See the factory configuration examples at {@link FactoryModuleBuilder}.]]>
      </doc>
    </method>
    <method name="implement" return="com.google.inject.assistedinject.FactoryModuleBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="source" type="com.google.inject.TypeLiteral&lt;T&gt;"/>
      <param name="annotation" type="java.lang.annotation.Annotation"/>
      <param name="target" type="com.google.inject.TypeLiteral&lt;? extends T&gt;"/>
      <doc>
      <![CDATA[See the factory configuration examples at {@link FactoryModuleBuilder}.]]>
      </doc>
    </method>
    <method name="implement" return="com.google.inject.assistedinject.FactoryModuleBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="source" type="java.lang.Class&lt;T&gt;"/>
      <param name="annotationType" type="java.lang.Class&lt;? extends java.lang.annotation.Annotation&gt;"/>
      <param name="target" type="java.lang.Class&lt;? extends T&gt;"/>
      <doc>
      <![CDATA[See the factory configuration examples at {@link FactoryModuleBuilder}.]]>
      </doc>
    </method>
    <method name="implement" return="com.google.inject.assistedinject.FactoryModuleBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="source" type="java.lang.Class&lt;T&gt;"/>
      <param name="annotationType" type="java.lang.Class&lt;? extends java.lang.annotation.Annotation&gt;"/>
      <param name="target" type="com.google.inject.TypeLiteral&lt;? extends T&gt;"/>
      <doc>
      <![CDATA[See the factory configuration examples at {@link FactoryModuleBuilder}.]]>
      </doc>
    </method>
    <method name="implement" return="com.google.inject.assistedinject.FactoryModuleBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="source" type="com.google.inject.TypeLiteral&lt;T&gt;"/>
      <param name="annotationType" type="java.lang.Class&lt;? extends java.lang.annotation.Annotation&gt;"/>
      <param name="target" type="java.lang.Class&lt;? extends T&gt;"/>
      <doc>
      <![CDATA[See the factory configuration examples at {@link FactoryModuleBuilder}.]]>
      </doc>
    </method>
    <method name="implement" return="com.google.inject.assistedinject.FactoryModuleBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="source" type="com.google.inject.TypeLiteral&lt;T&gt;"/>
      <param name="annotationType" type="java.lang.Class&lt;? extends java.lang.annotation.Annotation&gt;"/>
      <param name="target" type="com.google.inject.TypeLiteral&lt;? extends T&gt;"/>
      <doc>
      <![CDATA[See the factory configuration examples at {@link FactoryModuleBuilder}.]]>
      </doc>
    </method>
    <method name="implement" return="com.google.inject.assistedinject.FactoryModuleBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="source" type="com.google.inject.Key&lt;T&gt;"/>
      <param name="target" type="java.lang.Class&lt;? extends T&gt;"/>
      <doc>
      <![CDATA[See the factory configuration examples at {@link FactoryModuleBuilder}.]]>
      </doc>
    </method>
    <method name="implement" return="com.google.inject.assistedinject.FactoryModuleBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="source" type="com.google.inject.Key&lt;T&gt;"/>
      <param name="target" type="com.google.inject.TypeLiteral&lt;? extends T&gt;"/>
      <doc>
      <![CDATA[See the factory configuration examples at {@link FactoryModuleBuilder}.]]>
      </doc>
    </method>
    <method name="build" return="com.google.inject.Module"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="factoryInterface" type="java.lang.Class&lt;F&gt;"/>
      <doc>
      <![CDATA[See the factory configuration examples at {@link FactoryModuleBuilder}.]]>
      </doc>
    </method>
    <method name="build" return="com.google.inject.Module"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="factoryInterface" type="com.google.inject.TypeLiteral&lt;F&gt;"/>
      <doc>
      <![CDATA[See the factory configuration examples at {@link FactoryModuleBuilder}.]]>
      </doc>
    </method>
    <method name="build" return="com.google.inject.Module"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="factoryInterface" type="com.google.inject.Key&lt;F&gt;"/>
    </method>
    <doc>
    <![CDATA[Provides a factory that combines the caller's arguments with injector-supplied values to
 construct objects.

 <h3>Defining a factory</h3>
 Create an interface whose methods return the constructed type, or any of its supertypes. The
 method's parameters are the arguments required to build the constructed type.

 <pre>public interface PaymentFactory {
   Payment create(Date startDate, Money amount);
 }</pre>

 You can name your factory methods whatever you like, such as <i>create</i>, <i>createPayment</i>
 or <i>newPayment</i>.

 <h3>Creating a type that accepts factory parameters</h3>
 {@code constructedType} is a concrete class with an {@literal @}{@link com.google.inject.Inject
 Inject}-annotated constructor. In addition to injector-supplied parameters, the constructor
 should have parameters that match each of the factory method's parameters. Each factory-supplied
 parameter requires an {@literal @}{@link Assisted} annotation. This serves to document that the
 parameter is not bound by your application's modules.

 <pre>public class RealPayment implements Payment {
   {@literal @}Inject
   public RealPayment(
      CreditService creditService,
      AuthService authService,
      <strong>{@literal @}Assisted Date startDate</strong>,
      <strong>{@literal @}Assisted Money amount</strong>) {
     ...
   }
 }</pre>
 
 <h3>Multiple factory methods for the same type</h3>
 If the factory contains many methods that return the same type, you can create multiple
 constructors in your concrete class, each constructor marked with with
 {@literal @}{@link AssistedInject}, in order to match the different parameters types of the
 factory methods. 
 
 <pre>public interface PaymentFactory {
    Payment create(Date startDate, Money amount);
    Payment createWithoutDate(Money amount);
 }
 
 public class RealPayment implements Payment {
  {@literal @}AssistedInject
   public RealPayment(
      CreditService creditService,
      AuthService authService,
     <strong>{@literal @}Assisted Date startDate</strong>,
     <strong>{@literal @}Assisted Money amount</strong>) {
     ...
   }
   
  {@literal @}AssistedInject
   public RealPayment(
      CreditService creditService,
      AuthService authService,
     <strong>{@literal @}Assisted Money amount</strong>) {
     ...
   }   
 }</pre> 

 <h3>Configuring simple factories</h3>
 In your {@link Module module}, install a {@code FactoryModuleBuilder} that creates the
 factory:

 <pre>install(new FactoryModuleBuilder()
     .implement(Payment.class, RealPayment.class)
     .build(PaymentFactory.class));</pre>

 As a side-effect of this binding, Guice will inject the factory to initialize it for use. The
 factory cannot be used until the injector has been initialized.
 
 <h3>Configuring complex factories</h3>
 Factories can create an arbitrary number of objects, one per each method.  Each factory
 method can be configured using <code>.implement</code>.

 <pre>public interface OrderFactory {
    Payment create(Date startDate, Money amount);
    Shipment create(Customer customer, Item item);
    Receipt create(Payment payment, Shipment shipment);
 }
 
 [...]
 
 install(new FactoryModuleBuilder()
     .implement(Payment.class, RealPayment.class)
     // excluding .implement for Shipment means the implementation class
     // will be 'Shipment' itself, which is legal if it's not an interface.
     .implement(Receipt.class, RealReceipt.class)
     .build(OrderFactory.class));</pre>
 </pre>

 <h3>Using the factory</h3>
 Inject your factory into your application classes. When you use the factory, your arguments
 will be combined with values from the injector to construct an instance.

 <pre>public class PaymentAction {
   {@literal @}Inject private PaymentFactory paymentFactory;

   public void doPayment(Money amount) {
     Payment payment = paymentFactory.create(new Date(), amount);
     payment.apply();
   }
 }</pre>

 <h3>Making parameter types distinct</h3>
 The types of the factory method's parameters must be distinct. To use multiple parameters of
 the same type, use a named {@literal @}{@link Assisted} annotation to disambiguate the
 parameters. The names must be applied to the factory method's parameters:

 <pre>public interface PaymentFactory {
   Payment create(
       <strong>{@literal @}Assisted("startDate")</strong> Date startDate,
       <strong>{@literal @}Assisted("dueDate")</strong> Date dueDate,
       Money amount);
 } </pre>

 ...and to the concrete type's constructor parameters:

 <pre>public class RealPayment implements Payment {
   {@literal @}Inject
   public RealPayment(
      CreditService creditService,
      AuthService authService,
      <strong>{@literal @}Assisted("startDate")</strong> Date startDate,
      <strong>{@literal @}Assisted("dueDate")</strong> Date dueDate,
      <strong>{@literal @}Assisted</strong> Money amount) {
     ...
   }
 }</pre>

 <h3>Values are created by Guice</h3>
 Returned factories use child injectors to create values. The values are eligible for method
 interception. In addition, {@literal @}{@literal Inject} members will be injected before they are
 returned.

 <h3>More configuration options</h3>
 In addition to simply specifying an implementation class for any returned type, factories' return
 values can be automatic or can be configured to use annotations:
 <p/>
 If you just want to return the types specified in the factory, do not configure any
 implementations:

 <pre>public interface FruitFactory {
   Apple getApple(Color color);
 }
 ...
 protected void configure() {
   install(new FactoryModuleBuilder().build(FruitFactory.class));
 }</pre>

 Note that any type returned by the factory in this manner needs to be an implementation class.
 <p/>
 To return two different implementations for the same interface from your factory, use binding
 annotations on your return types:

 <pre>interface CarFactory {
   {@literal @}Named("fast") Car getFastCar(Color color);
   {@literal @}Named("clean") Car getCleanCar(Color color);
 }
 ...
 protected void configure() {
   install(new FactoryModuleBuilder()
       .implement(Car.class, Names.named("fast"), Porsche.class)
       .implement(Car.class, Names.named("clean"), Prius.class)
       .build(CarFactory.class));
 }</pre>
 
 <h3>Implementation limitations</h3>
 As a limitation of the implementation, it is prohibited to declare a factory method that
 accepts a {@code Provider} as one of its arguments.

 @since 3.0
 @author schmitt@google.com (Peter Schmitt)]]>
    </doc>
  </class>
  <!-- end class com.google.inject.assistedinject.FactoryModuleBuilder -->
  <!-- start class com.google.inject.assistedinject.FactoryProvider -->
  <class name="FactoryProvider" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="use {@link FactoryModuleBuilder} instead.">
    <implements name="com.google.inject.Provider&lt;F&gt;"/>
    <implements name="com.google.inject.spi.HasDependencies"/>
    <method name="newFactory" return="com.google.inject.Provider&lt;F&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="factoryType" type="java.lang.Class&lt;F&gt;"/>
      <param name="implementationType" type="java.lang.Class&lt;?&gt;"/>
    </method>
    <method name="newFactory" return="com.google.inject.Provider&lt;F&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="factoryType" type="com.google.inject.TypeLiteral&lt;F&gt;"/>
      <param name="implementationType" type="com.google.inject.TypeLiteral&lt;?&gt;"/>
    </method>
    <method name="getDependencies" return="java.util.Set&lt;com.google.inject.spi.Dependency&lt;?&gt;&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="get" return="F"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="obj" type="java.lang.Object"/>
    </method>
    <doc>
    <![CDATA[<strong>Obsolete.</strong> Prefer {@link FactoryModuleBuilder} for its more concise API and
 additional capability.

 <p>Provides a factory that combines the caller's arguments with injector-supplied values to
 construct objects.

 <h3>Defining a factory</h3>
 Create an interface whose methods return the constructed type, or any of its supertypes. The
 method's parameters are the arguments required to build the constructed type.
 <pre>public interface PaymentFactory {
   Payment create(Date startDate, Money amount);
 }</pre>
 You can name your factory methods whatever you like, such as <i>create</i>, <i>createPayment</i>
 or <i>newPayment</i>.

 <h3>Creating a type that accepts factory parameters</h3>
 {@code constructedType} is a concrete class with an {@literal @}{@link Inject}-annotated
 constructor. In addition to injector-supplied parameters, the constructor should have
 parameters that match each of the factory method's parameters. Each factory-supplied parameter
 requires an {@literal @}{@link Assisted} annotation. This serves to document that the parameter
 is not bound by your application's modules.
 <pre>public class RealPayment implements Payment {
   {@literal @}Inject
   public RealPayment(
      CreditService creditService,
      AuthService authService,
      <strong>{@literal @}Assisted Date startDate</strong>,
      <strong>{@literal @}Assisted Money amount</strong>) {
     ...
   }
 }</pre>
 Any parameter that permits a null value should also be annotated {@code @Nullable}.

 <h3>Configuring factories</h3>
 In your {@link com.google.inject.Module module}, bind the factory interface to the returned
 factory:
 <pre>bind(PaymentFactory.class).toProvider(
     FactoryProvider.newFactory(PaymentFactory.class, RealPayment.class));</pre>
 As a side-effect of this binding, Guice will inject the factory to initialize it for use. The
 factory cannot be used until the injector has been initialized.

 <h3>Using the factory</h3>
 Inject your factory into your application classes. When you use the factory, your arguments
 will be combined with values from the injector to construct an instance.
 <pre>public class PaymentAction {
   {@literal @}Inject private PaymentFactory paymentFactory;

   public void doPayment(Money amount) {
     Payment payment = paymentFactory.create(new Date(), amount);
     payment.apply();
   }
 }</pre>

 <h3>Making parameter types distinct</h3>
 The types of the factory method's parameters must be distinct. To use multiple parameters of
 the same type, use a named {@literal @}{@link Assisted} annotation to disambiguate the
 parameters. The names must be applied to the factory method's parameters:

 <pre>public interface PaymentFactory {
   Payment create(
       <strong>{@literal @}Assisted("startDate")</strong> Date startDate,
       <strong>{@literal @}Assisted("dueDate")</strong> Date dueDate,
       Money amount);
 } </pre>
 ...and to the concrete type's constructor parameters:
 <pre>public class RealPayment implements Payment {
   {@literal @}Inject
   public RealPayment(
      CreditService creditService,
      AuthService authService,
      <strong>{@literal @}Assisted("startDate")</strong> Date startDate,
      <strong>{@literal @}Assisted("dueDate")</strong> Date dueDate,
      <strong>{@literal @}Assisted</strong> Money amount) {
     ...
   }
 }</pre>

 <h3>Values are created by Guice</h3>
 Returned factories use child injectors to create values. The values are eligible for method
 interception. In addition, {@literal @}{@literal Inject} members will be injected before they are
 returned.

 <h3>Backwards compatibility using {@literal @}AssistedInject</h3>
 Instead of the {@literal @}Inject annotation, you may annotate the constructed classes with
 {@literal @}{@link AssistedInject}. This triggers a limited backwards-compatability mode.

 <p>Instead of matching factory method arguments to constructor parameters using their names, the
 <strong>parameters are matched by their order</strong>. The first factory method argument is
 used for the first {@literal @}Assisted constructor parameter, etc.. Annotation names have no
 effect.

 <p>Returned values are <strong>not created by Guice</strong>. These types are not eligible for
 method interception. They do receive post-construction member injection.

 @param <F> The factory interface

 @author jmourits@google.com (Jerome Mourits)
 @author jessewilson@google.com (Jesse Wilson)
 @author dtm@google.com (Daniel Martin)
 
 @deprecated use {@link FactoryModuleBuilder} instead.]]>
    </doc>
  </class>
  <!-- end class com.google.inject.assistedinject.FactoryProvider -->
</package>
<package name="com.google.inject.binder">
  <!-- start interface com.google.inject.binder.AnnotatedBindingBuilder -->
  <interface name="AnnotatedBindingBuilder"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.inject.binder.LinkedBindingBuilder&lt;T&gt;"/>
    <method name="annotatedWith" return="com.google.inject.binder.LinkedBindingBuilder&lt;T&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="annotationType" type="java.lang.Class&lt;? extends java.lang.annotation.Annotation&gt;"/>
      <doc>
      <![CDATA[See the EDSL examples at {@link com.google.inject.Binder}.]]>
      </doc>
    </method>
    <method name="annotatedWith" return="com.google.inject.binder.LinkedBindingBuilder&lt;T&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="annotation" type="java.lang.annotation.Annotation"/>
      <doc>
      <![CDATA[See the EDSL examples at {@link com.google.inject.Binder}.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[See the EDSL examples at {@link com.google.inject.Binder}.

 @author crazybob@google.com (Bob Lee)]]>
    </doc>
  </interface>
  <!-- end interface com.google.inject.binder.AnnotatedBindingBuilder -->
  <!-- start interface com.google.inject.binder.AnnotatedConstantBindingBuilder -->
  <interface name="AnnotatedConstantBindingBuilder"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="annotatedWith" return="com.google.inject.binder.ConstantBindingBuilder"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="annotationType" type="java.lang.Class&lt;? extends java.lang.annotation.Annotation&gt;"/>
      <doc>
      <![CDATA[See the EDSL examples at {@link com.google.inject.Binder}.]]>
      </doc>
    </method>
    <method name="annotatedWith" return="com.google.inject.binder.ConstantBindingBuilder"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="annotation" type="java.lang.annotation.Annotation"/>
      <doc>
      <![CDATA[See the EDSL examples at {@link com.google.inject.Binder}.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[See the EDSL examples at {@link com.google.inject.Binder}.

 @author crazybob@google.com (Bob Lee)]]>
    </doc>
  </interface>
  <!-- end interface com.google.inject.binder.AnnotatedConstantBindingBuilder -->
  <!-- start interface com.google.inject.binder.AnnotatedElementBuilder -->
  <interface name="AnnotatedElementBuilder"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="annotatedWith"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="annotationType" type="java.lang.Class&lt;? extends java.lang.annotation.Annotation&gt;"/>
      <doc>
      <![CDATA[See the EDSL examples at {@link com.google.inject.Binder}.]]>
      </doc>
    </method>
    <method name="annotatedWith"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="annotation" type="java.lang.annotation.Annotation"/>
      <doc>
      <![CDATA[See the EDSL examples at {@link com.google.inject.Binder}.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[See the EDSL examples at {@link com.google.inject.Binder}.

 @author jessewilson@google.com (Jesse Wilson)
 @since 2.0]]>
    </doc>
  </interface>
  <!-- end interface com.google.inject.binder.AnnotatedElementBuilder -->
  <!-- start interface com.google.inject.binder.ConstantBindingBuilder -->
  <interface name="ConstantBindingBuilder"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="to"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="java.lang.String"/>
      <doc>
      <![CDATA[Binds constant to the given value.]]>
      </doc>
    </method>
    <method name="to"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="int"/>
      <doc>
      <![CDATA[Binds constant to the given value.]]>
      </doc>
    </method>
    <method name="to"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="long"/>
      <doc>
      <![CDATA[Binds constant to the given value.]]>
      </doc>
    </method>
    <method name="to"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="boolean"/>
      <doc>
      <![CDATA[Binds constant to the given value.]]>
      </doc>
    </method>
    <method name="to"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="double"/>
      <doc>
      <![CDATA[Binds constant to the given value.]]>
      </doc>
    </method>
    <method name="to"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="float"/>
      <doc>
      <![CDATA[Binds constant to the given value.]]>
      </doc>
    </method>
    <method name="to"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="short"/>
      <doc>
      <![CDATA[Binds constant to the given value.]]>
      </doc>
    </method>
    <method name="to"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="char"/>
      <doc>
      <![CDATA[Binds constant to the given value.]]>
      </doc>
    </method>
    <method name="to"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="byte"/>
      <doc>
      <![CDATA[Binds constant to the given value.
 
 @since 3.0]]>
      </doc>
    </method>
    <method name="to"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="java.lang.Class&lt;?&gt;"/>
      <doc>
      <![CDATA[Binds constant to the given value.]]>
      </doc>
    </method>
    <method name="to"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="E extends java.lang.Enum&lt;E&gt;"/>
      <doc>
      <![CDATA[Binds constant to the given value.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Binds to a constant value.]]>
    </doc>
  </interface>
  <!-- end interface com.google.inject.binder.ConstantBindingBuilder -->
  <!-- start interface com.google.inject.binder.LinkedBindingBuilder -->
  <interface name="LinkedBindingBuilder"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.inject.binder.ScopedBindingBuilder"/>
    <method name="to" return="com.google.inject.binder.ScopedBindingBuilder"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="implementation" type="java.lang.Class&lt;? extends T&gt;"/>
      <doc>
      <![CDATA[See the EDSL examples at {@link com.google.inject.Binder}.]]>
      </doc>
    </method>
    <method name="to" return="com.google.inject.binder.ScopedBindingBuilder"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="implementation" type="com.google.inject.TypeLiteral&lt;? extends T&gt;"/>
      <doc>
      <![CDATA[See the EDSL examples at {@link com.google.inject.Binder}.]]>
      </doc>
    </method>
    <method name="to" return="com.google.inject.binder.ScopedBindingBuilder"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="targetKey" type="com.google.inject.Key&lt;? extends T&gt;"/>
      <doc>
      <![CDATA[See the EDSL examples at {@link com.google.inject.Binder}.]]>
      </doc>
    </method>
    <method name="toInstance"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="instance" type="T"/>
      <doc>
      <![CDATA[See the EDSL examples at {@link com.google.inject.Binder}.

 @see com.google.inject.Injector#injectMembers]]>
      </doc>
    </method>
    <method name="toProvider" return="com.google.inject.binder.ScopedBindingBuilder"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="provider" type="com.google.inject.Provider&lt;? extends T&gt;"/>
      <doc>
      <![CDATA[See the EDSL examples at {@link com.google.inject.Binder}.

 @see com.google.inject.Injector#injectMembers]]>
      </doc>
    </method>
    <method name="toProvider" return="com.google.inject.binder.ScopedBindingBuilder"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="provider" type="javax.inject.Provider&lt;? extends T&gt;"/>
      <doc>
      <![CDATA[See the EDSL examples at {@link com.google.inject.Binder}.

 @see com.google.inject.Injector#injectMembers
 @since 4.0]]>
      </doc>
    </method>
    <method name="toProvider" return="com.google.inject.binder.ScopedBindingBuilder"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="providerType" type="java.lang.Class&lt;? extends javax.inject.Provider&lt;? extends T&gt;&gt;"/>
      <doc>
      <![CDATA[See the EDSL examples at {@link com.google.inject.Binder}.]]>
      </doc>
    </method>
    <method name="toProvider" return="com.google.inject.binder.ScopedBindingBuilder"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="providerType" type="com.google.inject.TypeLiteral&lt;? extends javax.inject.Provider&lt;? extends T&gt;&gt;"/>
      <doc>
      <![CDATA[See the EDSL examples at {@link com.google.inject.Binder}.]]>
      </doc>
    </method>
    <method name="toProvider" return="com.google.inject.binder.ScopedBindingBuilder"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="providerKey" type="com.google.inject.Key&lt;? extends javax.inject.Provider&lt;? extends T&gt;&gt;"/>
      <doc>
      <![CDATA[See the EDSL examples at {@link com.google.inject.Binder}.]]>
      </doc>
    </method>
    <method name="toConstructor" return="com.google.inject.binder.ScopedBindingBuilder"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="constructor" type="java.lang.reflect.Constructor&lt;S&gt;"/>
      <doc>
      <![CDATA[See the EDSL examples at {@link com.google.inject.Binder}.
 
 @since 3.0]]>
      </doc>
    </method>
    <method name="toConstructor" return="com.google.inject.binder.ScopedBindingBuilder"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="constructor" type="java.lang.reflect.Constructor&lt;S&gt;"/>
      <param name="type" type="com.google.inject.TypeLiteral&lt;? extends S&gt;"/>
      <doc>
      <![CDATA[See the EDSL examples at {@link com.google.inject.Binder}.
 
 @since 3.0]]>
      </doc>
    </method>
    <doc>
    <![CDATA[See the EDSL examples at {@link com.google.inject.Binder}.

 @author crazybob@google.com (Bob Lee)]]>
    </doc>
  </interface>
  <!-- end interface com.google.inject.binder.LinkedBindingBuilder -->
  <!-- start interface com.google.inject.binder.ScopedBindingBuilder -->
  <interface name="ScopedBindingBuilder"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="in"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="scopeAnnotation" type="java.lang.Class&lt;? extends java.lang.annotation.Annotation&gt;"/>
      <doc>
      <![CDATA[See the EDSL examples at {@link com.google.inject.Binder}.]]>
      </doc>
    </method>
    <method name="in"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="scope" type="com.google.inject.Scope"/>
      <doc>
      <![CDATA[See the EDSL examples at {@link com.google.inject.Binder}.]]>
      </doc>
    </method>
    <method name="asEagerSingleton"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Instructs the {@link com.google.inject.Injector} to eagerly initialize this
 singleton-scoped binding upon creation. Useful for application
 initialization logic.  See the EDSL examples at
 {@link com.google.inject.Binder}.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[See the EDSL examples at {@link com.google.inject.Binder}.

 @author crazybob@google.com (Bob Lee)]]>
    </doc>
  </interface>
  <!-- end interface com.google.inject.binder.ScopedBindingBuilder -->
</package>
<package name="com.google.inject.daggeradapter">
  <!-- start class com.google.inject.daggeradapter.DaggerAdapter -->
  <class name="DaggerAdapter" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="from" return="com.google.inject.Module"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="daggerModuleObjects" type="java.lang.Object[]"/>
      <doc>
      <![CDATA[Returns a guice module from a dagger module.

 <p>Note: At present, it does not honor {@code @Module(includes=...)} directives.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A utility to adapt classes annotated with {@link @dagger.Module} such that their
 {@link @dagger.Provides} methods can be properly invoked by Guice to perform their
 provision operations.

 <p>Simple example: <pre>{@code
   Guice.createInjector(...other modules..., DaggerAdapter.from(new SomeDaggerAdapter()));
 }</pre>

 <p>Some notes on usage and compatibility.
   <ul>
     <li>Dagger provider methods have a "SET_VALUES" provision mode not supported by Guice.
     <li>MapBindings are not yet implemented (pending).
     <li>Be careful about stateful modules. In contrast to Dagger (where components are
         expected to be recreated on-demand with new Module instances), Guice typically
         has a single injector with a long lifetime, so your module instance will be used
         throughout the lifetime of the entire app.
     <li>Dagger 1.x uses {@link @Singleton} for all scopes, including shorter-lived scopes
         like per-request or per-activity.  Using modules written with Dagger 1.x usage
         in mind may result in mis-scoped objects.
     <li>Dagger 2.x supports custom scope annotations, but for use in Guice, a custom scope
         implementation must be registered in order to support the custom lifetime of that
         annotation.
   </ul>

 @author cgruber@google.com (Christian Gruber)]]>
    </doc>
  </class>
  <!-- end class com.google.inject.daggeradapter.DaggerAdapter -->
</package>
<package name="com.google.inject.grapher">
  <!-- start class com.google.inject.grapher.AbstractInjectorGrapher -->
  <class name="AbstractInjectorGrapher" extends="java.lang.Object"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.inject.grapher.InjectorGrapher"/>
    <constructor name="AbstractInjectorGrapher"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="AbstractInjectorGrapher" type="com.google.inject.grapher.AbstractInjectorGrapher.GrapherParameters"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="graph"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="injector" type="com.google.inject.Injector"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="graph"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="injector" type="com.google.inject.Injector"/>
      <param name="root" type="java.util.Set&lt;com.google.inject.Key&lt;?&gt;&gt;"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="reset"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Resets the state of the grapher before rendering a new graph.]]>
      </doc>
    </method>
    <method name="newInterfaceNode"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="node" type="com.google.inject.grapher.InterfaceNode"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Adds a new interface node to the graph.]]>
      </doc>
    </method>
    <method name="newImplementationNode"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="node" type="com.google.inject.grapher.ImplementationNode"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Adds a new implementation node to the graph.]]>
      </doc>
    </method>
    <method name="newInstanceNode"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="node" type="com.google.inject.grapher.InstanceNode"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Adds a new instance node to the graph.]]>
      </doc>
    </method>
    <method name="newDependencyEdge"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="edge" type="com.google.inject.grapher.DependencyEdge"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Adds a new dependency edge to the graph.]]>
      </doc>
    </method>
    <method name="newBindingEdge"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="edge" type="com.google.inject.grapher.BindingEdge"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Adds a new binding edge to the graph.]]>
      </doc>
    </method>
    <method name="postProcess"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Performs any post processing required after all nodes and edges have been added.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Abstract injector grapher that builds the dependency graph but doesn't render it.

 @author bojand@google.com (Bojan Djordjevic)
 @since 4.0]]>
    </doc>
  </class>
  <!-- end class com.google.inject.grapher.AbstractInjectorGrapher -->
  <!-- start class com.google.inject.grapher.AbstractInjectorGrapher.GrapherParameters -->
  <class name="AbstractInjectorGrapher.GrapherParameters" extends="java.lang.Object"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="GrapherParameters"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getRootKeySetCreator" return="com.google.inject.grapher.RootKeySetCreator"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setRootKeySetCreator" return="com.google.inject.grapher.AbstractInjectorGrapher.GrapherParameters"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="rootKeySetCreator" type="com.google.inject.grapher.RootKeySetCreator"/>
    </method>
    <method name="getAliasCreator" return="com.google.inject.grapher.AliasCreator"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setAliasCreator" return="com.google.inject.grapher.AbstractInjectorGrapher.GrapherParameters"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="aliasCreator" type="com.google.inject.grapher.AliasCreator"/>
    </method>
    <method name="getNodeCreator" return="com.google.inject.grapher.NodeCreator"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setNodeCreator" return="com.google.inject.grapher.AbstractInjectorGrapher.GrapherParameters"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="nodeCreator" type="com.google.inject.grapher.NodeCreator"/>
    </method>
    <method name="getEdgeCreator" return="com.google.inject.grapher.EdgeCreator"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setEdgeCreator" return="com.google.inject.grapher.AbstractInjectorGrapher.GrapherParameters"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="edgeCreator" type="com.google.inject.grapher.EdgeCreator"/>
    </method>
    <doc>
    <![CDATA[Parameters used to override default settings of the grapher.
 @since 4.0]]>
    </doc>
  </class>
  <!-- end class com.google.inject.grapher.AbstractInjectorGrapher.GrapherParameters -->
  <!-- start class com.google.inject.grapher.Alias -->
  <class name="Alias" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="Alias" type="com.google.inject.grapher.NodeId, com.google.inject.grapher.NodeId"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getFromId" return="com.google.inject.grapher.NodeId"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getToId" return="com.google.inject.grapher.NodeId"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Alias between two nodes. Causes the 'from' node to be aliased with the 'to' node, which means
 that the 'from' node is not rendered and all edges going to it instead go to the 'to' node.

 @author bojand@google.com (Bojan Djordjevic)
 @since 4.0]]>
    </doc>
  </class>
  <!-- end class com.google.inject.grapher.Alias -->
  <!-- start interface com.google.inject.grapher.AliasCreator -->
  <interface name="AliasCreator"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="createAliases" return="java.lang.Iterable&lt;com.google.inject.grapher.Alias&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="bindings" type="java.lang.Iterable&lt;com.google.inject.Binding&lt;?&gt;&gt;"/>
      <doc>
      <![CDATA[Returns aliases for the given dependency graph. The aliases do not need to be transitively
 resolved, i.e. it is valid to return an alias (X to Y) and an alias (Y to Z). It is the
 responsibility of the caller to resolve this to (X to Z) and (Y to Z).

 @param bindings bindings that make up the dependency graph
 @return aliases that should be applied on the graph]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Creator of node aliases. Used by dependency graphers to merge nodes in the internal Guice graph
 into a single node on the rendered graph.

 @author bojand@google.com (Bojan Djordjevic)
 @since 4.0]]>
    </doc>
  </interface>
  <!-- end interface com.google.inject.grapher.AliasCreator -->
  <!-- start class com.google.inject.grapher.BindingEdge -->
  <class name="BindingEdge" extends="com.google.inject.grapher.Edge"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="BindingEdge" type="com.google.inject.grapher.NodeId, com.google.inject.grapher.NodeId, com.google.inject.grapher.BindingEdge.Type"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getType" return="com.google.inject.grapher.BindingEdge.Type"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="obj" type="java.lang.Object"/>
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="copy" return="com.google.inject.grapher.Edge"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="fromId" type="com.google.inject.grapher.NodeId"/>
      <param name="toId" type="com.google.inject.grapher.NodeId"/>
    </method>
    <doc>
    <![CDATA[Edge that connects an interface to the type or instance that is bound to implement it.

 @author phopkins@gmail.com (Pete Hopkins)
 @since 4.0 (since 2.0 as an interface)]]>
    </doc>
  </class>
  <!-- end class com.google.inject.grapher.BindingEdge -->
  <!-- start class com.google.inject.grapher.BindingEdge.Type -->
  <class name="BindingEdge.Type" extends="java.lang.Enum&lt;com.google.inject.grapher.BindingEdge.Type&gt;"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="values" return="com.google.inject.grapher.BindingEdge.Type[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="com.google.inject.grapher.BindingEdge.Type"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <doc>
    <![CDATA[Classification for what kind of binding this edge represents.]]>
    </doc>
  </class>
  <!-- end class com.google.inject.grapher.BindingEdge.Type -->
  <!-- start class com.google.inject.grapher.DefaultRootKeySetCreator -->
  <class name="DefaultRootKeySetCreator" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.inject.grapher.RootKeySetCreator"/>
    <constructor name="DefaultRootKeySetCreator"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getRootKeys" return="java.util.Set&lt;com.google.inject.Key&lt;?&gt;&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="injector" type="com.google.inject.Injector"/>
    </method>
    <doc>
    <![CDATA[Root key set creator that starts with all types that are not Guice internal types or the
 {@link Logger} type.

 @author bojand@google.com (Bojan Djordjevic)
 @since 4.0]]>
    </doc>
  </class>
  <!-- end class com.google.inject.grapher.DefaultRootKeySetCreator -->
  <!-- start class com.google.inject.grapher.DependencyEdge -->
  <class name="DependencyEdge" extends="com.google.inject.grapher.Edge"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="DependencyEdge" type="com.google.inject.grapher.NodeId, com.google.inject.grapher.NodeId, com.google.inject.spi.InjectionPoint"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getInjectionPoint" return="com.google.inject.spi.InjectionPoint"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="obj" type="java.lang.Object"/>
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="copy" return="com.google.inject.grapher.Edge"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="fromId" type="com.google.inject.grapher.NodeId"/>
      <param name="toId" type="com.google.inject.grapher.NodeId"/>
    </method>
    <doc>
    <![CDATA[Edge from a class or {@link InjectionPoint} to the interface node that will satisfy the
 dependency.

 @author phopkins@gmail.com (Pete Hopkins)
 @since 4.0 (since 2.0 as an interface)]]>
    </doc>
  </class>
  <!-- end class com.google.inject.grapher.DependencyEdge -->
  <!-- start class com.google.inject.grapher.Edge -->
  <class name="Edge" extends="java.lang.Object"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="Edge" type="com.google.inject.grapher.NodeId, com.google.inject.grapher.NodeId"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </constructor>
    <method name="getFromId" return="com.google.inject.grapher.NodeId"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getToId" return="com.google.inject.grapher.NodeId"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="obj" type="java.lang.Object"/>
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="copy" return="com.google.inject.grapher.Edge"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="fromId" type="com.google.inject.grapher.NodeId"/>
      <param name="toId" type="com.google.inject.grapher.NodeId"/>
      <doc>
      <![CDATA[Returns a copy of the edge with new node IDs.

 @param fromId new ID of the 'from' node
 @param toId new ID of the 'to' node
 @return copy of the edge with the new node IDs]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Edge in a guice dependency graph.

 @author bojand@google.com (Bojan Djordjevic)
 @since 4.0]]>
    </doc>
  </class>
  <!-- end class com.google.inject.grapher.Edge -->
  <!-- start interface com.google.inject.grapher.EdgeCreator -->
  <interface name="EdgeCreator"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="getEdges" return="java.lang.Iterable&lt;com.google.inject.grapher.Edge&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="bindings" type="java.lang.Iterable&lt;com.google.inject.Binding&lt;?&gt;&gt;"/>
      <doc>
      <![CDATA[Returns edges for the given dependency graph.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Creator of graph edges to render. All edges will be rendered on the graph after node aliasing is
 performed.

 @author bojand@google.com (Bojan Djordjevic)
 @since 4.0]]>
    </doc>
  </interface>
  <!-- end interface com.google.inject.grapher.EdgeCreator -->
  <!-- start class com.google.inject.grapher.ImplementationNode -->
  <class name="ImplementationNode" extends="com.google.inject.grapher.Node"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="ImplementationNode" type="com.google.inject.grapher.NodeId, java.lang.Object, java.util.Collection&lt;java.lang.reflect.Member&gt;"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getMembers" return="java.util.Collection&lt;java.lang.reflect.Member&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="obj" type="java.lang.Object"/>
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="copy" return="com.google.inject.grapher.Node"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="id" type="com.google.inject.grapher.NodeId"/>
    </method>
    <doc>
    <![CDATA[Node for types that have {@link com.google.inject.spi.Dependency}s and are
 bound to {@link InterfaceNode}s. These nodes will often have fields for
 {@link Member}s that are {@link com.google.inject.spi.InjectionPoint}s.

 @see DependencyEdge
 @author phopkins@gmail.com (Pete Hopkins)
 @since 4.0 (since 2.0 as an interface)]]>
    </doc>
  </class>
  <!-- end class com.google.inject.grapher.ImplementationNode -->
  <!-- start interface com.google.inject.grapher.InjectorGrapher -->
  <interface name="InjectorGrapher"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="graph"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="injector" type="com.google.inject.Injector"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Graphs the guice dependency graph for the given injector using default starting keys.]]>
      </doc>
    </method>
    <method name="graph"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="injector" type="com.google.inject.Injector"/>
      <param name="root" type="java.util.Set&lt;com.google.inject.Key&lt;?&gt;&gt;"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Graphs the guice dependency graph for the given injector using the given starting keys and
 their transitive dependencies.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Guice injector grapher. Renders the guice dependency graph for an injector. It can render the
 whole dependency graph or just transitive dependencies of a given set of nodes.

 @author phopkins@gmail.com (Pete Hopkins)
 @since 4.0 (since 2.0 as a concrete class with a different API)]]>
    </doc>
  </interface>
  <!-- end interface com.google.inject.grapher.InjectorGrapher -->
  <!-- start class com.google.inject.grapher.InstanceNode -->
  <class name="InstanceNode" extends="com.google.inject.grapher.Node"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="InstanceNode" type="com.google.inject.grapher.NodeId, java.lang.Object, java.lang.Object, java.lang.Iterable&lt;java.lang.reflect.Member&gt;"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getInstance" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getMembers" return="java.lang.Iterable&lt;java.lang.reflect.Member&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="obj" type="java.lang.Object"/>
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="copy" return="com.google.inject.grapher.Node"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="id" type="com.google.inject.grapher.NodeId"/>
    </method>
    <doc>
    <![CDATA[Node for instances. Used when a type is bound to an instance.

 @author bojand@google.com (Bojan Djordjevic)
 @since 4.0]]>
    </doc>
  </class>
  <!-- end class com.google.inject.grapher.InstanceNode -->
  <!-- start class com.google.inject.grapher.InterfaceNode -->
  <class name="InterfaceNode" extends="com.google.inject.grapher.Node"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="InterfaceNode" type="com.google.inject.grapher.NodeId, java.lang.Object"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="copy" return="com.google.inject.grapher.Node"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="id" type="com.google.inject.grapher.NodeId"/>
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="obj" type="java.lang.Object"/>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Node for an interface type that has been bound to an implementation class or instance.

 @see BindingEdge
 @author phopkins@gmail.com (Pete Hopkins)
 @since 4.0 (since 2.0 as an interface)]]>
    </doc>
  </class>
  <!-- end class com.google.inject.grapher.InterfaceNode -->
  <!-- start interface com.google.inject.grapher.NameFactory -->
  <interface name="NameFactory"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="getMemberName" return="java.lang.String"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="member" type="java.lang.reflect.Member"/>
    </method>
    <method name="getClassName" return="java.lang.String"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="com.google.inject.Key&lt;?&gt;"/>
    </method>
    <method name="getInstanceName" return="java.lang.String"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="instance" type="java.lang.Object"/>
    </method>
    <method name="getAnnotationName" return="java.lang.String"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="com.google.inject.Key&lt;?&gt;"/>
    </method>
    <method name="getSourceName" return="java.lang.String"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="source" type="java.lang.Object"/>
    </method>
    <doc>
    <![CDATA[Interface for a service that provides nice {@link String}s that we can
 display in the graph for the types that come up in
 {@link com.google.inject.Binding}s.

 @author phopkins@gmail.com (Pete Hopkins)]]>
    </doc>
  </interface>
  <!-- end interface com.google.inject.grapher.NameFactory -->
  <!-- start class com.google.inject.grapher.Node -->
  <class name="Node" extends="java.lang.Object"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="Node" type="com.google.inject.grapher.NodeId, java.lang.Object"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </constructor>
    <method name="getId" return="com.google.inject.grapher.NodeId"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getSource" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="obj" type="java.lang.Object"/>
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="copy" return="com.google.inject.grapher.Node"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="id" type="com.google.inject.grapher.NodeId"/>
      <doc>
      <![CDATA[Returns a copy of the node with a new ID.

 @param id new ID of the node
 @return copy of the node with a new ID]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Node in a guice dependency graph.

 @author bojand@google.com (Bojan Djordjevic)
 @since 4.0]]>
    </doc>
  </class>
  <!-- end class com.google.inject.grapher.Node -->
  <!-- start interface com.google.inject.grapher.NodeCreator -->
  <interface name="NodeCreator"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="getNodes" return="java.lang.Iterable&lt;com.google.inject.grapher.Node&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="bindings" type="java.lang.Iterable&lt;com.google.inject.Binding&lt;?&gt;&gt;"/>
      <doc>
      <![CDATA[Returns nodes for the given dependency graph.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Creator of graph nodes.

 @author bojand@google.com (Bojan Djordjevic)
 @since 4.0]]>
    </doc>
  </interface>
  <!-- end interface com.google.inject.grapher.NodeCreator -->
  <!-- start class com.google.inject.grapher.NodeId -->
  <class name="NodeId" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="newTypeId" return="com.google.inject.grapher.NodeId"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="com.google.inject.Key&lt;?&gt;"/>
    </method>
    <method name="newInstanceId" return="com.google.inject.grapher.NodeId"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="com.google.inject.Key&lt;?&gt;"/>
    </method>
    <method name="getKey" return="com.google.inject.Key&lt;?&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="obj" type="java.lang.Object"/>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[ID of a node in the graph. An ID is given by a {@link Key} and a node type, which is used to
 distinguish instances and implementation classes for the same key. For example
 {@code bind(Integer.class).toInstance(42)} produces two nodes: an
 interface node with the key of {@code Key<Integer>} and an instance node with the same
 {@link Key} and value of 42.

 @author bojand@google.com (Bojan Djordjevic)
 @since 4.0]]>
    </doc>
  </class>
  <!-- end class com.google.inject.grapher.NodeId -->
  <!-- start class com.google.inject.grapher.NodeId.NodeType -->
  <class name="NodeId.NodeType" extends="java.lang.Enum&lt;com.google.inject.grapher.NodeId.NodeType&gt;"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="values" return="com.google.inject.grapher.NodeId.NodeType[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="com.google.inject.grapher.NodeId.NodeType"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <doc>
    <![CDATA[Type of node.

 @since 4.0]]>
    </doc>
  </class>
  <!-- end class com.google.inject.grapher.NodeId.NodeType -->
  <!-- start interface com.google.inject.grapher.RootKeySetCreator -->
  <interface name="RootKeySetCreator"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="getRootKeys" return="java.util.Set&lt;com.google.inject.Key&lt;?&gt;&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="injector" type="com.google.inject.Injector"/>
      <doc>
      <![CDATA[Returns the set of starting keys to graph.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Creator of the default starting set of keys to graph. These keys and their transitive
 dependencies will be graphed.

 @author bojand@google.com (Bojan Djordjevic)
 @since 4.0]]>
    </doc>
  </interface>
  <!-- end interface com.google.inject.grapher.RootKeySetCreator -->
  <!-- start class com.google.inject.grapher.ShortNameFactory -->
  <class name="ShortNameFactory" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.inject.grapher.NameFactory"/>
    <constructor name="ShortNameFactory"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getMemberName" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="member" type="java.lang.reflect.Member"/>
    </method>
    <method name="getAnnotationName" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="com.google.inject.Key&lt;?&gt;"/>
    </method>
    <method name="getClassName" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="com.google.inject.Key&lt;?&gt;"/>
    </method>
    <method name="getInstanceName" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="instance" type="java.lang.Object"/>
    </method>
    <method name="getSourceName" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="source" type="java.lang.Object"/>
      <doc>
      <![CDATA[Returns a name for a Guice "source" object. This will typically be either
 a {@link StackTraceElement} for when the binding is made to the instance,
 or a {@link Method} when a provider method is used.]]>
      </doc>
    </method>
    <method name="getFileString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="stackTraceElement" type="java.lang.StackTraceElement"/>
    </method>
    <method name="getMethodString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="method" type="java.lang.reflect.Method"/>
    </method>
    <doc>
    <![CDATA[Reasonable implementation for {@link NameFactory}. Mostly takes various
 {@link Object#toString()}s and strips package names out of them so that
 they'll fit on the graph.

 @author phopkins@gmail.com (Pete Hopkins)]]>
    </doc>
  </class>
  <!-- end class com.google.inject.grapher.ShortNameFactory -->
  <!-- start class com.google.inject.grapher.TransitiveDependencyVisitor -->
  <class name="TransitiveDependencyVisitor" extends="com.google.inject.spi.DefaultBindingTargetVisitor&lt;java.lang.Object, java.util.Collection&lt;com.google.inject.Key&lt;?&gt;&gt;&gt;"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="TransitiveDependencyVisitor"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="visit" return="java.util.Collection&lt;com.google.inject.Key&lt;?&gt;&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="binding" type="com.google.inject.spi.ConstructorBinding&lt;?&gt;"/>
    </method>
    <method name="visit" return="java.util.Collection&lt;com.google.inject.Key&lt;?&gt;&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="binding" type="com.google.inject.spi.ConvertedConstantBinding&lt;?&gt;"/>
    </method>
    <method name="visit" return="java.util.Collection&lt;com.google.inject.Key&lt;?&gt;&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="binding" type="com.google.inject.spi.InstanceBinding&lt;?&gt;"/>
    </method>
    <method name="visit" return="java.util.Collection&lt;com.google.inject.Key&lt;?&gt;&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="binding" type="com.google.inject.spi.LinkedKeyBinding&lt;?&gt;"/>
    </method>
    <method name="visit" return="java.util.Collection&lt;com.google.inject.Key&lt;?&gt;&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="binding" type="com.google.inject.spi.ProviderBinding&lt;?&gt;"/>
    </method>
    <method name="visit" return="java.util.Collection&lt;com.google.inject.Key&lt;?&gt;&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="binding" type="com.google.inject.spi.ProviderInstanceBinding&lt;?&gt;"/>
    </method>
    <method name="visit" return="java.util.Collection&lt;com.google.inject.Key&lt;?&gt;&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="binding" type="com.google.inject.spi.ProviderKeyBinding&lt;?&gt;"/>
    </method>
    <method name="visitOther" return="java.util.Collection&lt;com.google.inject.Key&lt;?&gt;&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="binding" type="com.google.inject.Binding&lt;?&gt;"/>
      <doc>
      <![CDATA[@since 4.0]]>
      </doc>
    </method>
    <doc>
    <![CDATA[{@link com.google.inject.spi.BindingTargetVisitor} that returns a
 {@link Collection} of the {@link Key}s of each {@link Binding}'s
 dependencies. Used by {@link InjectorGrapher} to walk the dependency graph
 from a starting set of {@link Binding}s.

 @author phopkins@gmail.com (Pete Hopkins)]]>
    </doc>
  </class>
  <!-- end class com.google.inject.grapher.TransitiveDependencyVisitor -->
</package>
<package name="com.google.inject.grapher.graphviz">
  <!-- start class com.google.inject.grapher.graphviz.ArrowType -->
  <class name="ArrowType" extends="java.lang.Enum&lt;com.google.inject.grapher.graphviz.ArrowType&gt;"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="values" return="com.google.inject.grapher.graphviz.ArrowType[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="com.google.inject.grapher.graphviz.ArrowType"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Arrow symbols that are available from Graphviz. These can be composed by
 concatenation to make double arrows and such.
 <p>
 See: http://www.graphviz.org/doc/info/arrows.html

 @author phopkins@gmail.com (Pete Hopkins)]]>
    </doc>
  </class>
  <!-- end class com.google.inject.grapher.graphviz.ArrowType -->
  <!-- start class com.google.inject.grapher.graphviz.CompassPoint -->
  <class name="CompassPoint" extends="java.lang.Enum&lt;com.google.inject.grapher.graphviz.CompassPoint&gt;"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="values" return="com.google.inject.grapher.graphviz.CompassPoint[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="com.google.inject.grapher.graphviz.CompassPoint"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Enum for the "compass point" values used to control where edge
 end points appear on the graph.
 <p>
 See: http://www.graphviz.org/doc/info/attrs.html#k:portPos

 @author phopkins@gmail.com (Pete Hopkins)]]>
    </doc>
  </class>
  <!-- end class com.google.inject.grapher.graphviz.CompassPoint -->
  <!-- start class com.google.inject.grapher.graphviz.EdgeStyle -->
  <class name="EdgeStyle" extends="java.lang.Enum&lt;com.google.inject.grapher.graphviz.EdgeStyle&gt;"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="values" return="com.google.inject.grapher.graphviz.EdgeStyle[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="com.google.inject.grapher.graphviz.EdgeStyle"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Styles for edges.
 <p>
 See: http://www.graphviz.org/doc/info/attrs.html#k:style

 @author phopkins@gmail.com (Pete Hopkins)]]>
    </doc>
  </class>
  <!-- end class com.google.inject.grapher.graphviz.EdgeStyle -->
  <!-- start class com.google.inject.grapher.graphviz.GraphvizEdge -->
  <class name="GraphvizEdge" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="GraphvizEdge" type="com.google.inject.grapher.NodeId, com.google.inject.grapher.NodeId"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getHeadNodeId" return="com.google.inject.grapher.NodeId"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@since 4.0]]>
      </doc>
    </method>
    <method name="getHeadPortId" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setHeadPortId"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="headPortId" type="java.lang.String"/>
    </method>
    <method name="getHeadCompassPoint" return="com.google.inject.grapher.graphviz.CompassPoint"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setHeadCompassPoint"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="headCompassPoint" type="com.google.inject.grapher.graphviz.CompassPoint"/>
    </method>
    <method name="getArrowHead" return="java.util.List&lt;com.google.inject.grapher.graphviz.ArrowType&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setArrowHead"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="arrowHead" type="java.util.List&lt;com.google.inject.grapher.graphviz.ArrowType&gt;"/>
    </method>
    <method name="getTailNodeId" return="com.google.inject.grapher.NodeId"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@since 4.0]]>
      </doc>
    </method>
    <method name="getTailPortId" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setTailPortId"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="tailPortId" type="java.lang.String"/>
    </method>
    <method name="getTailCompassPoint" return="com.google.inject.grapher.graphviz.CompassPoint"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setTailCompassPoint"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="tailCompassPoint" type="com.google.inject.grapher.graphviz.CompassPoint"/>
    </method>
    <method name="getArrowTail" return="java.util.List&lt;com.google.inject.grapher.graphviz.ArrowType&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setArrowTail"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="arrowTail" type="java.util.List&lt;com.google.inject.grapher.graphviz.ArrowType&gt;"/>
    </method>
    <method name="getStyle" return="com.google.inject.grapher.graphviz.EdgeStyle"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setStyle"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="style" type="com.google.inject.grapher.graphviz.EdgeStyle"/>
    </method>
    <doc>
    <![CDATA[Data object to encapsulate the attributes of Graphviz edges that we're
 interested in drawing.

 @author phopkins@gmail.com (Pete Hopkins)]]>
    </doc>
  </class>
  <!-- end class com.google.inject.grapher.graphviz.GraphvizEdge -->
  <!-- start class com.google.inject.grapher.graphviz.GraphvizGrapher -->
  <class name="GraphvizGrapher" extends="com.google.inject.grapher.AbstractInjectorGrapher"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="reset"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </method>
    <method name="setOut"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="out" type="java.io.PrintWriter"/>
    </method>
    <method name="setRankdir"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="rankdir" type="java.lang.String"/>
    </method>
    <method name="postProcess"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </method>
    <method name="getGraphAttributes" return="java.util.Map&lt;java.lang.String, java.lang.String&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </method>
    <method name="start"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </method>
    <method name="finish"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </method>
    <method name="renderNode"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="node" type="com.google.inject.grapher.graphviz.GraphvizNode"/>
    </method>
    <method name="getNodeAttributes" return="java.util.Map&lt;java.lang.String, java.lang.String&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="node" type="com.google.inject.grapher.graphviz.GraphvizNode"/>
    </method>
    <method name="getNodeLabel" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="node" type="com.google.inject.grapher.graphviz.GraphvizNode"/>
      <doc>
      <![CDATA[Creates the "label" for a node. This is a string of HTML that defines a
 table with a heading at the top and (in the case of
 {@link ImplementationNode}s) rows for each of the member fields.]]>
      </doc>
    </method>
    <method name="renderEdge"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="edge" type="com.google.inject.grapher.graphviz.GraphvizEdge"/>
    </method>
    <method name="getEdgeAttributes" return="java.util.Map&lt;java.lang.String, java.lang.String&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="edge" type="com.google.inject.grapher.graphviz.GraphvizEdge"/>
    </method>
    <method name="getArrowString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="arrows" type="java.util.List&lt;com.google.inject.grapher.graphviz.ArrowType&gt;"/>
      <doc>
      <![CDATA[Turns a {@link List} of {@link ArrowType}s into a {@link String} that
 represents combining them. With Graphviz, that just means concatenating
 them.]]>
      </doc>
    </method>
    <method name="getEdgeEndPoint" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="nodeId" type="java.lang.String"/>
      <param name="portId" type="java.lang.String"/>
      <param name="compassPoint" type="com.google.inject.grapher.graphviz.CompassPoint"/>
    </method>
    <method name="htmlEscape" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="str" type="java.lang.String"/>
    </method>
    <method name="htmlEscape" return="java.util.List&lt;java.lang.String&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="elements" type="java.util.List&lt;java.lang.String&gt;"/>
    </method>
    <method name="newInterfaceNode"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="node" type="com.google.inject.grapher.InterfaceNode"/>
    </method>
    <method name="newImplementationNode"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="node" type="com.google.inject.grapher.ImplementationNode"/>
    </method>
    <method name="newInstanceNode"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="node" type="com.google.inject.grapher.InstanceNode"/>
    </method>
    <method name="newDependencyEdge"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="edge" type="com.google.inject.grapher.DependencyEdge"/>
    </method>
    <method name="newBindingEdge"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="edge" type="com.google.inject.grapher.BindingEdge"/>
    </method>
    <doc>
    <![CDATA[{@link com.google.inject.grapher.InjectorGrapher} implementation that writes out a Graphviz DOT
 file of the graph. Dependencies are bound in {@link GraphvizModule}.
 <p>
 Specify the {@link PrintWriter} to output to with {@link #setOut(PrintWriter)}.

 @author phopkins@gmail.com (Pete Hopkins)
 @since 4.0]]>
    </doc>
  </class>
  <!-- end class com.google.inject.grapher.graphviz.GraphvizGrapher -->
  <!-- start class com.google.inject.grapher.graphviz.GraphvizModule -->
  <class name="GraphvizModule" extends="com.google.inject.AbstractModule"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="GraphvizModule"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="configure"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Module that provides classes needed by {@link GraphvizGrapher}.

 @author phopkins@gmail.com (Pete Hopkins)]]>
    </doc>
  </class>
  <!-- end class com.google.inject.grapher.graphviz.GraphvizModule -->
  <!-- start class com.google.inject.grapher.graphviz.GraphvizNode -->
  <class name="GraphvizNode" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="GraphvizNode" type="com.google.inject.grapher.NodeId"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@since 4.0]]>
      </doc>
    </constructor>
    <method name="getNodeId" return="com.google.inject.grapher.NodeId"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@since 4.0]]>
      </doc>
    </method>
    <method name="getShape" return="com.google.inject.grapher.graphviz.NodeShape"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setShape"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="shape" type="com.google.inject.grapher.graphviz.NodeShape"/>
    </method>
    <method name="getStyle" return="com.google.inject.grapher.graphviz.NodeStyle"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setStyle"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="style" type="com.google.inject.grapher.graphviz.NodeStyle"/>
    </method>
    <method name="getTitle" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setTitle"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="title" type="java.lang.String"/>
    </method>
    <method name="getSubtitles" return="java.util.List&lt;java.lang.String&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="addSubtitle"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="position" type="int"/>
      <param name="subtitle" type="java.lang.String"/>
    </method>
    <method name="getHeaderTextColor" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setHeaderTextColor"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="headerTextColor" type="java.lang.String"/>
    </method>
    <method name="getHeaderBackgroundColor" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setHeaderBackgroundColor"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="headerBackgroundColor" type="java.lang.String"/>
    </method>
    <method name="addField"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="portId" type="java.lang.String"/>
      <param name="title" type="java.lang.String"/>
    </method>
    <method name="getFields" return="java.util.Map&lt;java.lang.String, java.lang.String&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getIdentifier" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@since 4.0]]>
      </doc>
    </method>
    <method name="setIdentifier"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="identifier" type="java.lang.String"/>
      <doc>
      <![CDATA[@since 4.0]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Data object to encapsulate the attributes of Graphviz nodes that we're
 interested in drawing.

 @author phopkins@gmail.com (Pete Hopkins)]]>
    </doc>
  </class>
  <!-- end class com.google.inject.grapher.graphviz.GraphvizNode -->
  <!-- start class com.google.inject.grapher.graphviz.NodeShape -->
  <class name="NodeShape" extends="java.lang.Enum&lt;com.google.inject.grapher.graphviz.NodeShape&gt;"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="values" return="com.google.inject.grapher.graphviz.NodeShape[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="com.google.inject.grapher.graphviz.NodeShape"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Enum for the shapes that are most interesting for Guice graphing.
 <p>
 See: http://www.graphviz.org/doc/info/shapes.html
 
 @author phopkins@gmail.com (Pete Hopkins)]]>
    </doc>
  </class>
  <!-- end class com.google.inject.grapher.graphviz.NodeShape -->
  <!-- start class com.google.inject.grapher.graphviz.NodeStyle -->
  <class name="NodeStyle" extends="java.lang.Enum&lt;com.google.inject.grapher.graphviz.NodeStyle&gt;"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="values" return="com.google.inject.grapher.graphviz.NodeStyle[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="com.google.inject.grapher.graphviz.NodeStyle"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Styles for nodes. Similar to {@link EdgeStyle} but with a few more options.
 <p>
 See: http://www.graphviz.org/doc/info/attrs.html#k:style

 @author phopkins@gmail.com (Pete Hopkins)]]>
    </doc>
  </class>
  <!-- end class com.google.inject.grapher.graphviz.NodeStyle -->
  <!-- start interface com.google.inject.grapher.graphviz.PortIdFactory -->
  <interface name="PortIdFactory"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="getPortId" return="java.lang.String"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="member" type="java.lang.reflect.Member"/>
    </method>
    <doc>
    <![CDATA[Interface for a service that returns Graphviz port IDs, used for naming the
 rows in {@link com.google.inject.grapher.ImplementationNode}-displaying {@link GraphvizNode}s.

 @author phopkins@gmail.com (Pete Hopkins)]]>
    </doc>
  </interface>
  <!-- end interface com.google.inject.grapher.graphviz.PortIdFactory -->
  <!-- start class com.google.inject.grapher.graphviz.PortIdFactoryImpl -->
  <class name="PortIdFactoryImpl" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.inject.grapher.graphviz.PortIdFactory"/>
    <constructor name="PortIdFactoryImpl"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getPortId" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="member" type="java.lang.reflect.Member"/>
    </method>
    <doc>
    <![CDATA[Implementation of {@link PortIdFactory}. Bound in {@link GraphvizModule}.

 @author phopkins@gmail.com (Pete Hopkins)]]>
    </doc>
  </class>
  <!-- end class com.google.inject.grapher.graphviz.PortIdFactoryImpl -->
</package>
<package name="com.google.inject.jndi">
  <!-- start class com.google.inject.jndi.JndiIntegration -->
  <class name="JndiIntegration" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="fromJndi" return="com.google.inject.Provider&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="java.lang.Class&lt;T&gt;"/>
      <param name="name" type="java.lang.String"/>
      <doc>
      <![CDATA[Creates a provider which looks up objects in JNDI using the given name.
 Example usage:

 <pre>
 bind(DataSource.class).toProvider(fromJndi(DataSource.class, "java:..."));
 </pre>]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Integrates Guice with JNDI. Requires a binding to 
 {@link javax.naming.Context}.

 @author crazybob@google.com (Bob Lee)]]>
    </doc>
  </class>
  <!-- end class com.google.inject.jndi.JndiIntegration -->
</package>
<package name="com.google.inject.matcher">
  <!-- start class com.google.inject.matcher.AbstractMatcher -->
  <class name="AbstractMatcher" extends="java.lang.Object"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.inject.matcher.Matcher&lt;T&gt;"/>
    <constructor name="AbstractMatcher"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="and" return="com.google.inject.matcher.Matcher&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="other" type="com.google.inject.matcher.Matcher&lt;? super T&gt;"/>
    </method>
    <method name="or" return="com.google.inject.matcher.Matcher&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="other" type="com.google.inject.matcher.Matcher&lt;? super T&gt;"/>
    </method>
    <doc>
    <![CDATA[Implements {@code and()} and {@code or()}.

 @author crazybob@google.com (Bob Lee)]]>
    </doc>
  </class>
  <!-- end class com.google.inject.matcher.AbstractMatcher -->
  <!-- start interface com.google.inject.matcher.Matcher -->
  <interface name="Matcher"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="matches" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="t" type="T"/>
      <doc>
      <![CDATA[Returns {@code true} if this matches {@code t}, {@code false} otherwise.]]>
      </doc>
    </method>
    <method name="and" return="com.google.inject.matcher.Matcher&lt;T&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="other" type="com.google.inject.matcher.Matcher&lt;? super T&gt;"/>
      <doc>
      <![CDATA[Returns a new matcher which returns {@code true} if both this and the
 given matcher return {@code true}.]]>
      </doc>
    </method>
    <method name="or" return="com.google.inject.matcher.Matcher&lt;T&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="other" type="com.google.inject.matcher.Matcher&lt;? super T&gt;"/>
      <doc>
      <![CDATA[Returns a new matcher which returns {@code true} if either this or the
 given matcher return {@code true}.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Returns {@code true} or {@code false} for a given input.

 @author crazybob@google.com (Bob Lee)]]>
    </doc>
  </interface>
  <!-- end interface com.google.inject.matcher.Matcher -->
  <!-- start class com.google.inject.matcher.Matchers -->
  <class name="Matchers" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="any" return="com.google.inject.matcher.Matcher&lt;java.lang.Object&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a matcher which matches any input.]]>
      </doc>
    </method>
    <method name="not" return="com.google.inject.matcher.Matcher&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="p" type="com.google.inject.matcher.Matcher&lt;? super T&gt;"/>
      <doc>
      <![CDATA[Inverts the given matcher.]]>
      </doc>
    </method>
    <method name="annotatedWith" return="com.google.inject.matcher.Matcher&lt;java.lang.reflect.AnnotatedElement&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="annotationType" type="java.lang.Class&lt;? extends java.lang.annotation.Annotation&gt;"/>
      <doc>
      <![CDATA[Returns a matcher which matches elements (methods, classes, etc.)
 with a given annotation.]]>
      </doc>
    </method>
    <method name="annotatedWith" return="com.google.inject.matcher.Matcher&lt;java.lang.reflect.AnnotatedElement&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="annotation" type="java.lang.annotation.Annotation"/>
      <doc>
      <![CDATA[Returns a matcher which matches elements (methods, classes, etc.)
 with a given annotation.]]>
      </doc>
    </method>
    <method name="subclassesOf" return="com.google.inject.matcher.Matcher&lt;java.lang.Class&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="superclass" type="java.lang.Class&lt;?&gt;"/>
      <doc>
      <![CDATA[Returns a matcher which matches subclasses of the given type (as well as
 the given type).]]>
      </doc>
    </method>
    <method name="only" return="com.google.inject.matcher.Matcher&lt;java.lang.Object&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="java.lang.Object"/>
      <doc>
      <![CDATA[Returns a matcher which matches objects equal to the given object.]]>
      </doc>
    </method>
    <method name="identicalTo" return="com.google.inject.matcher.Matcher&lt;java.lang.Object&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="java.lang.Object"/>
      <doc>
      <![CDATA[Returns a matcher which matches only the given object.]]>
      </doc>
    </method>
    <method name="inPackage" return="com.google.inject.matcher.Matcher&lt;java.lang.Class&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="targetPackage" type="java.lang.Package"/>
      <doc>
      <![CDATA[Returns a matcher which matches classes in the given package. Packages are specific to their
 classloader, so classes with the same package name may not have the same package at runtime.]]>
      </doc>
    </method>
    <method name="inSubpackage" return="com.google.inject.matcher.Matcher&lt;java.lang.Class&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="targetPackageName" type="java.lang.String"/>
      <doc>
      <![CDATA[Returns a matcher which matches classes in the given package and its subpackages. Unlike
 {@link #inPackage(Package) inPackage()}, this matches classes from any classloader.
 
 @since 2.0]]>
      </doc>
    </method>
    <method name="returns" return="com.google.inject.matcher.Matcher&lt;java.lang.reflect.Method&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="returnType" type="com.google.inject.matcher.Matcher&lt;? super java.lang.Class&lt;?&gt;&gt;"/>
      <doc>
      <![CDATA[Returns a matcher which matches methods with matching return types.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Matcher implementations. Supports matching classes and methods.

 @author crazybob@google.com (Bob Lee)]]>
    </doc>
  </class>
  <!-- end class com.google.inject.matcher.Matchers -->
</package>
<package name="com.google.inject.multibindings">
  <!-- start class com.google.inject.multibindings.ClassMapKey -->
  <class name="ClassMapKey"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.lang.annotation.Annotation"/>
    <doc>
    <![CDATA[Allows {@literal @}{@link ProvidesIntoMap} to specify a class map key.

 @since 4.0]]>
    </doc>
  </class>
  <!-- end class com.google.inject.multibindings.ClassMapKey -->
  <!-- start class com.google.inject.multibindings.MapBinder -->
  <class name="MapBinder" extends="java.lang.Object"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="newMapBinder" return="com.google.inject.multibindings.MapBinder&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="binder" type="com.google.inject.Binder"/>
      <param name="keyType" type="com.google.inject.TypeLiteral&lt;K&gt;"/>
      <param name="valueType" type="com.google.inject.TypeLiteral&lt;V&gt;"/>
      <doc>
      <![CDATA[Returns a new mapbinder that collects entries of {@code keyType}/{@code valueType} in a
 {@link Map} that is itself bound with no binding annotation.]]>
      </doc>
    </method>
    <method name="newMapBinder" return="com.google.inject.multibindings.MapBinder&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="binder" type="com.google.inject.Binder"/>
      <param name="keyType" type="java.lang.Class&lt;K&gt;"/>
      <param name="valueType" type="java.lang.Class&lt;V&gt;"/>
      <doc>
      <![CDATA[Returns a new mapbinder that collects entries of {@code keyType}/{@code valueType} in a
 {@link Map} that is itself bound with no binding annotation.]]>
      </doc>
    </method>
    <method name="newMapBinder" return="com.google.inject.multibindings.MapBinder&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="binder" type="com.google.inject.Binder"/>
      <param name="keyType" type="com.google.inject.TypeLiteral&lt;K&gt;"/>
      <param name="valueType" type="com.google.inject.TypeLiteral&lt;V&gt;"/>
      <param name="annotation" type="java.lang.annotation.Annotation"/>
      <doc>
      <![CDATA[Returns a new mapbinder that collects entries of {@code keyType}/{@code valueType} in a
 {@link Map} that is itself bound with {@code annotation}.]]>
      </doc>
    </method>
    <method name="newMapBinder" return="com.google.inject.multibindings.MapBinder&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="binder" type="com.google.inject.Binder"/>
      <param name="keyType" type="java.lang.Class&lt;K&gt;"/>
      <param name="valueType" type="java.lang.Class&lt;V&gt;"/>
      <param name="annotation" type="java.lang.annotation.Annotation"/>
      <doc>
      <![CDATA[Returns a new mapbinder that collects entries of {@code keyType}/{@code valueType} in a
 {@link Map} that is itself bound with {@code annotation}.]]>
      </doc>
    </method>
    <method name="newMapBinder" return="com.google.inject.multibindings.MapBinder&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="binder" type="com.google.inject.Binder"/>
      <param name="keyType" type="com.google.inject.TypeLiteral&lt;K&gt;"/>
      <param name="valueType" type="com.google.inject.TypeLiteral&lt;V&gt;"/>
      <param name="annotationType" type="java.lang.Class&lt;? extends java.lang.annotation.Annotation&gt;"/>
      <doc>
      <![CDATA[Returns a new mapbinder that collects entries of {@code keyType}/{@code valueType} in a
 {@link Map} that is itself bound with {@code annotationType}.]]>
      </doc>
    </method>
    <method name="newMapBinder" return="com.google.inject.multibindings.MapBinder&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="binder" type="com.google.inject.Binder"/>
      <param name="keyType" type="java.lang.Class&lt;K&gt;"/>
      <param name="valueType" type="java.lang.Class&lt;V&gt;"/>
      <param name="annotationType" type="java.lang.Class&lt;? extends java.lang.annotation.Annotation&gt;"/>
      <doc>
      <![CDATA[Returns a new mapbinder that collects entries of {@code keyType}/{@code valueType} in a
 {@link Map} that is itself bound with {@code annotationType}.]]>
      </doc>
    </method>
    <method name="permitDuplicates" return="com.google.inject.multibindings.MapBinder&lt;K, V&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Configures the {@code MapBinder} to handle duplicate entries.
 <p>When multiple equal keys are bound, the value that gets included in the map is
 arbitrary.
 <p>In addition to the {@code Map<K, V>} and {@code Map<K, Provider<V>>}
 maps that are normally bound, a {@code Map<K, Set<V>>} and
 {@code Map<K, Set<Provider<V>>>} are <em>also</em> bound, which contain
 all values bound to each key.
 <p>
 When multiple modules contribute elements to the map, this configuration
 option impacts all of them.

 @return this map binder
 @since 3.0]]>
      </doc>
    </method>
    <method name="addBinding" return="com.google.inject.binder.LinkedBindingBuilder&lt;V&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="K"/>
      <doc>
      <![CDATA[Returns a binding builder used to add a new entry in the map. Each
 key must be distinct (and non-null). Bound providers will be evaluated each
 time the map is injected.

 <p>It is an error to call this method without also calling one of the
 {@code to} methods on the returned binding builder.

 <p>Scoping elements independently is supported. Use the {@code in} method
 to specify a binding scope.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[An API to bind multiple map entries separately, only to later inject them as
 a complete map. MapBinder is intended for use in your application's module:
 <pre><code>
 public class SnacksModule extends AbstractModule {
   protected void configure() {
     MapBinder&lt;String, Snack&gt; mapbinder
         = MapBinder.newMapBinder(binder(), String.class, Snack.class);
     mapbinder.addBinding("twix").toInstance(new Twix());
     mapbinder.addBinding("snickers").toProvider(SnickersProvider.class);
     mapbinder.addBinding("skittles").to(Skittles.class);
   }
 }</code></pre>

 <p>With this binding, a {@link Map}{@code <String, Snack>} can now be
 injected:
 <pre><code>
 class SnackMachine {
   {@literal @}Inject
   public SnackMachine(Map&lt;String, Snack&gt; snacks) { ... }
 }</code></pre>

 <p>In addition to binding {@code Map<K, V>}, a mapbinder will also bind
 {@code Map<K, Provider<V>>} for lazy value provision:
 <pre><code>
 class SnackMachine {
   {@literal @}Inject
   public SnackMachine(Map&lt;String, Provider&lt;Snack&gt;&gt; snackProviders) { ... }
 }</code></pre>

 <p>Contributing mapbindings from different modules is supported. For example,
 it is okay to have both {@code CandyModule} and {@code ChipsModule} both
 create their own {@code MapBinder<String, Snack>}, and to each contribute
 bindings to the snacks map. When that map is injected, it will contain
 entries from both modules.

 <p>The map's iteration order is consistent with the binding order. This is
 convenient when multiple elements are contributed by the same module because
 that module can order its bindings appropriately. Avoid relying on the
 iteration order of elements contributed by different modules, since there is
 no equivalent mechanism to order modules.

 <p>The map is unmodifiable.  Elements can only be added to the map by
 configuring the MapBinder.  Elements can never be removed from the map.

 <p>Values are resolved at map injection time. If a value is bound to a
 provider, that provider's get method will be called each time the map is
 injected (unless the binding is also scoped, or a map of providers is injected).

 <p>Annotations are used to create different maps of the same key/value
 type. Each distinct annotation gets its own independent map.

 <p><strong>Keys must be distinct.</strong> If the same key is bound more than
 once, map injection will fail. However, use {@link #permitDuplicates()} in
 order to allow duplicate keys; extra bindings to {@code Map<K, Set<V>>} and
 {@code Map<K, Set<Provider<V>>} will be added.

 <p><strong>Keys must be non-null.</strong> {@code addBinding(null)} will
 throw an unchecked exception.

 <p><strong>Values must be non-null to use map injection.</strong> If any
 value is null, map injection will fail (although injecting a map of providers
 will not).

 @author dpb@google.com (David P. Baker)]]>
    </doc>
  </class>
  <!-- end class com.google.inject.multibindings.MapBinder -->
  <!-- start interface com.google.inject.multibindings.MapBinderBinding -->
  <interface name="MapBinderBinding"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="getMapKey" return="com.google.inject.Key&lt;T&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the {@link Key} for the map.]]>
      </doc>
    </method>
    <method name="getKeyTypeLiteral" return="com.google.inject.TypeLiteral&lt;?&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the TypeLiteral describing the keys of the map.
 <p>
 The TypeLiteral will always match the type Map's generic type. For example, if getMapKey
 returns a key of <code>Map&lt;String, Snack></code>, then this will always return a
 <code>TypeLiteral&lt;String></code>.]]>
      </doc>
    </method>
    <method name="getValueTypeLiteral" return="com.google.inject.TypeLiteral&lt;?&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the TypeLiteral describing the values of the map.
 <p>
 The TypeLiteral will always match the type Map's generic type. For example, if getMapKey
 returns a key of <code>Map&lt;String, Snack></code>, then this will always return a
 <code>TypeLiteral&lt;Snack></code>.]]>
      </doc>
    </method>
    <method name="getEntries" return="java.util.List&lt;java.util.Map.Entry&lt;?, com.google.inject.Binding&lt;?&gt;&gt;&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns all entries in the Map. The returned list of Map.Entries contains the key and a binding
 to the value. Duplicate keys or values will exist as separate Map.Entries in the returned list.
 This is only supported on bindings returned from an injector. This will throw
 {@link UnsupportedOperationException} if it is called on an element retrieved from
 {@link Elements#getElements}.
 <p>
 The elements will always match the type Map's generic type. For example, if getMapKey returns a
 key of <code>Map&lt;String, Snack></code>, then this will always return a list of type
 <code>List&lt;Map.Entry&lt;String, Binding&lt;Snack>>></code>.]]>
      </doc>
    </method>
    <method name="permitsDuplicates" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns true if the MapBinder permits duplicates. This is only supported on bindings returned
 from an injector. This will throw {@link UnsupportedOperationException} if it is called on a
 MapBinderBinding retrieved from {@link Elements#getElements}.]]>
      </doc>
    </method>
    <method name="containsElement" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="element" type="com.google.inject.spi.Element"/>
      <doc>
      <![CDATA[Returns true if this MapBinder contains the given Element in order to build the map or uses the
 given Element in order to support building and injecting the map. This will work for
 MapBinderBindings retrieved from an injector and {@link Elements#getElements}. Usually this is
 only necessary if you are working with elements retrieved from modules (without an Injector),
 otherwise {@link #getEntries} and {@link #permitsDuplicates} are better options.
 <p>
 If you need to introspect the details of the map, such as the keys, values or if it permits
 duplicates, it is necessary to pass the elements through an Injector and use
 {@link #getEntries()} and {@link #permitsDuplicates()}.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A binding for a MapBinder.
 <p>
 Although MapBinders may be injected through a variety of generic types (Map&lt;K, V>, Map
 &lt;K, Provider&lt;V>>, Map&lt;K, Set&lt;V>>, Map<K, Set&lt;
 Provider&lt;V>>, and even Set&lt;Map.Entry&lt;K, Provider&lt;V>>), a
 MapBinderBinding exists only on the Binding associated with the Map&lt;K, V> key. Other
 bindings can be validated to be derived from this MapBinderBinding using
 {@link #containsElement(Element)}.
 
 @param <T> The fully qualified type of the map, including Map. For example:
          <code>MapBinderBinding&lt;Map&lt;String, Snack>></code>
 
 @since 3.0
 @author sameb@google.com (Sam Berlin)]]>
    </doc>
  </interface>
  <!-- end interface com.google.inject.multibindings.MapBinderBinding -->
  <!-- start class com.google.inject.multibindings.MapKey -->
  <class name="MapKey"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.lang.annotation.Annotation"/>
    <doc>
    <![CDATA[Allows users define customized key type annotations for map bindings by annotating an annotation
 of a {@code Map}'s key type. The custom key annotation can be applied to methods also annotated
 with {@literal @}{@link ProvidesIntoMap}.
 
 <p>A {@link StringMapKey} and {@link ClassMapKey} are provided for convenience with maps whose
 keys are strings or classes. For maps with enums or primitive types as keys, you must provide
 your own MapKey annotation, such as this one for an enum:

 <pre>
 {@literal @}MapKey(unwrapValue = true)
 {@literal @}Retention(RUNTIME)
 public {@literal @}interface MyCustomEnumKey {
   MyCustomEnum value();
 }
 </pre>

 You can also use the whole annotation as the key, if {@code unwrapValue=false}.
 When unwrapValue is false, the annotation type will be the key type for the injected map and
 the annotation instances will be the key values. If {@code unwrapValue=true}, the value() type
 will be the key type for injected map and the value() instances will be the keys values.

 @since 4.0]]>
    </doc>
  </class>
  <!-- end class com.google.inject.multibindings.MapKey -->
  <!-- start class com.google.inject.multibindings.Multibinder -->
  <class name="Multibinder" extends="java.lang.Object"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="newSetBinder" return="com.google.inject.multibindings.Multibinder&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="binder" type="com.google.inject.Binder"/>
      <param name="type" type="com.google.inject.TypeLiteral&lt;T&gt;"/>
      <doc>
      <![CDATA[Returns a new multibinder that collects instances of {@code type} in a {@link Set} that is
 itself bound with no binding annotation.]]>
      </doc>
    </method>
    <method name="newSetBinder" return="com.google.inject.multibindings.Multibinder&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="binder" type="com.google.inject.Binder"/>
      <param name="type" type="java.lang.Class&lt;T&gt;"/>
      <doc>
      <![CDATA[Returns a new multibinder that collects instances of {@code type} in a {@link Set} that is
 itself bound with no binding annotation.]]>
      </doc>
    </method>
    <method name="newSetBinder" return="com.google.inject.multibindings.Multibinder&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="binder" type="com.google.inject.Binder"/>
      <param name="type" type="com.google.inject.TypeLiteral&lt;T&gt;"/>
      <param name="annotation" type="java.lang.annotation.Annotation"/>
      <doc>
      <![CDATA[Returns a new multibinder that collects instances of {@code type} in a {@link Set} that is
 itself bound with {@code annotation}.]]>
      </doc>
    </method>
    <method name="newSetBinder" return="com.google.inject.multibindings.Multibinder&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="binder" type="com.google.inject.Binder"/>
      <param name="type" type="java.lang.Class&lt;T&gt;"/>
      <param name="annotation" type="java.lang.annotation.Annotation"/>
      <doc>
      <![CDATA[Returns a new multibinder that collects instances of {@code type} in a {@link Set} that is
 itself bound with {@code annotation}.]]>
      </doc>
    </method>
    <method name="newSetBinder" return="com.google.inject.multibindings.Multibinder&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="binder" type="com.google.inject.Binder"/>
      <param name="type" type="com.google.inject.TypeLiteral&lt;T&gt;"/>
      <param name="annotationType" type="java.lang.Class&lt;? extends java.lang.annotation.Annotation&gt;"/>
      <doc>
      <![CDATA[Returns a new multibinder that collects instances of {@code type} in a {@link Set} that is
 itself bound with {@code annotationType}.]]>
      </doc>
    </method>
    <method name="newSetBinder" return="com.google.inject.multibindings.Multibinder&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="binder" type="com.google.inject.Binder"/>
      <param name="key" type="com.google.inject.Key&lt;T&gt;"/>
      <doc>
      <![CDATA[Returns a new multibinder that collects instances of the key's type in a {@link Set} that is
 itself bound with the annotation (if any) of the key.

 @since 4.0]]>
      </doc>
    </method>
    <method name="newSetBinder" return="com.google.inject.multibindings.Multibinder&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="binder" type="com.google.inject.Binder"/>
      <param name="type" type="java.lang.Class&lt;T&gt;"/>
      <param name="annotationType" type="java.lang.Class&lt;? extends java.lang.annotation.Annotation&gt;"/>
      <doc>
      <![CDATA[Returns a new multibinder that collects instances of {@code type} in a {@link Set} that is
 itself bound with {@code annotationType}.]]>
      </doc>
    </method>
    <method name="permitDuplicates" return="com.google.inject.multibindings.Multibinder&lt;T&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Configures the bound set to silently discard duplicate elements. When multiple equal values are
 bound, the one that gets included is arbitrary. When multiple modules contribute elements to
 the set, this configuration option impacts all of them.

 @return this multibinder
 @since 3.0]]>
      </doc>
    </method>
    <method name="addBinding" return="com.google.inject.binder.LinkedBindingBuilder&lt;T&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a binding builder used to add a new element in the set. Each
 bound element must have a distinct value. Bound providers will be
 evaluated each time the set is injected.

 <p>It is an error to call this method without also calling one of the
 {@code to} methods on the returned binding builder.

 <p>Scoping elements independently is supported. Use the {@code in} method
 to specify a binding scope.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[An API to bind multiple values separately, only to later inject them as a
 complete collection. Multibinder is intended for use in your application's
 module:
 <pre><code>
 public class SnacksModule extends AbstractModule {
   protected void configure() {
     Multibinder&lt;Snack&gt; multibinder
         = Multibinder.newSetBinder(binder(), Snack.class);
     multibinder.addBinding().toInstance(new Twix());
     multibinder.addBinding().toProvider(SnickersProvider.class);
     multibinder.addBinding().to(Skittles.class);
   }
 }</code></pre>

 <p>With this binding, a {@link Set}{@code <Snack>} can now be injected:
 <pre><code>
 class SnackMachine {
   {@literal @}Inject
   public SnackMachine(Set&lt;Snack&gt; snacks) { ... }
 }</code></pre>

 If desired, {@link Collection}{@code <Provider<Snack>>} can also be injected.

 <p>Contributing multibindings from different modules is supported. For
 example, it is okay for both {@code CandyModule} and {@code ChipsModule}
 to create their own {@code Multibinder<Snack>}, and to each contribute
 bindings to the set of snacks. When that set is injected, it will contain
 elements from both modules.

 <p>The set's iteration order is consistent with the binding order. This is
 convenient when multiple elements are contributed by the same module because
 that module can order its bindings appropriately. Avoid relying on the
 iteration order of elements contributed by different modules, since there is
 no equivalent mechanism to order modules.

 <p>The set is unmodifiable.  Elements can only be added to the set by
 configuring the multibinder.  Elements can never be removed from the set.

 <p>Elements are resolved at set injection time. If an element is bound to a
 provider, that provider's get method will be called each time the set is
 injected (unless the binding is also scoped).

 <p>Annotations are be used to create different sets of the same element
 type. Each distinct annotation gets its own independent collection of
 elements.

 <p><strong>Elements must be distinct.</strong> If multiple bound elements
 have the same value, set injection will fail.

 <p><strong>Elements must be non-null.</strong> If any set element is null,
 set injection will fail.

 @author jessewilson@google.com (Jesse Wilson)]]>
    </doc>
  </class>
  <!-- end class com.google.inject.multibindings.Multibinder -->
  <!-- start interface com.google.inject.multibindings.MultibinderBinding -->
  <interface name="MultibinderBinding"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="getSetKey" return="com.google.inject.Key&lt;T&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the key for the set.]]>
      </doc>
    </method>
    <method name="getElementTypeLiteral" return="com.google.inject.TypeLiteral&lt;?&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the TypeLiteral that describes the type of elements in the set.
 <p>
 The elements will always match the type Set's generic type. For example, if getSetKey returns a
 key of <code>Set&lt;String></code>, then this will always return a
 <code>TypeLiteral&lt;String></code>.]]>
      </doc>
    </method>
    <method name="getElements" return="java.util.List&lt;com.google.inject.Binding&lt;?&gt;&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns all bindings that make up the set. This is only supported on bindings returned from an
 injector. This will throw {@link UnsupportedOperationException} if it is called on an element
 retrieved from {@link Elements#getElements}.
 <p>
 The elements will always match the type Set's generic type. For example, if getSetKey returns a
 key of <code>Set&lt;String></code>, then this will always return a list of type
 <code>List&lt;Binding&lt;String>></code>.]]>
      </doc>
    </method>
    <method name="permitsDuplicates" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns true if the multibinder permits duplicates. This is only supported on bindings returned
 from an injector. This will throw {@link UnsupportedOperationException} if it is called on a
 MultibinderBinding retrieved from {@link Elements#getElements}.]]>
      </doc>
    </method>
    <method name="containsElement" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="element" type="com.google.inject.spi.Element"/>
      <doc>
      <![CDATA[Returns true if this Multibinder uses the given Element. This will be true for bindings that
 derive the elements of the set and other bindings that Multibinder uses internally. This will
 work for MultibinderBindings retrieved from an injector and {@link Elements#getElements}.
 Usually this is only necessary if you are working with elements retrieved from modules (without
 an Injector), otherwise {@link #getElements} and {@link #permitsDuplicates} are better options.
 <p>
 If you need to introspect the details of the set, such as the values or if it permits
 duplicates, it is necessary to pass the elements through an Injector and use
 {@link #getElements()} and {@link #permitsDuplicates()}.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A binding for a Multibinder.
 
 @param <T> The fully qualified type of the set, including Set. For example:
          <code>MultibinderBinding&lt;Set&lt;Boolean>></code>
 
 @since 3.0
 @author sameb@google.com (Sam Berlin)]]>
    </doc>
  </interface>
  <!-- end interface com.google.inject.multibindings.MultibinderBinding -->
  <!-- start class com.google.inject.multibindings.MultibindingsScanner -->
  <class name="MultibindingsScanner" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="asModule" return="com.google.inject.Module"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a module that, when installed, will scan all modules for methods with the annotations
 {@literal @}{@link ProvidesIntoMap}, {@literal @}{@link ProvidesIntoSet}, and
 {@literal @}{@link ProvidesIntoOptional}.
 
 <p>This is a convenience method, equivalent to doing
 {@code binder().scanModulesForAnnotatedMethods(MultibindingsScanner.scanner())}.]]>
      </doc>
    </method>
    <method name="scanner" return="com.google.inject.spi.ModuleAnnotatedMethodScanner"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a {@link ModuleAnnotatedMethodScanner} that, when bound, will scan all modules for
 methods with the annotations {@literal @}{@link ProvidesIntoMap},
 {@literal @}{@link ProvidesIntoSet}, and {@literal @}{@link ProvidesIntoOptional}.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Scans a module for annotations that signal multibindings, mapbindings, and optional bindings.

 @since 4.0]]>
    </doc>
  </class>
  <!-- end class com.google.inject.multibindings.MultibindingsScanner -->
  <!-- start interface com.google.inject.multibindings.MultibindingsTargetVisitor -->
  <interface name="MultibindingsTargetVisitor"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.inject.spi.BindingTargetVisitor&lt;T, V&gt;"/>
    <method name="visit" return="V"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="multibinding" type="com.google.inject.multibindings.MultibinderBinding&lt;? extends T&gt;"/>
      <doc>
      <![CDATA[Visits a binding created through {@link Multibinder}.]]>
      </doc>
    </method>
    <method name="visit" return="V"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="mapbinding" type="com.google.inject.multibindings.MapBinderBinding&lt;? extends T&gt;"/>
      <doc>
      <![CDATA[Visits a binding created through {@link MapBinder}.]]>
      </doc>
    </method>
    <method name="visit" return="V"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="optionalbinding" type="com.google.inject.multibindings.OptionalBinderBinding&lt;? extends T&gt;"/>
      <doc>
      <![CDATA[Visits a binding created through {@link OptionalBinder}.
 
 @since 4.0]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A visitor for the multibinder extension.
 <p>
 If your {@link BindingTargetVisitor} implements this interface, bindings created by using
 {@link Multibinder}, {@link MapBinder} or {@link OptionalBinderBinding} will be visited through
 this interface.

 @since 3.0
 @author sameb@google.com (Sam Berlin)]]>
    </doc>
  </interface>
  <!-- end interface com.google.inject.multibindings.MultibindingsTargetVisitor -->
  <!-- start class com.google.inject.multibindings.OptionalBinder -->
  <class name="OptionalBinder" extends="java.lang.Object"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="newOptionalBinder" return="com.google.inject.multibindings.OptionalBinder&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="binder" type="com.google.inject.Binder"/>
      <param name="type" type="java.lang.Class&lt;T&gt;"/>
    </method>
    <method name="newOptionalBinder" return="com.google.inject.multibindings.OptionalBinder&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="binder" type="com.google.inject.Binder"/>
      <param name="type" type="com.google.inject.TypeLiteral&lt;T&gt;"/>
    </method>
    <method name="newOptionalBinder" return="com.google.inject.multibindings.OptionalBinder&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="binder" type="com.google.inject.Binder"/>
      <param name="type" type="com.google.inject.Key&lt;T&gt;"/>
    </method>
    <method name="setDefault" return="com.google.inject.binder.LinkedBindingBuilder&lt;T&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a binding builder used to set the default value that will be injected.
 The binding set by this method will be ignored if {@link #setBinding} is called.
 
 <p>It is an error to call this method without also calling one of the {@code to}
 methods on the returned binding builder.]]>
      </doc>
    </method>
    <method name="setBinding" return="com.google.inject.binder.LinkedBindingBuilder&lt;T&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a binding builder used to set the actual value that will be injected.
 This overrides any binding set by {@link #setDefault}.
 
 <p>It is an error to call this method without also calling one of the {@code to}
 methods on the returned binding builder.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[An API to bind optional values, optionally with a default value.
 OptionalBinder fulfills two roles: <ol>
 <li>It allows a framework to define an injection point that may or
     may not be bound by users.
 <li>It allows a framework to supply a default value that can be changed
     by users.
 </ol>
 
 <p>When an OptionalBinder is added, it will always supply the bindings:
 {@code Optional<T>} and {@code Optional<Provider<T>>}.  If
 {@link #setBinding} or {@link #setDefault} are called, it will also
 bind {@code T}.
 
 <p>{@code setDefault} is intended for use by frameworks that need a default
 value.  User code can call {@code setBinding} to override the default.
 <b>Warning: Even if setBinding is called, the default binding
 will still exist in the object graph.  If it is a singleton, it will be
 instantiated in {@code Stage.PRODUCTION}.</b>
 
 <p>If setDefault or setBinding are linked to Providers, the Provider may return
 {@code null}.  If it does, the Optional bindings will be absent.  Binding
 setBinding to a Provider that returns null will not cause OptionalBinder
 to fall back to the setDefault binding.
 
 <p>If neither setDefault nor setBinding are called, it will try to link to a
 user-supplied binding of the same type.  If no binding exists, the optionals
 will be absent.  Otherwise, if a user-supplied binding of that type exists,
 or if setBinding or setDefault are called, the optionals will return present
 if they are bound to a non-null value.

 <p>Values are resolved at injection time. If a value is bound to a
 provider, that provider's get method will be called each time the optional
 is injected (unless the binding is also scoped, or an optional of provider is
 injected).
 
 <p>Annotations are used to create different optionals of the same key/value
 type. Each distinct annotation gets its own independent binding.
  
 <pre><code>
 public class FrameworkModule extends AbstractModule {
   protected void configure() {
     OptionalBinder.newOptionalBinder(binder(), Renamer.class);
   }
 }</code></pre>

 <p>With this module, an {@link Optional}{@code <Renamer>} can now be
 injected.  With no other bindings, the optional will be absent.
 Users can specify bindings in one of two ways:
 
 <p>Option 1:
 <pre><code>
 public class UserRenamerModule extends AbstractModule {
   protected void configure() {
     bind(Renamer.class).to(ReplacingRenamer.class);
   }
 }</code></pre>
 
 <p>or Option 2:
 <pre><code>
 public class UserRenamerModule extends AbstractModule {
   protected void configure() {
     OptionalBinder.newOptionalBinder(binder(), Renamer.class)
         .setBinding().to(ReplacingRenamer.class);
   }
 }</code></pre>
 With both options, the {@code Optional<Renamer>} will be present and supply the
 ReplacingRenamer. 
 
 <p>Default values can be supplied using:
 <pre><code>
 public class FrameworkModule extends AbstractModule {
   protected void configure() {
     OptionalBinder.newOptionalBinder(binder(), Key.get(String.class, LookupUrl.class))
         .setDefault().toInstance(DEFAULT_LOOKUP_URL);
   }
 }</code></pre>
 With the above module, code can inject an {@code @LookupUrl String} and it
 will supply the DEFAULT_LOOKUP_URL.  A user can change this value by binding
 <pre><code>
 public class UserLookupModule extends AbstractModule {
   protected void configure() {
     OptionalBinder.newOptionalBinder(binder(), Key.get(String.class, LookupUrl.class))
         .setBinding().toInstance(CUSTOM_LOOKUP_URL);
   }
 }</code></pre>
 ... which will override the default value.
 
 <p>If one module uses setDefault the only way to override the default is to use setBinding.
 It is an error for a user to specify the binding without using OptionalBinder if
 setDefault or setBinding are called.  For example, 
 <pre><code>
 public class FrameworkModule extends AbstractModule {
   protected void configure() {
     OptionalBinder.newOptionalBinder(binder(), Key.get(String.class, LookupUrl.class))
         .setDefault().toInstance(DEFAULT_LOOKUP_URL);
   }
 }
 public class UserLookupModule extends AbstractModule {
   protected void configure() {
     bind(Key.get(String.class, LookupUrl.class)).toInstance(CUSTOM_LOOKUP_URL);
   } 
 }</code></pre>
 ... would generate an error, because both the framework and the user are trying to bind
 {@code @LookupUrl String}. 

 @author sameb@google.com (Sam Berlin)
 @since 4.0]]>
    </doc>
  </class>
  <!-- end class com.google.inject.multibindings.OptionalBinder -->
  <!-- start interface com.google.inject.multibindings.OptionalBinderBinding -->
  <interface name="OptionalBinderBinding"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="getKey" return="com.google.inject.Key&lt;T&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the {@link Key} for this binding.]]>
      </doc>
    </method>
    <method name="getDefaultBinding" return="com.google.inject.Binding&lt;?&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the default binding (set by {@link OptionalBinder#setDefault}) if one exists or null
 if no default binding is set. This will throw {@link UnsupportedOperationException} if it is
 called on an element retrieved from {@link Elements#getElements}.
 <p>
 The Binding's type will always match the type Optional's generic type. For example, if getKey
 returns a key of <code>Optional&lt;String></code>, then this will always return a
 <code>Binding&lt;String></code>.]]>
      </doc>
    </method>
    <method name="getActualBinding" return="com.google.inject.Binding&lt;?&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the actual binding (set by {@link OptionalBinder#setBinding}) or null if not set.
 This will throw {@link UnsupportedOperationException} if it is called on an element retrieved
 from {@link Elements#getElements}.
 <p>
 The Binding's type will always match the type Optional's generic type. For example, if getKey
 returns a key of <code>Optional&lt;String></code>, then this will always return a
 <code>Binding&lt;String></code>.]]>
      </doc>
    </method>
    <method name="containsElement" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="element" type="com.google.inject.spi.Element"/>
      <doc>
      <![CDATA[Returns true if this OptionalBinder contains the given Element in order to build the optional
 binding or uses the given Element in order to support building and injecting its data. This
 will work for OptionalBinderBinding retrieved from an injector and
 {@link Elements#getElements}. Usually this is only necessary if you are working with elements
 retrieved from modules (without an Injector), otherwise {@link #getDefaultBinding} and
 {@link #getActualBinding} are better options.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A binding for a OptionalBinder.
 
 <p>Although OptionalBinders may be injected through a variety of types
 {@code T}, {@code Optional<T>}, {@code Optional<Provider<T>>}, etc..), an
 OptionalBinderBinding exists only on the Binding associated with the
 {@code Optional<T>} key.  Other bindings can be validated to be derived from this
 OptionalBinderBinding using {@link #containsElement}.
 
 @param <T> The fully qualified type of the optional binding, including Optional.
        For example: {@code Optional<String>}.
 
 @since 4.0
 @author sameb@google.com (Sam Berlin)]]>
    </doc>
  </interface>
  <!-- end interface com.google.inject.multibindings.OptionalBinderBinding -->
  <!-- start class com.google.inject.multibindings.ProvidesIntoMap -->
  <class name="ProvidesIntoMap"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.lang.annotation.Annotation"/>
    <doc>
    <![CDATA[Annotates methods of a {@link Module} to add items to a {@link MapBinder}.
 The method's return type, binding annotation and additional key annotation determines
 what Map this will contribute to. For example,

 <pre>
 {@literal @}ProvidesIntoMap
 {@literal @}StringMapKey("Foo")
 {@literal @}Named("plugins")
 Plugin provideFooUrl(FooManager fm) { return fm.getPlugin(); }

 {@literal @}ProvidesIntoMap
 {@literal @}StringMapKey("Bar")
 {@literal @}Named("urls")
 Plugin provideBarUrl(BarManager bm) { return bm.getPlugin(); }
 </pre>

 will add two items to the {@code @Named("urls") Map<String, Plugin>} map. The key 'Foo'
 will map to the provideFooUrl method, and the key 'Bar' will map to the provideBarUrl method.
 The values are bound as providers and will be evaluated at injection time.

 <p>Because the key is specified as an annotation, only Strings, Classes, enums, primitive
 types and annotation instances are supported as keys.

 @author sameb@google.com (Sam Berlin)
 @since 4.0]]>
    </doc>
  </class>
  <!-- end class com.google.inject.multibindings.ProvidesIntoMap -->
  <!-- start class com.google.inject.multibindings.ProvidesIntoOptional -->
  <class name="ProvidesIntoOptional"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.lang.annotation.Annotation"/>
    <doc>
    <![CDATA[Annotates methods of a {@link Module} to add items to a {@link Multibinder}.
 The method's return type and binding annotation determines what Optional this will
 contribute to. For example,

 <pre>
 {@literal @}ProvidesIntoOptional(DEFAULT)
 {@literal @}Named("url")
 String provideFooUrl(FooManager fm) { returm fm.getUrl(); }

 {@literal @}ProvidesIntoOptional(ACTUAL)
 {@literal @}Named("url")
 String provideBarUrl(BarManager bm) { return bm.getUrl(); }
 </pre>

 will set the default value of {@code @Named("url") Optional<String>} to foo's URL,
 and then override it to bar's URL.

 @author sameb@google.com (Sam Berlin)
 @since 4.0]]>
    </doc>
  </class>
  <!-- end class com.google.inject.multibindings.ProvidesIntoOptional -->
  <!-- start class com.google.inject.multibindings.ProvidesIntoOptional.Type -->
  <class name="ProvidesIntoOptional.Type" extends="java.lang.Enum&lt;com.google.inject.multibindings.ProvidesIntoOptional.Type&gt;"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="values" return="com.google.inject.multibindings.ProvidesIntoOptional.Type[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="com.google.inject.multibindings.ProvidesIntoOptional.Type"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <doc>
    <![CDATA[@since 4.0]]>
    </doc>
  </class>
  <!-- end class com.google.inject.multibindings.ProvidesIntoOptional.Type -->
  <!-- start class com.google.inject.multibindings.ProvidesIntoSet -->
  <class name="ProvidesIntoSet"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.lang.annotation.Annotation"/>
    <doc>
    <![CDATA[Annotates methods of a {@link Module} to add items to a {@link Multibinder}.
 The method's return type and binding annotation determines what Set this will
 contribute to. For example,

 <pre>
 {@literal @}ProvidesIntoSet
 {@literal @}Named("urls")
 String provideFooUrl(FooManager fm) { returm fm.getUrl(); }

 {@literal @}ProvidesIntoSet
 {@literal @}Named("urls")
 String provideBarUrl(BarManager bm) { return bm.getUrl(); }
 </pre>

 will add two items to the {@code @Named("urls") Set<String>} set. The items are bound as
 providers and will be evaluated at injection time.

 @author sameb@google.com (Sam Berlin)
 @since 4.0]]>
    </doc>
  </class>
  <!-- end class com.google.inject.multibindings.ProvidesIntoSet -->
  <!-- start class com.google.inject.multibindings.StringMapKey -->
  <class name="StringMapKey"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.lang.annotation.Annotation"/>
    <doc>
    <![CDATA[Allows {@literal @}{@link ProvidesIntoMap} to specify a string map key.

 @since 4.0]]>
    </doc>
  </class>
  <!-- end class com.google.inject.multibindings.StringMapKey -->
</package>
<package name="com.google.inject.name">
  <!-- start class com.google.inject.name.Named -->
  <class name="Named"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.lang.annotation.Annotation"/>
    <doc>
    <![CDATA[Annotates named things.

 @author crazybob@google.com (Bob Lee)]]>
    </doc>
  </class>
  <!-- end class com.google.inject.name.Named -->
  <!-- start class com.google.inject.name.Names -->
  <class name="Names" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="named" return="com.google.inject.name.Named"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <doc>
      <![CDATA[Creates a {@link Named} annotation with {@code name} as the value.]]>
      </doc>
    </method>
    <method name="bindProperties"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="binder" type="com.google.inject.Binder"/>
      <param name="properties" type="java.util.Map&lt;java.lang.String, java.lang.String&gt;"/>
      <doc>
      <![CDATA[Creates a constant binding to {@code @Named(key)} for each entry in
 {@code properties}.]]>
      </doc>
    </method>
    <method name="bindProperties"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="binder" type="com.google.inject.Binder"/>
      <param name="properties" type="java.util.Properties"/>
      <doc>
      <![CDATA[Creates a constant binding to {@code @Named(key)} for each property. This
 method binds all properties including those inherited from 
 {@link Properties#defaults defaults}.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Utility methods for use with {@code @}{@link Named}.

 @author crazybob@google.com (Bob Lee)]]>
    </doc>
  </class>
  <!-- end class com.google.inject.name.Names -->
</package>
<package name="com.google.inject.persist">
  <!-- start class com.google.inject.persist.PersistFilter -->
  <class name="PersistFilter" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="javax.servlet.Filter"/>
    <constructor name="PersistFilter" type="com.google.inject.persist.UnitOfWork, com.google.inject.persist.PersistService"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="init"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="filterConfig" type="javax.servlet.FilterConfig"/>
      <exception name="ServletException" type="javax.servlet.ServletException"/>
    </method>
    <method name="destroy"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="doFilter"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="servletRequest" type="javax.servlet.ServletRequest"/>
      <param name="servletResponse" type="javax.servlet.ServletResponse"/>
      <param name="filterChain" type="javax.servlet.FilterChain"/>
      <exception name="IOException" type="java.io.IOException"/>
      <exception name="ServletException" type="javax.servlet.ServletException"/>
    </method>
    <doc>
    <![CDATA[Apply this filter to enable the HTTP Request unit of work and to have
 guice-persist manage the lifecycle of active units of work.
 The filter automatically starts and stops the relevant {@link PersistService}
 upon {@link javax.servlet.Filter#init(javax.servlet.FilterConfig)} and
 {@link javax.servlet.Filter#destroy()} respectively.

 <p> To be able to use the open session-in-view pattern (i.e. work per request),
 register this filter <b>once</b> in your Guice {@code ServletModule}. It is
 important that you register this filter before any other filter.

 For multiple providers, you should register this filter once per provider, inside
 a private module for each persist module installed (this must be the same private
 module where the specific persist module is itself installed).

 <p>
 Example configuration:
 <pre>{@code
  public class MyModule extends ServletModule {
    public void configureServlets() {
      filter("/*").through(PersistFilter.class);

      serve("/index.html").with(MyHtmlServlet.class);
      // Etc.
    }
  }
 }</pre>
 <p>
 This filter is thread safe and allows you to create injectors concurrently
 and deploy multiple guice-persist modules within the same injector, or even
 multiple injectors with persist modules withing the same JVM or web app.
 <p>
 This filter requires the Guice Servlet extension.

 @author Dhanji R. Prasanna (dhanji@gmail.com)]]>
    </doc>
  </class>
  <!-- end class com.google.inject.persist.PersistFilter -->
  <!-- start class com.google.inject.persist.PersistModule -->
  <class name="PersistModule" extends="com.google.inject.AbstractModule"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="PersistModule"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="configure"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="protected"
      deprecated="not deprecated">
    </method>
    <method name="configurePersistence"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </method>
    <method name="getTransactionInterceptor" return="org.aopalliance.intercept.MethodInterceptor"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Install this module to add guice-persist library support for JPA persistence
 providers.

 @author dhanji@gmail.com (Dhanji R. Prasanna)]]>
    </doc>
  </class>
  <!-- end class com.google.inject.persist.PersistModule -->
  <!-- start interface com.google.inject.persist.PersistService -->
  <interface name="PersistService"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="start"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Starts the underlying persistence engine and makes guice-persist ready for
 use. For instance, with JPA, it creates an EntityManagerFactory and may
 open connection pools. This method must be called by your code prior to
 using any guice-persist or JPA artifacts. If already started,
 calling this method does nothing, if already stopped, it also does
 nothing.]]>
      </doc>
    </method>
    <method name="stop"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Stops the underlying persistence engine. For instance, with JPA, it
 closes the {@code EntityManagerFactory}. If already stopped, calling this
 method does nothing. If not yet started, it also does nothing.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Persistence provider service. Use this to manage the overall
 startup and stop of the persistence module(s).

 TODO(dhanji): Integrate with Service API when appropriate.

 @author dhanji@gmail.com (Dhanji R. Prasanna)]]>
    </doc>
  </interface>
  <!-- end interface com.google.inject.persist.PersistService -->
  <!-- start class com.google.inject.persist.Transactional -->
  <class name="Transactional"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.lang.annotation.Annotation"/>
    <doc>
    <![CDATA[<p> Any method or class marked with this annotation will be considered for transactionality.
 Consult the documentation on https://github.com/google/guice/wiki/GuicePersist for detailed
 semantics.
 Marking a method {@code @Transactional} will start a new transaction before the method
 executes and commit it after the method returns.
 <p>
 If the method throws an exception, the transaction will be rolled back <em>unless</em>
 you have specifically requested not to in the {@link #ignore()} clause.
 <p>
 Similarly, the set of exceptions that will trigger a rollback can be defined in
 the {@link #rollbackOn()} clause. By default, only unchecked exceptions trigger a
 rollback.

 @author Dhanji R. Prasanna (dhanji@gmail.com)]]>
    </doc>
  </class>
  <!-- end class com.google.inject.persist.Transactional -->
  <!-- start interface com.google.inject.persist.UnitOfWork -->
  <interface name="UnitOfWork"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="begin"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Starts a Unit Of Work. Underneath, causes a session to the data layer to be opened. If there
 is already one open, the invocation will do nothing. In this way, you can define arbitrary
 units-of-work that nest within one another safely.

 Transaction semantics are not affected.]]>
      </doc>
    </method>
    <method name="end"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Declares an end to the current Unit of Work. Underneath, causes any open session to the data
 layer to close. If there is no Unit of work open, then the call returns silently. You can
 safely invoke end() repeatedly.
 <p>
 Transaction semantics are not affected.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[This interface is used to gain manual control over the unit of work. This is mostly to do
 work in non-request, non-transactional threads. Or where more fine-grained control over the unit
 of work is required. Starting and ending a unit of work directly corresponds to opening and
 closing a {@code Session}, {@code EntityManager} or {@code ObjectContainer} respectively.
 <p> The
 Unit of Work referred to by UnitOfWork will always be local to the calling thread. Be careful to
 end() in a finally block. Neither JPA, nor Hibernate supports threadsafe sessions (reasoning
 behind thread-locality of Unit of Work semantics).

 <ul>
   <li>Using UnitOfWork with the PersistFilter inside a request is not recommended.</li>
   <li>Using UnitOfWork with session-per-txn strategy is not terribly clever either.</li>
   <li>Using UnitOfWork with session-per-request strategy but *outside* a request (i.e. in a
       background or bootstrap thread) is probably a good use case.</li>
  </ul>

 @author Dhanji R. Prasanna (dhanji@gmail com)]]>
    </doc>
  </interface>
  <!-- end interface com.google.inject.persist.UnitOfWork -->
</package>
<package name="com.google.inject.persist.finder">
  <!-- start class com.google.inject.persist.finder.DynamicFinder -->
  <class name="DynamicFinder" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="DynamicFinder" type="java.lang.reflect.Method"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="from" return="com.google.inject.persist.finder.DynamicFinder"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="method" type="java.lang.reflect.Method"/>
      <doc>
      <![CDATA[Returns some metadata if the method is annotated {@code @Finder} or null.

 @param method a method you want to test as a dynamic finder]]>
      </doc>
    </method>
    <method name="metadata" return="com.google.inject.persist.finder.Finder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Utility that helps you introspect dynamic finder methods.

 @author dhanji@gmail.com (Dhanji R. Prasanna)]]>
    </doc>
  </class>
  <!-- end class com.google.inject.persist.finder.DynamicFinder -->
  <!-- start class com.google.inject.persist.finder.Finder -->
  <class name="Finder"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.lang.annotation.Annotation"/>
    <doc>
    <![CDATA[Marks a method stub as a dynamic finder. The method is intercepted and replaced with the
 specified JPAQL query. Provides result auto-boxing and automatic parameter binding.

 @author Dhanji R. Prasanna (dhanji@gmail.com)]]>
    </doc>
  </class>
  <!-- end class com.google.inject.persist.finder.Finder -->
  <!-- start class com.google.inject.persist.finder.FirstResult -->
  <class name="FirstResult"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.lang.annotation.Annotation"/>
    <doc>
    <![CDATA[Annotate any dynamic finder method's integer argument with this to pass in
 the index of the first result in the result set you are interested in.
 Useful for paging result sets. Complemented by {@link MaxResults}.

 @author Dhanji R. Prasanna (dhanji@gmail.com)]]>
    </doc>
  </class>
  <!-- end class com.google.inject.persist.finder.FirstResult -->
  <!-- start class com.google.inject.persist.finder.MaxResults -->
  <class name="MaxResults"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.lang.annotation.Annotation"/>
    <doc>
    <![CDATA[Annotate any dynamic finder method's integer argument with this to pass in
 the maximum size of returned result window. Usefule for paging result sets.
 Complement of {@link FirstResult}.

 @author Dhanji R. Prasanna (dhanji@gmail.com)]]>
    </doc>
  </class>
  <!-- end class com.google.inject.persist.finder.MaxResults -->
</package>
<package name="com.google.inject.persist.jpa">
  <!-- start class com.google.inject.persist.jpa.JpaPersistModule -->
  <class name="JpaPersistModule" extends="com.google.inject.persist.PersistModule"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="JpaPersistModule" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="configurePersistence"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </method>
    <method name="getTransactionInterceptor" return="org.aopalliance.intercept.MethodInterceptor"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </method>
    <method name="properties" return="com.google.inject.persist.jpa.JpaPersistModule"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="properties" type="java.util.Map&lt;?, ?&gt;"/>
      <doc>
      <![CDATA[Configures the JPA persistence provider with a set of properties.
 
 @param properties A set of name value pairs that configure a JPA persistence
     provider as per the specification.
 @since 4.0 (since 3.0 with a parameter type of {@code java.util.Properties})]]>
      </doc>
    </method>
    <method name="addFinder" return="com.google.inject.persist.jpa.JpaPersistModule"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="iface" type="java.lang.Class&lt;T&gt;"/>
      <doc>
      <![CDATA[Adds an interface to this module to use as a dynamic finder.

 @param iface Any interface type whose methods are all dynamic finders.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[JPA provider for guice persist.

 @author dhanji@gmail.com (Dhanji R. Prasanna)]]>
    </doc>
  </class>
  <!-- end class com.google.inject.persist.jpa.JpaPersistModule -->
</package>
<package name="com.google.inject.servlet">
  <!-- start class com.google.inject.servlet.GuiceFilter -->
  <class name="GuiceFilter" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="javax.servlet.Filter"/>
    <constructor name="GuiceFilter"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="doFilter"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="servletRequest" type="javax.servlet.ServletRequest"/>
      <param name="servletResponse" type="javax.servlet.ServletResponse"/>
      <param name="filterChain" type="javax.servlet.FilterChain"/>
      <exception name="IOException" type="java.io.IOException"/>
      <exception name="ServletException" type="javax.servlet.ServletException"/>
    </method>
    <method name="init"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="filterConfig" type="javax.servlet.FilterConfig"/>
      <exception name="ServletException" type="javax.servlet.ServletException"/>
    </method>
    <method name="destroy"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[<p>
 Apply this filter in web.xml above all other filters (typically), to all requests where you plan
  to use servlet scopes. This is also needed in order to dispatch requests to injectable filters
  and servlets:
  <pre>
  &lt;filter&gt;
    &lt;filter-name&gt;guiceFilter&lt;/filter-name&gt;
    &lt;filter-class&gt;<b>com.google.inject.servlet.GuiceFilter</b>&lt;/filter-class&gt;
  &lt;/filter&gt;

  &lt;filter-mapping&gt;
    &lt;filter-name&gt;guiceFilter&lt;/filter-name&gt;
    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
  &lt;/filter-mapping&gt;
  </pre>

 This filter must appear before every filter that makes use of Guice injection or servlet
 scopes functionality. Typically, you will only register this filter in web.xml and register
 any other filters (and servlets) using a {@link ServletModule}.

 @author crazybob@google.com (Bob Lee)
 @author dhanji@gmail.com (Dhanji R. Prasanna)]]>
    </doc>
  </class>
  <!-- end class com.google.inject.servlet.GuiceFilter -->
  <!-- start class com.google.inject.servlet.GuiceServletContextListener -->
  <class name="GuiceServletContextListener" extends="java.lang.Object"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="javax.servlet.ServletContextListener"/>
    <constructor name="GuiceServletContextListener"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="contextInitialized"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="servletContextEvent" type="javax.servlet.ServletContextEvent"/>
    </method>
    <method name="contextDestroyed"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="servletContextEvent" type="javax.servlet.ServletContextEvent"/>
    </method>
    <method name="getInjector" return="com.google.inject.Injector"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Override this method to create (or otherwise obtain a reference to) your
 injector.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[As of Guice 2.0 you can still use (your subclasses of) {@code GuiceServletContextListener}
 class as a logical place to create and configure your injector. This will ensure the injector
 is created when the web application is deployed.
 
 @author Kevin Bourrillion (kevinb@google.com)
 @since 2.0]]>
    </doc>
  </class>
  <!-- end class com.google.inject.servlet.GuiceServletContextListener -->
  <!-- start interface com.google.inject.servlet.InstanceFilterBinding -->
  <interface name="InstanceFilterBinding"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.inject.servlet.ServletModuleBinding"/>
    <method name="getFilterInstance" return="javax.servlet.Filter"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the filter instance that will be used.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A binding to a single instance of a filter. 

 @author sameb@google.com
 @since 3.0]]>
    </doc>
  </interface>
  <!-- end interface com.google.inject.servlet.InstanceFilterBinding -->
  <!-- start interface com.google.inject.servlet.InstanceServletBinding -->
  <interface name="InstanceServletBinding"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.inject.servlet.ServletModuleBinding"/>
    <method name="getServletInstance" return="javax.servlet.http.HttpServlet"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the servlet instance that will be used.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A binding to a single instance of a servlet. 

 @author sameb@google.com
 @since 3.0]]>
    </doc>
  </interface>
  <!-- end interface com.google.inject.servlet.InstanceServletBinding -->
  <!-- start interface com.google.inject.servlet.LinkedFilterBinding -->
  <interface name="LinkedFilterBinding"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.inject.servlet.ServletModuleBinding"/>
    <method name="getLinkedKey" return="com.google.inject.Key&lt;? extends javax.servlet.Filter&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the key used to lookup the filter instance.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A linked binding to a filter. 

 @author sameb@google.com
 @since 3.0]]>
    </doc>
  </interface>
  <!-- end interface com.google.inject.servlet.LinkedFilterBinding -->
  <!-- start interface com.google.inject.servlet.LinkedServletBinding -->
  <interface name="LinkedServletBinding"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.inject.servlet.ServletModuleBinding"/>
    <method name="getLinkedKey" return="com.google.inject.Key&lt;? extends javax.servlet.http.HttpServlet&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the key used to lookup the servlet instance.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A linked binding to a servlet. 

 @author sameb@google.com
 @since 3.0]]>
    </doc>
  </interface>
  <!-- end interface com.google.inject.servlet.LinkedServletBinding -->
  <!-- start class com.google.inject.servlet.RequestParameters -->
  <class name="RequestParameters"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.lang.annotation.Annotation"/>
    <doc>
    <![CDATA[Apply this to field or parameters of type {@code Map<String, String[]>}
 when you want the HTTP request parameter map to be injected.

 @author crazybob@google.com (Bob Lee)]]>
    </doc>
  </class>
  <!-- end class com.google.inject.servlet.RequestParameters -->
  <!-- start class com.google.inject.servlet.RequestScoped -->
  <class name="RequestScoped"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.lang.annotation.Annotation"/>
    <doc>
    <![CDATA[Apply this to implementation classes when you want one instance per request.

 @author crazybob@google.com (Bob Lee)]]>
    </doc>
  </class>
  <!-- end class com.google.inject.servlet.RequestScoped -->
  <!-- start interface com.google.inject.servlet.RequestScoper -->
  <interface name="RequestScoper"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="open" return="com.google.inject.servlet.RequestScoper.CloseableScope"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Opens up the request scope until the returned object is closed.
 Implementations should ensure (e.g. by blocking) that multiple threads
 cannot open the same request scope concurrently. It is allowable to open
 the same request scope on the same thread, as long as open/close calls are
 correctly nested.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Object that can be used to apply a request scope to a block of code.]]>
    </doc>
  </interface>
  <!-- end interface com.google.inject.servlet.RequestScoper -->
  <!-- start interface com.google.inject.servlet.RequestScoper.CloseableScope -->
  <interface name="RequestScoper.CloseableScope"    abstract="true"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.io.Closeable"/>
    <method name="close"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Closeable subclass that does not throw any exceptions from close.]]>
    </doc>
  </interface>
  <!-- end interface com.google.inject.servlet.RequestScoper.CloseableScope -->
  <!-- start class com.google.inject.servlet.ScopingException -->
  <class name="ScopingException" extends="java.lang.IllegalStateException"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="ScopingException" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <doc>
    <![CDATA[Exception thrown when there was a failure entering request scope.

 @author Chris Nokleberg
 @since 4.0]]>
    </doc>
  </class>
  <!-- end class com.google.inject.servlet.ScopingException -->
  <!-- start class com.google.inject.servlet.ScopingOnly -->
  <class name="ScopingOnly"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.lang.annotation.Annotation"/>
    <doc>
    <![CDATA[Annotates a {@link GuiceFilter} that provides scope functionality, but
 doesn't dispatch to {@link ServletModule} bound servlets or filters.

 @author iqshum@google.com (Isaac Shum)
 @since 4.0]]>
    </doc>
  </class>
  <!-- end class com.google.inject.servlet.ScopingOnly -->
  <!-- start class com.google.inject.servlet.ServletModule -->
  <class name="ServletModule" extends="com.google.inject.AbstractModule"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="ServletModule"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="configure"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="protected"
      deprecated="not deprecated">
    </method>
    <method name="configureServlets"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[<h3>Servlet Mapping EDSL</h3>

 <p> Part of the EDSL builder language for configuring servlets
 and filters with guice-servlet. Think of this as an in-code replacement for web.xml.
 Filters and servlets are configured here using simple java method calls. Here is a typical
 example of registering a filter when creating your Guice injector:

 <pre>
   Guice.createInjector(..., new ServletModule() {

     {@literal @}Override
     protected void configureServlets() {
       <b>serve("*.html").with(MyServlet.class)</b>
     }
   }
 </pre>

 This registers a servlet (subclass of {@code HttpServlet}) called {@code MyServlet} to service
 any web pages ending in {@code .html}. You can also use a path-style syntax to register
 servlets:

 <pre>
       <b>serve("/my/*").with(MyServlet.class)</b>
 </pre>

 Every servlet (or filter) is required to be a singleton. If you cannot annotate the class
 directly, you should add a separate {@code bind(..).in(Singleton.class)} rule elsewhere in
 your module. Mapping a servlet that is bound under any other scope is an error.

 <p>
 <h4>Dispatch Order</h4>
 You are free to register as many servlets and filters as you like this way. They will
 be compared and dispatched in the order in which the filter methods are called:

 <pre>

   Guice.createInjector(..., new ServletModule() {

     {@literal @}Override
     protected void configureServlets() {
       filter("/*").through(MyFilter.class);
       filter("*.css").through(MyCssFilter.class);
       filter("*.jpg").through(new MyJpgFilter());
       // etc..

       serve("*.html").with(MyServlet.class);
       serve("/my/*").with(MyServlet.class);
       serve("*.jpg").with(new MyServlet());
       // etc..
      }
    }
 </pre>
 This will traverse down the list of rules in lexical order. For example, a url
  "{@code /my/file.js}" (after it runs through the matching filters) will first
  be compared against the servlet mapping:
 
 <pre>
       serve("*.html").with(MyServlet.class);
 </pre>
 And failing that, it will descend to the next servlet mapping:

 <pre>
       serve("/my/*").with(MyServlet.class);
 </pre>

 Since this rule matches, Guice Servlet will dispatch to {@code MyServlet}. These
 two mapping rules can also be written in more compact form using varargs syntax:

 <pre>
       serve(<b>"*.html", "/my/*"</b>).with(MyServlet.class);
 </pre>
 
 This way you can map several URI patterns to the same servlet. A similar syntax is
 also available for filter mappings.

 <p>
 <h4>Regular Expressions</h4>
 You can also map servlets (or filters) to URIs using regular expressions:
 <pre>
    <b>serveRegex("(.)*ajax(.)*").with(MyAjaxServlet.class)</b>
 </pre>

 This will map any URI containing the text "ajax" in it to {@code MyAjaxServlet}. Such as:
 <ul>
 <li>http://www.google.com/ajax.html</li>
 <li>http://www.google.com/content/ajax/index</li>
 <li>http://www.google.com/it/is_totally_ajaxian</li>
 </ul>


 <h3>Initialization Parameters</h3>

 Servlets (and filters) allow you to pass in init params
 using the {@code <init-param>} tag in web.xml. You can similarly pass in parameters to
 Servlets and filters registered in Guice-servlet using a {@link java.util.Map} of parameter
 name/value pairs. For example, to initialize {@code MyServlet} with two parameters
 ({@code name="Dhanji", site="google.com"}) you could write:

 <pre>
  Map&lt;String, String&gt; params = new HashMap&lt;String, String&gt;();
  params.put("name", "Dhanji");
  params.put("site", "google.com");

  ...
      serve("/*").with(MyServlet.class, <b>params</b>)
 </pre>

 <p>
 <h3>Binding Keys</h3>

 You can also bind keys rather than classes. This lets you hide
 implementations with package-local visbility and expose them using
 only a Guice module and an annotation:

 <pre>
  ...
      filter("/*").through(<b>Key.get(Filter.class, Fave.class)</b>);
 </pre>

 Where {@code Filter.class} refers to the Servlet API interface and {@code Fave.class} is a
 custom binding annotation. Elsewhere (in one of your own modules) you can bind this
 filter's implementation:

 <pre>
   bind(Filter.class)<b>.annotatedWith(Fave.class)</b>.to(MyFilterImpl.class);
 </pre>

 See {@link com.google.inject.Binder} for more information on binding syntax.

 <p>
 <h3>Multiple Modules</h3>

 It is sometimes useful to capture servlet and filter mappings from multiple different
 modules. This is essential if you want to package and offer drop-in Guice plugins that
 provide servlet functionality.

 <p>
 Guice Servlet allows you to register several instances of {@code ServletModule} to your
 injector. The order in which these modules are installed determines the dispatch order
 of filters and the precedence order of servlets. For example, if you had two servlet modules,
 {@code RpcModule} and {@code WebServiceModule} and they each contained a filter that mapped
 to the same URI pattern, {@code "/*"}:

 <p>
 In {@code RpcModule}:
 <pre>
     filter("/*").through(RpcFilter.class);
 </pre>

 In {@code WebServiceModule}:
 <pre>
     filter("/*").through(WebServiceFilter.class);
 </pre>

 Then the order in which these filters are dispatched is determined by the order in which
 the modules are installed:

 <pre>
   <b>install(new WebServiceModule());</b>
   install(new RpcModule());
 </pre>

 In the case shown above {@code WebServiceFilter} will run first.
 
 @since 2.0]]>
      </doc>
    </method>
    <method name="filter" return="com.google.inject.servlet.ServletModule.FilterKeyBindingBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="protected"
      deprecated="not deprecated">
      <param name="urlPattern" type="java.lang.String"/>
      <param name="morePatterns" type="java.lang.String[]"/>
      <doc>
      <![CDATA[@param urlPattern Any Servlet-style pattern. examples: /*, /html/*, *.html, etc.
 @since 2.0]]>
      </doc>
    </method>
    <method name="filter" return="com.google.inject.servlet.ServletModule.FilterKeyBindingBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="protected"
      deprecated="not deprecated">
      <param name="urlPatterns" type="java.lang.Iterable&lt;java.lang.String&gt;"/>
      <doc>
      <![CDATA[@param urlPatterns Any Servlet-style patterns. examples: /*, /html/*, *.html, etc.
 @since 4.1]]>
      </doc>
    </method>
    <method name="filterRegex" return="com.google.inject.servlet.ServletModule.FilterKeyBindingBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="protected"
      deprecated="not deprecated">
      <param name="regex" type="java.lang.String"/>
      <param name="regexes" type="java.lang.String[]"/>
      <doc>
      <![CDATA[@param regex Any Java-style regular expression.
 @since 2.0]]>
      </doc>
    </method>
    <method name="filterRegex" return="com.google.inject.servlet.ServletModule.FilterKeyBindingBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="protected"
      deprecated="not deprecated">
      <param name="regexes" type="java.lang.Iterable&lt;java.lang.String&gt;"/>
      <doc>
      <![CDATA[@param regexes Any Java-style regular expressions.
 @since 4.1]]>
      </doc>
    </method>
    <method name="serve" return="com.google.inject.servlet.ServletModule.ServletKeyBindingBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="protected"
      deprecated="not deprecated">
      <param name="urlPattern" type="java.lang.String"/>
      <param name="morePatterns" type="java.lang.String[]"/>
      <doc>
      <![CDATA[@param urlPattern Any Servlet-style pattern. examples: /*, /html/*, *.html, etc.
 @since 2.0]]>
      </doc>
    </method>
    <method name="serve" return="com.google.inject.servlet.ServletModule.ServletKeyBindingBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="protected"
      deprecated="not deprecated">
      <param name="urlPatterns" type="java.lang.Iterable&lt;java.lang.String&gt;"/>
      <doc>
      <![CDATA[@param urlPatterns Any Servlet-style patterns. examples: /*, /html/*, *.html, etc.
 @since 4.1]]>
      </doc>
    </method>
    <method name="serveRegex" return="com.google.inject.servlet.ServletModule.ServletKeyBindingBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="protected"
      deprecated="not deprecated">
      <param name="regex" type="java.lang.String"/>
      <param name="regexes" type="java.lang.String[]"/>
      <doc>
      <![CDATA[@param regex Any Java-style regular expression.
 @since 2.0]]>
      </doc>
    </method>
    <method name="serveRegex" return="com.google.inject.servlet.ServletModule.ServletKeyBindingBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="protected"
      deprecated="not deprecated">
      <param name="regexes" type="java.lang.Iterable&lt;java.lang.String&gt;"/>
      <doc>
      <![CDATA[@param regexes Any Java-style regular expressions.
 @since 4.1]]>
      </doc>
    </method>
    <method name="getServletContext" return="javax.servlet.ServletContext"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[This method only works if you are using the {@linkplain GuiceServletContextListener} to
 create your injector. Otherwise, it returns null.
 @return The current servlet context.
 @since 3.0]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Configures the servlet scopes and creates bindings for the servlet API
 objects so you can inject the request, response, session, etc.

 <p>
 You should subclass this module to register servlets and
 filters in the {@link #configureServlets()} method.

 @author crazybob@google.com (Bob Lee)
 @author dhanji@gmail.com (Dhanji R. Prasanna)]]>
    </doc>
  </class>
  <!-- end class com.google.inject.servlet.ServletModule -->
  <!-- start interface com.google.inject.servlet.ServletModule.FilterKeyBindingBuilder -->
  <interface name="ServletModule.FilterKeyBindingBuilder"    abstract="true"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="through"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="filterKey" type="java.lang.Class&lt;? extends javax.servlet.Filter&gt;"/>
    </method>
    <method name="through"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="filterKey" type="com.google.inject.Key&lt;? extends javax.servlet.Filter&gt;"/>
    </method>
    <method name="through"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="filter" type="javax.servlet.Filter"/>
      <doc>
      <![CDATA[@since 3.0]]>
      </doc>
    </method>
    <method name="through"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="filterKey" type="java.lang.Class&lt;? extends javax.servlet.Filter&gt;"/>
      <param name="initParams" type="java.util.Map&lt;java.lang.String, java.lang.String&gt;"/>
    </method>
    <method name="through"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="filterKey" type="com.google.inject.Key&lt;? extends javax.servlet.Filter&gt;"/>
      <param name="initParams" type="java.util.Map&lt;java.lang.String, java.lang.String&gt;"/>
    </method>
    <method name="through"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="filter" type="javax.servlet.Filter"/>
      <param name="initParams" type="java.util.Map&lt;java.lang.String, java.lang.String&gt;"/>
      <doc>
      <![CDATA[@since 3.0]]>
      </doc>
    </method>
    <doc>
    <![CDATA[See the EDSL examples at {@link ServletModule#configureServlets()}

 @since 2.0]]>
    </doc>
  </interface>
  <!-- end interface com.google.inject.servlet.ServletModule.FilterKeyBindingBuilder -->
  <!-- start interface com.google.inject.servlet.ServletModule.ServletKeyBindingBuilder -->
  <interface name="ServletModule.ServletKeyBindingBuilder"    abstract="true"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="with"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="servletKey" type="java.lang.Class&lt;? extends javax.servlet.http.HttpServlet&gt;"/>
    </method>
    <method name="with"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="servletKey" type="com.google.inject.Key&lt;? extends javax.servlet.http.HttpServlet&gt;"/>
    </method>
    <method name="with"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="servlet" type="javax.servlet.http.HttpServlet"/>
      <doc>
      <![CDATA[@since 3.0]]>
      </doc>
    </method>
    <method name="with"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="servletKey" type="java.lang.Class&lt;? extends javax.servlet.http.HttpServlet&gt;"/>
      <param name="initParams" type="java.util.Map&lt;java.lang.String, java.lang.String&gt;"/>
    </method>
    <method name="with"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="servletKey" type="com.google.inject.Key&lt;? extends javax.servlet.http.HttpServlet&gt;"/>
      <param name="initParams" type="java.util.Map&lt;java.lang.String, java.lang.String&gt;"/>
    </method>
    <method name="with"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="servlet" type="javax.servlet.http.HttpServlet"/>
      <param name="initParams" type="java.util.Map&lt;java.lang.String, java.lang.String&gt;"/>
      <doc>
      <![CDATA[@since 3.0]]>
      </doc>
    </method>
    <doc>
    <![CDATA[See the EDSL examples at {@link ServletModule#configureServlets()}

 @since 2.0]]>
    </doc>
  </interface>
  <!-- end interface com.google.inject.servlet.ServletModule.ServletKeyBindingBuilder -->
  <!-- start interface com.google.inject.servlet.ServletModuleBinding -->
  <interface name="ServletModuleBinding"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="getUriPatternType" return="com.google.inject.servlet.UriPatternType"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the pattern type that this binding was created with.]]>
      </doc>
    </method>
    <method name="getPattern" return="java.lang.String"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the pattern used to match against the binding.]]>
      </doc>
    </method>
    <method name="getInitParams" return="java.util.Map&lt;java.lang.String, java.lang.String&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns any context params supplied when creating the binding.]]>
      </doc>
    </method>
    <method name="matchesUri" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="uri" type="java.lang.String"/>
      <doc>
      <![CDATA[Returns true if the given URI will match this binding.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A binding created by {@link ServletModule}.
 
 @author sameb@google.com (Sam Berlin)
 @since 3.0]]>
    </doc>
  </interface>
  <!-- end interface com.google.inject.servlet.ServletModuleBinding -->
  <!-- start interface com.google.inject.servlet.ServletModuleTargetVisitor -->
  <interface name="ServletModuleTargetVisitor"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.inject.spi.BindingTargetVisitor&lt;T, V&gt;"/>
    <method name="visit" return="V"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="binding" type="com.google.inject.servlet.LinkedFilterBinding"/>
      <doc>
      <![CDATA[Visits a filter binding created by {@link ServletModule#filter}, where
 {@link FilterKeyBindingBuilder#through} is called with a Class or Key.
 
 If multiple patterns were specified, this will be called multiple times.]]>
      </doc>
    </method>
    <method name="visit" return="V"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="binding" type="com.google.inject.servlet.InstanceFilterBinding"/>
      <doc>
      <![CDATA[Visits a filter binding created by {@link ServletModule#filter} where
 {@link FilterKeyBindingBuilder#through} is called with a {@link Filter}.
 
 If multiple patterns were specified, this will be called multiple times.]]>
      </doc>
    </method>
    <method name="visit" return="V"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="binding" type="com.google.inject.servlet.LinkedServletBinding"/>
      <doc>
      <![CDATA[Visits a servlet binding created by {@link ServletModule#serve} where
 {@link ServletKeyBindingBuilder#with}, is called with a Class or Key.
 
 If multiple patterns were specified, this will be called multiple times.]]>
      </doc>
    </method>
    <method name="visit" return="V"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="binding" type="com.google.inject.servlet.InstanceServletBinding"/>
      <doc>
      <![CDATA[Visits a servlet binding created by {@link ServletModule#serve} where 
 {@link ServletKeyBindingBuilder#with}, is called with an {@link HttpServlet}.
 
 If multiple patterns were specified, this will be called multiple times.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A visitor for the servlet extension.
 
 If your {@link BindingTargetVisitor} implements this interface, bindings created by using
 {@link ServletModule} will be visited through this interface.
 
 @since 3.0
 @author sameb@google.com (Sam Berlin)]]>
    </doc>
  </interface>
  <!-- end interface com.google.inject.servlet.ServletModuleTargetVisitor -->
  <!-- start class com.google.inject.servlet.ServletScopes -->
  <class name="ServletScopes" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="continueRequest" return="java.util.concurrent.Callable&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="You probably want to use {@code transferRequest} instead">
      <param name="callable" type="java.util.concurrent.Callable&lt;T&gt;"/>
      <param name="seedMap" type="java.util.Map&lt;com.google.inject.Key&lt;?&gt;, java.lang.Object&gt;"/>
      <doc>
      <![CDATA[Wraps the given callable in a contextual callable that "continues" the
 HTTP request in another thread. This acts as a way of transporting
 request context data from the request processing thread to to worker
 threads.
 <p>
 There are some limitations:
 <ul>
   <li>Derived objects (i.e. anything marked @RequestScoped will not be
      transported.</li>
   <li>State changes to the HttpServletRequest after this method is called
      will not be seen in the continued thread.</li>
   <li>Only the HttpServletRequest, ServletContext and request parameter
      map are available in the continued thread. The response and session
      are not available.</li>
 </ul>

 <p>The returned callable will throw a {@link ScopingException} when called
 if the HTTP request scope is still active on the current thread.

 @param callable code to be executed in another thread, which depends on
     the request scope.
 @param seedMap the initial set of scoped instances for Guice to seed the
     request scope with.  To seed a key with null, use {@code null} as
     the value.
 @return a callable that will invoke the given callable, making the request
     context available to it.
 @throws OutOfScopeException if this method is called from a non-request
     thread, or if the request has completed.
 
 @since 3.0
 @deprecated You probably want to use {@code transferRequest} instead]]>
      </doc>
    </method>
    <method name="transferRequest" return="java.util.concurrent.Callable&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="callable" type="java.util.concurrent.Callable&lt;T&gt;"/>
      <doc>
      <![CDATA[Wraps the given callable in a contextual callable that "transfers" the
 request to another thread. This acts as a way of transporting
 request context data from the current thread to a future thread.

 <p>As opposed to {@link #continueRequest}, this method propagates all
 existing scoped objects. The primary use case is in server implementations
 where you can detach the request processing thread while waiting for data,
 and reattach to a different thread to finish processing at a later time.

 <p>Because request-scoped objects are not typically thread-safe, the
 callable returned by this method must not be run on a different thread
 until the current request scope has terminated. The returned callable will
 block until the current thread has released the request scope.

 @param callable code to be executed in another thread, which depends on
     the request scope.
 @return a callable that will invoke the given callable, making the request
     context available to it.
 @throws OutOfScopeException if this method is called from a non-request
     thread, or if the request has completed.
 @since 4.0]]>
      </doc>
    </method>
    <method name="transferRequest" return="com.google.inject.servlet.RequestScoper"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns an object that "transfers" the request to another thread. This acts
 as a way of transporting request context data from the current thread to a
 future thread. The transferred scope is the one active for the thread that
 calls this method. A later call to {@code open()} activates the transferred
 the scope, including propagating any objects scoped at that time.

 <p>As opposed to {@link #continueRequest}, this method propagates all
 existing scoped objects. The primary use case is in server implementations
 where you can detach the request processing thread while waiting for data,
 and reattach to a different thread to finish processing at a later time.

 <p>Because request-scoped objects are not typically thread-safe, it is
 important to avoid applying the same request scope concurrently. The
 returned Scoper will block on open until the current thread has released
 the request scope.

 @return an object that when opened will initiate the request scope
 @throws OutOfScopeException if this method is called from a non-request
     thread, or if the request has completed.
 @since 4.1]]>
      </doc>
    </method>
    <method name="isRequestScoped" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="binding" type="com.google.inject.Binding&lt;?&gt;"/>
      <doc>
      <![CDATA[Returns true if {@code binding} is request-scoped. If the binding is a
 {@link com.google.inject.spi.LinkedKeyBinding linked key binding} and
 belongs to an injector (i. e. it was retrieved via
 {@link Injector#getBinding Injector.getBinding()}), then this method will
 also return true if the target binding is request-scoped.

 @since 4.0]]>
      </doc>
    </method>
    <method name="scopeRequest" return="java.util.concurrent.Callable&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="callable" type="java.util.concurrent.Callable&lt;T&gt;"/>
      <param name="seedMap" type="java.util.Map&lt;com.google.inject.Key&lt;?&gt;, java.lang.Object&gt;"/>
      <doc>
      <![CDATA[Scopes the given callable inside a request scope. This is not the same
 as the HTTP request scope, but is used if no HTTP request scope is in
 progress. In this way, keys can be scoped as @RequestScoped and exist
 in non-HTTP requests (for example: RPC requests) as well as in HTTP
 request threads.

 <p>The returned callable will throw a {@link ScopingException} when called
 if there is a request scope already active on the current thread.

 @param callable code to be executed which depends on the request scope.
     Typically in another thread, but not necessarily so.
 @param seedMap the initial set of scoped instances for Guice to seed the
     request scope with.  To seed a key with null, use {@code null} as
     the value.
 @return a callable that when called will run inside the a request scope
     that exposes the instances in the {@code seedMap} as scoped keys.
 @since 3.0]]>
      </doc>
    </method>
    <method name="scopeRequest" return="com.google.inject.servlet.RequestScoper"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="seedMap" type="java.util.Map&lt;com.google.inject.Key&lt;?&gt;, java.lang.Object&gt;"/>
      <doc>
      <![CDATA[Returns an object that will apply request scope to a block of code. This is
 not the same as the HTTP request scope, but is used if no HTTP request
 scope is in progress. In this way, keys can be scoped as @RequestScoped and
 exist in non-HTTP requests (for example: RPC requests) as well as in HTTP
 request threads.

 <p>The returned object will throw a {@link ScopingException} when opened
 if there is a request scope already active on the current thread.

 @param seedMap the initial set of scoped instances for Guice to seed the
     request scope with.  To seed a key with null, use {@code null} as
     the value.
 @return an object that when opened will initiate the request scope
 @since 4.1]]>
      </doc>
    </method>
    <field name="REQUEST" type="com.google.inject.Scope"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[HTTP servlet request scope.]]>
      </doc>
    </field>
    <field name="SESSION" type="com.google.inject.Scope"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[HTTP session scope.]]>
      </doc>
    </field>
    <doc>
    <![CDATA[Servlet scopes.

 @author crazybob@google.com (Bob Lee)]]>
    </doc>
  </class>
  <!-- end class com.google.inject.servlet.ServletScopes -->
  <!-- start class com.google.inject.servlet.SessionScoped -->
  <class name="SessionScoped"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.lang.annotation.Annotation"/>
    <doc>
    <![CDATA[Apply this to implementation classes when you want one instance per session.

 @see com.google.inject.Scopes#SINGLETON
 @author crazybob@google.com (Bob Lee)]]>
    </doc>
  </class>
  <!-- end class com.google.inject.servlet.SessionScoped -->
  <!-- start class com.google.inject.servlet.UriPatternType -->
  <class name="UriPatternType" extends="java.lang.Enum&lt;com.google.inject.servlet.UriPatternType&gt;"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="values" return="com.google.inject.servlet.UriPatternType[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="com.google.inject.servlet.UriPatternType"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <doc>
    <![CDATA[An enumeration of the available URI-pattern matching styles
 
 @since 3.0]]>
    </doc>
  </class>
  <!-- end class com.google.inject.servlet.UriPatternType -->
</package>
<package name="com.google.inject.spi">
  <!-- start interface com.google.inject.spi.BindingScopingVisitor -->
  <interface name="BindingScopingVisitor"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="visitEagerSingleton" return="V"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Visit an eager singleton or single instance. This scope strategy is found on both module and
 injector bindings.]]>
      </doc>
    </method>
    <method name="visitScope" return="V"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="scope" type="com.google.inject.Scope"/>
      <doc>
      <![CDATA[Visit a scope instance. This scope strategy is found on both module and injector bindings.]]>
      </doc>
    </method>
    <method name="visitScopeAnnotation" return="V"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="scopeAnnotation" type="java.lang.Class&lt;? extends java.lang.annotation.Annotation&gt;"/>
      <doc>
      <![CDATA[Visit a scope annotation. This scope strategy is found only on module bindings. The instance
 that implements this scope is registered by {@link com.google.inject.Binder#bindScope(Class,
 Scope) Binder.bindScope()}.]]>
      </doc>
    </method>
    <method name="visitNoScoping" return="V"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Visit an unspecified or unscoped strategy. On a module, this strategy indicates that the
 injector should use scoping annotations to find a scope. On an injector, it indicates that
 no scope is applied to the binding. An unscoped binding will behave like a scoped one when it
 is linked to a scoped binding.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Visits each of the strategies used to scope an injection.

 @param <V> any type to be returned by the visit method. Use {@link Void} with
     {@code return null} if no return type is needed.
 @since 2.0]]>
    </doc>
  </interface>
  <!-- end interface com.google.inject.spi.BindingScopingVisitor -->
  <!-- start interface com.google.inject.spi.BindingTargetVisitor -->
  <interface name="BindingTargetVisitor"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="visit" return="V"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="binding" type="com.google.inject.spi.InstanceBinding&lt;? extends T&gt;"/>
      <doc>
      <![CDATA[Visit a instance binding. The same instance is returned for every injection. This target is
 found in both module and injector bindings.]]>
      </doc>
    </method>
    <method name="visit" return="V"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="binding" type="com.google.inject.spi.ProviderInstanceBinding&lt;? extends T&gt;"/>
      <doc>
      <![CDATA[Visit a provider instance binding. The provider's {@code get} method is invoked to resolve
 injections. This target is found in both module and injector bindings.]]>
      </doc>
    </method>
    <method name="visit" return="V"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="binding" type="com.google.inject.spi.ProviderKeyBinding&lt;? extends T&gt;"/>
      <doc>
      <![CDATA[Visit a provider key binding. To resolve injections, the provider key is first resolved, then
 that provider's {@code get} method is invoked. This target is found in both module and injector
 bindings.]]>
      </doc>
    </method>
    <method name="visit" return="V"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="binding" type="com.google.inject.spi.LinkedKeyBinding&lt;? extends T&gt;"/>
      <doc>
      <![CDATA[Visit a linked key binding. The other key's binding is used to resolve injections. This
 target is found in both module and injector bindings.]]>
      </doc>
    </method>
    <method name="visit" return="V"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="binding" type="com.google.inject.spi.ExposedBinding&lt;? extends T&gt;"/>
      <doc>
      <![CDATA[Visit a binding to a key exposed from an enclosed private environment. This target is only
 found in injector bindings.]]>
      </doc>
    </method>
    <method name="visit" return="V"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="binding" type="com.google.inject.spi.UntargettedBinding&lt;? extends T&gt;"/>
      <doc>
      <![CDATA[Visit an untargetted binding. This target is found only on module bindings. It indicates
 that the injector should use its implicit binding strategies to resolve injections.]]>
      </doc>
    </method>
    <method name="visit" return="V"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="binding" type="com.google.inject.spi.ConstructorBinding&lt;? extends T&gt;"/>
      <doc>
      <![CDATA[Visit a constructor binding. To resolve injections, an instance is instantiated by invoking
 {@code constructor}. This target is found only on injector bindings.]]>
      </doc>
    </method>
    <method name="visit" return="V"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="binding" type="com.google.inject.spi.ConvertedConstantBinding&lt;? extends T&gt;"/>
      <doc>
      <![CDATA[Visit a binding created from converting a bound instance to a new type. The source binding
 has the same binding annotation but a different type. This target is found only on injector
 bindings.]]>
      </doc>
    </method>
    <method name="visit" return="V"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="binding" type="com.google.inject.spi.ProviderBinding&lt;? extends T&gt;"/>
      <doc>
      <![CDATA[Visit a binding to a {@link com.google.inject.Provider} that delegates to the binding for the
 provided type. This target is found only on injector bindings.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Visits each of the strategies used to find an instance to satisfy an injection.

 @param <V> any type to be returned by the visit method. Use {@link Void} with
     {@code return null} if no return type is needed.
 @since 2.0]]>
    </doc>
  </interface>
  <!-- end interface com.google.inject.spi.BindingTargetVisitor -->
  <!-- start interface com.google.inject.spi.ConstructorBinding -->
  <interface name="ConstructorBinding"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.inject.Binding&lt;T&gt;"/>
    <implements name="com.google.inject.spi.HasDependencies"/>
    <method name="getConstructor" return="com.google.inject.spi.InjectionPoint"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the constructor this binding injects.]]>
      </doc>
    </method>
    <method name="getInjectableMembers" return="java.util.Set&lt;com.google.inject.spi.InjectionPoint&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns all instance method and field injection points on {@code type}.

 @return a possibly empty set of injection points. The set has a specified iteration order. All
      fields are returned and then all methods. Within the fields, supertype fields are returned
      before subtype fields. Similarly, supertype methods are returned before subtype methods.]]>
      </doc>
    </method>
    <method name="getMethodInterceptors" return="java.util.Map&lt;java.lang.reflect.Method, java.util.List&lt;org.aopalliance.intercept.MethodInterceptor&gt;&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the interceptors applied to each method, in the order that they will be applied.

 @return a possibly empty map]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A binding to the constructor of a concrete clss. To resolve injections, an instance is
 instantiated by invoking the constructor.

 @author jessewilson@google.com (Jesse Wilson)
 @since 2.0]]>
    </doc>
  </interface>
  <!-- end interface com.google.inject.spi.ConstructorBinding -->
  <!-- start interface com.google.inject.spi.ConvertedConstantBinding -->
  <interface name="ConvertedConstantBinding"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.inject.Binding&lt;T&gt;"/>
    <implements name="com.google.inject.spi.HasDependencies"/>
    <method name="getValue" return="T"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the converted value.]]>
      </doc>
    </method>
    <method name="getTypeConverterBinding" return="com.google.inject.spi.TypeConverterBinding"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the type converter binding used to convert the constant.
 
 @since 3.0]]>
      </doc>
    </method>
    <method name="getSourceKey" return="com.google.inject.Key&lt;java.lang.String&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the key for the source binding. That binding can be retrieved from an injector using
 {@link com.google.inject.Injector#getBinding(Key) Injector.getBinding(key)}.]]>
      </doc>
    </method>
    <method name="getDependencies" return="java.util.Set&lt;com.google.inject.spi.Dependency&lt;?&gt;&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a singleton set containing only the converted key.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A binding created from converting a bound instance to a new type. The source binding has the same
 binding annotation but a different type.

 @author jessewilson@google.com (Jesse Wilson)
 @since 2.0]]>
    </doc>
  </interface>
  <!-- end interface com.google.inject.spi.ConvertedConstantBinding -->
  <!-- start class com.google.inject.spi.DefaultBindingScopingVisitor -->
  <class name="DefaultBindingScopingVisitor" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.inject.spi.BindingScopingVisitor&lt;V&gt;"/>
    <constructor name="DefaultBindingScopingVisitor"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="visitOther" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Default visit implementation. Returns {@code null}.]]>
      </doc>
    </method>
    <method name="visitEagerSingleton" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="visitScope" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="scope" type="com.google.inject.Scope"/>
    </method>
    <method name="visitScopeAnnotation" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="scopeAnnotation" type="java.lang.Class&lt;? extends java.lang.annotation.Annotation&gt;"/>
    </method>
    <method name="visitNoScoping" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[No-op visitor for subclassing. All interface methods simply delegate to
 {@link #visitOther()}, returning its result.

 @param <V> any type to be returned by the visit method. Use {@link Void} with
     {@code return null} if no return type is needed.
 
 @author jessewilson@google.com (Jesse Wilson)
 @since 2.0]]>
    </doc>
  </class>
  <!-- end class com.google.inject.spi.DefaultBindingScopingVisitor -->
  <!-- start class com.google.inject.spi.DefaultBindingTargetVisitor -->
  <class name="DefaultBindingTargetVisitor" extends="java.lang.Object"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.inject.spi.BindingTargetVisitor&lt;T, V&gt;"/>
    <constructor name="DefaultBindingTargetVisitor"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="visitOther" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="binding" type="com.google.inject.Binding&lt;? extends T&gt;"/>
      <doc>
      <![CDATA[Default visit implementation. Returns {@code null}.]]>
      </doc>
    </method>
    <method name="visit" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="instanceBinding" type="com.google.inject.spi.InstanceBinding&lt;? extends T&gt;"/>
    </method>
    <method name="visit" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="providerInstanceBinding" type="com.google.inject.spi.ProviderInstanceBinding&lt;? extends T&gt;"/>
    </method>
    <method name="visit" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="providerKeyBinding" type="com.google.inject.spi.ProviderKeyBinding&lt;? extends T&gt;"/>
    </method>
    <method name="visit" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="linkedKeyBinding" type="com.google.inject.spi.LinkedKeyBinding&lt;? extends T&gt;"/>
    </method>
    <method name="visit" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="exposedBinding" type="com.google.inject.spi.ExposedBinding&lt;? extends T&gt;"/>
    </method>
    <method name="visit" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="untargettedBinding" type="com.google.inject.spi.UntargettedBinding&lt;? extends T&gt;"/>
    </method>
    <method name="visit" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="constructorBinding" type="com.google.inject.spi.ConstructorBinding&lt;? extends T&gt;"/>
    </method>
    <method name="visit" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="convertedConstantBinding" type="com.google.inject.spi.ConvertedConstantBinding&lt;? extends T&gt;"/>
    </method>
    <method name="visit" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="providerBinding" type="com.google.inject.spi.ProviderBinding&lt;? extends T&gt;"/>
    </method>
    <doc>
    <![CDATA[No-op visitor for subclassing. All interface methods simply delegate to {@link
 #visitOther(Binding)}, returning its result.

 @param <V> any type to be returned by the visit method. Use {@link Void} with
     {@code return null} if no return type is needed.

 @author jessewilson@google.com (Jesse Wilson)
 @since 2.0]]>
    </doc>
  </class>
  <!-- end class com.google.inject.spi.DefaultBindingTargetVisitor -->
  <!-- start class com.google.inject.spi.DefaultElementVisitor -->
  <class name="DefaultElementVisitor" extends="java.lang.Object"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.inject.spi.ElementVisitor&lt;V&gt;"/>
    <constructor name="DefaultElementVisitor"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="visitOther" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="element" type="com.google.inject.spi.Element"/>
      <doc>
      <![CDATA[Default visit implementation. Returns {@code null}.]]>
      </doc>
    </method>
    <method name="visit" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="message" type="com.google.inject.spi.Message"/>
    </method>
    <method name="visit" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="binding" type="com.google.inject.Binding&lt;T&gt;"/>
    </method>
    <method name="visit" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="interceptorBinding" type="com.google.inject.spi.InterceptorBinding"/>
    </method>
    <method name="visit" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="scopeBinding" type="com.google.inject.spi.ScopeBinding"/>
    </method>
    <method name="visit" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="typeConverterBinding" type="com.google.inject.spi.TypeConverterBinding"/>
    </method>
    <method name="visit" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="providerLookup" type="com.google.inject.spi.ProviderLookup&lt;T&gt;"/>
    </method>
    <method name="visit" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="injectionRequest" type="com.google.inject.spi.InjectionRequest&lt;?&gt;"/>
    </method>
    <method name="visit" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="staticInjectionRequest" type="com.google.inject.spi.StaticInjectionRequest"/>
    </method>
    <method name="visit" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="privateElements" type="com.google.inject.spi.PrivateElements"/>
    </method>
    <method name="visit" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="lookup" type="com.google.inject.spi.MembersInjectorLookup&lt;T&gt;"/>
    </method>
    <method name="visit" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="binding" type="com.google.inject.spi.TypeListenerBinding"/>
    </method>
    <method name="visit" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="binding" type="com.google.inject.spi.ProvisionListenerBinding"/>
    </method>
    <method name="visit" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="option" type="com.google.inject.spi.DisableCircularProxiesOption"/>
    </method>
    <method name="visit" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="option" type="com.google.inject.spi.RequireExplicitBindingsOption"/>
    </method>
    <method name="visit" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="option" type="com.google.inject.spi.RequireAtInjectOnConstructorsOption"/>
    </method>
    <method name="visit" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="option" type="com.google.inject.spi.RequireExactBindingAnnotationsOption"/>
    </method>
    <method name="visit" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="binding" type="com.google.inject.spi.ModuleAnnotatedMethodScannerBinding"/>
    </method>
    <doc>
    <![CDATA[No-op visitor for subclassing. All interface methods simply delegate to
 {@link #visitOther(Element)}, returning its result.

 @param <V> any type to be returned by the visit method. Use {@link Void} with
     {@code return null} if no return type is needed.

 @author sberlin@gmail.com (Sam Berlin)
 @since 2.0]]>
    </doc>
  </class>
  <!-- end class com.google.inject.spi.DefaultElementVisitor -->
  <!-- start class com.google.inject.spi.Dependency -->
  <class name="Dependency" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="get" return="com.google.inject.spi.Dependency&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="com.google.inject.Key&lt;T&gt;"/>
      <doc>
      <![CDATA[Returns a new dependency that is not attached to an injection point. The returned dependency is
 nullable.]]>
      </doc>
    </method>
    <method name="forInjectionPoints" return="java.util.Set&lt;com.google.inject.spi.Dependency&lt;?&gt;&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="injectionPoints" type="java.util.Set&lt;com.google.inject.spi.InjectionPoint&gt;"/>
      <doc>
      <![CDATA[Returns the dependencies from the given injection points.]]>
      </doc>
    </method>
    <method name="getKey" return="com.google.inject.Key&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the key to the binding that satisfies this dependency.]]>
      </doc>
    </method>
    <method name="isNullable" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns true if null is a legal value for this dependency.]]>
      </doc>
    </method>
    <method name="getInjectionPoint" return="com.google.inject.spi.InjectionPoint"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the injection point to which this dependency belongs, or null if this dependency isn't
 attached to a particular injection point.]]>
      </doc>
    </method>
    <method name="getParameterIndex" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the index of this dependency in the injection point's parameter list, or {@code -1} if
 this dependency does not belong to a parameter list. Only method and constuctor dependencies
 are elements in a parameter list.]]>
      </doc>
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="o" type="java.lang.Object"/>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[A variable that can be resolved by an injector.

 <p>Use {@link #get} to build a freestanding dependency, or {@link InjectionPoint} to build one
 that's attached to a constructor, method or field.

 @author crazybob@google.com (Bob Lee)
 @author jessewilson@google.com (Jesse Wilson)
 @since 2.0]]>
    </doc>
  </class>
  <!-- end class com.google.inject.spi.Dependency -->
  <!-- start class com.google.inject.spi.DependencyAndSource -->
  <class name="DependencyAndSource" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="DependencyAndSource" type="com.google.inject.spi.Dependency&lt;?&gt;, java.lang.Object"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getDependency" return="com.google.inject.spi.Dependency&lt;?&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the Dependency, if one exists. For anything that can be referenced
 by {@link Injector#getBinding}, a dependency exists. A dependency will not
 exist (and this will return null) for types initialized with
 {@link Binder#requestInjection} or {@link Injector#injectMembers(Object)},
 nor will it exist for objects injected into Providers bound with
 LinkedBindingBuilder#toProvider(Provider).]]>
      </doc>
    </method>
    <method name="getBindingSource" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a string describing where this dependency was bound. If the binding
 was just-in-time, there is no valid binding source, so this describes the
 class in question.]]>
      </doc>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[A combination of a {@link Dependency} and the {@link Binding#getSource()
 source} where the dependency was bound.
 
 @author sameb@google.com (Sam Berlin)
 @since 4.0]]>
    </doc>
  </class>
  <!-- end class com.google.inject.spi.DependencyAndSource -->
  <!-- start class com.google.inject.spi.DisableCircularProxiesOption -->
  <class name="DisableCircularProxiesOption" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.inject.spi.Element"/>
    <method name="getSource" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="applyTo"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="binder" type="com.google.inject.Binder"/>
    </method>
    <method name="acceptVisitor" return="T"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="visitor" type="com.google.inject.spi.ElementVisitor&lt;T&gt;"/>
    </method>
    <doc>
    <![CDATA[A request to disable circular proxies.

 @author sameb@google.com (Sam Berlin)
 @since 3.0]]>
    </doc>
  </class>
  <!-- end class com.google.inject.spi.DisableCircularProxiesOption -->
  <!-- start interface com.google.inject.spi.Element -->
  <interface name="Element"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="getSource" return="java.lang.Object"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns an arbitrary object containing information about the "place" where this element was
 configured. Used by Guice in the production of descriptive error messages.

 <p>Tools might specially handle types they know about; {@code StackTraceElement} is a good
 example. Tools should simply call {@code toString()} on the source object if the type is
 unfamiliar.]]>
      </doc>
    </method>
    <method name="acceptVisitor" return="T"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="visitor" type="com.google.inject.spi.ElementVisitor&lt;T&gt;"/>
      <doc>
      <![CDATA[Accepts an element visitor. Invokes the visitor method specific to this element's type.

 @param visitor to call back on]]>
      </doc>
    </method>
    <method name="applyTo"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="binder" type="com.google.inject.Binder"/>
      <doc>
      <![CDATA[Writes this module element to the given binder (optional operation).

 @param binder to apply configuration element to
 @throws UnsupportedOperationException if the {@code applyTo} method is not supported by this
     element.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A core component of a module or injector.

 <p>The elements of a module can be inspected, validated and rewritten. Use {@link
 Elements#getElements(com.google.inject.Module[]) Elements.getElements()} to read the elements
 from a module, and {@link Elements#getModule(Iterable) Elements.getModule()} to rewrite them.
 This can be used for static analysis and generation of Guice modules.

 <p>The elements of an injector can be inspected and exercised. Use {@link
 com.google.inject.Injector#getBindings Injector.getBindings()} to reflect on Guice injectors.

 @author jessewilson@google.com (Jesse Wilson)
 @author crazybob@google.com (Bob Lee)
 @since 2.0]]>
    </doc>
  </interface>
  <!-- end interface com.google.inject.spi.Element -->
  <!-- start class com.google.inject.spi.Elements -->
  <class name="Elements" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="Elements"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getElements" return="java.util.List&lt;com.google.inject.spi.Element&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="modules" type="com.google.inject.Module[]"/>
      <doc>
      <![CDATA[Records the elements executed by {@code modules}.]]>
      </doc>
    </method>
    <method name="getElements" return="java.util.List&lt;com.google.inject.spi.Element&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="stage" type="com.google.inject.Stage"/>
      <param name="modules" type="com.google.inject.Module[]"/>
      <doc>
      <![CDATA[Records the elements executed by {@code modules}.]]>
      </doc>
    </method>
    <method name="getElements" return="java.util.List&lt;com.google.inject.spi.Element&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="modules" type="java.lang.Iterable&lt;? extends com.google.inject.Module&gt;"/>
      <doc>
      <![CDATA[Records the elements executed by {@code modules}.]]>
      </doc>
    </method>
    <method name="getElements" return="java.util.List&lt;com.google.inject.spi.Element&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="stage" type="com.google.inject.Stage"/>
      <param name="modules" type="java.lang.Iterable&lt;? extends com.google.inject.Module&gt;"/>
      <doc>
      <![CDATA[Records the elements executed by {@code modules}.]]>
      </doc>
    </method>
    <method name="getModule" return="com.google.inject.Module"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="elements" type="java.lang.Iterable&lt;? extends com.google.inject.spi.Element&gt;"/>
      <doc>
      <![CDATA[Returns the module composed of {@code elements}.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Exposes elements of a module so they can be inspected, validated or {@link
 Element#applyTo(Binder) rewritten}.

 @author jessewilson@google.com (Jesse Wilson)
 @since 2.0]]>
    </doc>
  </class>
  <!-- end class com.google.inject.spi.Elements -->
  <!-- start class com.google.inject.spi.ElementSource -->
  <class name="ElementSource" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="getOriginalElementSource" return="com.google.inject.spi.ElementSource"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the {@link ElementSource} of the element this was created or copied from. If this was
 not created or copied from another element, returns {@code null}.]]>
      </doc>
    </method>
    <method name="getDeclaringSource" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a single location in source code that defines the element. It can be any object
 such as {@link java.lang.reflect.Constructor}, {@link java.lang.reflect.Method},
 {@link java.lang.reflect.Field}, {@link StackTraceElement}, etc. For
 example, if the element is created from a method annotated by {@literal @Provides}, the
 declaring source of element would be the method itself.]]>
      </doc>
    </method>
    <method name="getModuleClassNames" return="java.util.List&lt;java.lang.String&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the class names of modules involved in creating this {@link Element}. The first
 element (index 0) is the class name of module that defined the element, and the last element
 is the class name of root module.]]>
      </doc>
    </method>
    <method name="getModuleConfigurePositionsInStackTrace" return="java.util.List&lt;java.lang.Integer&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the position of {@link com.google.inject.Module#configure configure(Binder)} method
 call in the {@link #getStackTrace stack trace} for modules that their classes returned by
 {@link #getModuleClassNames}. For example, if the stack trace looks like the following:
 <p>
 {@code
  0 - Binder.bind(),
  1 - ModuleTwo.configure(),
  2 - Binder.install(),
  3 - ModuleOne.configure(),
  4 - theRest(). 
 }
 <p>
 1 and 3 are returned.
 <p>
 In the cases where stack trace is not available (i.e., the stack trace was not collected),
 it returns -1 for all module positions.]]>
      </doc>
    </method>
    <method name="getStackTrace" return="java.lang.StackTraceElement[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the sequence of method calls that ends at one of {@link com.google.inject.Binder}
 {@code bindXXX()} methods and eventually defines the element. Note that
 {@link #getStackTrace} lists {@link StackTraceElement StackTraceElements} in reverse
 chronological order. The first element (index zero) is the last method call and the last
 element is the first method invocation. In the cases where stack trace is not available
 (i.e.,the stack trace was not collected), it returns an empty array.]]>
      </doc>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns {@code getDeclaringSource().toString()} value.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Contains information about where and how an {@link Element element} was
 bound.
 <p>
 The {@link #getDeclaringSource() declaring source} refers to a location in
 source code that defines the Guice {@link Element element}. For example, if
 the element is created from a method annotated by {@literal @Provides}, the
 declaring source of element would be the method itself.
 <p>
 The {@link #getStackTrace()} refers to the sequence of calls ends at one of
 {@link com.google.inject.Binder} {@code bindXXX()} methods and eventually
 defines the element. Note that {@link #getStackTrace()} lists
 {@link StackTraceElement StackTraceElements} in reverse chronological order.
 The first element (index zero) is the last method call and the last element
 is the first method invocation. By default, the stack trace is not collected.
 The default behavior can be changed by setting the
 {@code guice_include_stack_traces} flag value. The value can be either
 {@code OFF}, {@code ONLY_FOR_DECLARING_SOURCE} or {@code COMPLETE}. Note that
 collecting stack traces for every binding can cause a performance hit when
 the injector is created.
 <p>
 The sequence of class names of {@link com.google.inject.Module modules}
 involved in the element creation can be retrieved by
 {@link #getModuleClassNames()}. Similar to {@link #getStackTrace()}, the
 order is reverse chronological. The first module (index 0) is the module that
 installs the {@link Element element}. The last module is the root module.
 <p>
 In order to support the cases where a Guice {@link Element element} is
 created from another Guice {@link Element element} (original) (e.g., by
 {@link Element#applyTo}), it also provides a reference to the original
 element source ({@link #getOriginalElementSource()}).

 @since 4.0]]>
    </doc>
  </class>
  <!-- end class com.google.inject.spi.ElementSource -->
  <!-- start interface com.google.inject.spi.ElementVisitor -->
  <interface name="ElementVisitor"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="visit" return="V"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="binding" type="com.google.inject.Binding&lt;T&gt;"/>
      <doc>
      <![CDATA[Visit a mapping from a key (type and optional annotation) to the strategy for getting
 instances of the type.]]>
      </doc>
    </method>
    <method name="visit" return="V"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="binding" type="com.google.inject.spi.InterceptorBinding"/>
      <doc>
      <![CDATA[Visit a registration of interceptors for matching methods of matching classes.]]>
      </doc>
    </method>
    <method name="visit" return="V"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="binding" type="com.google.inject.spi.ScopeBinding"/>
      <doc>
      <![CDATA[Visit a registration of a scope annotation with the scope that implements it.]]>
      </doc>
    </method>
    <method name="visit" return="V"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="binding" type="com.google.inject.spi.TypeConverterBinding"/>
      <doc>
      <![CDATA[Visit a registration of type converters for matching target types.]]>
      </doc>
    </method>
    <method name="visit" return="V"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="request" type="com.google.inject.spi.InjectionRequest&lt;?&gt;"/>
      <doc>
      <![CDATA[Visit a request to inject the instance fields and methods of an instance.]]>
      </doc>
    </method>
    <method name="visit" return="V"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="request" type="com.google.inject.spi.StaticInjectionRequest"/>
      <doc>
      <![CDATA[Visit a request to inject the static fields and methods of type.]]>
      </doc>
    </method>
    <method name="visit" return="V"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="lookup" type="com.google.inject.spi.ProviderLookup&lt;T&gt;"/>
      <doc>
      <![CDATA[Visit a lookup of the provider for a type.]]>
      </doc>
    </method>
    <method name="visit" return="V"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="lookup" type="com.google.inject.spi.MembersInjectorLookup&lt;T&gt;"/>
      <doc>
      <![CDATA[Visit a lookup of the members injector.]]>
      </doc>
    </method>
    <method name="visit" return="V"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="message" type="com.google.inject.spi.Message"/>
      <doc>
      <![CDATA[Visit an error message and the context in which it occured.]]>
      </doc>
    </method>
    <method name="visit" return="V"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="elements" type="com.google.inject.spi.PrivateElements"/>
      <doc>
      <![CDATA[Visit a collection of configuration elements for a {@linkplain com.google.inject.PrivateBinder
 private binder}.]]>
      </doc>
    </method>
    <method name="visit" return="V"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="binding" type="com.google.inject.spi.TypeListenerBinding"/>
      <doc>
      <![CDATA[Visit an injectable type listener binding.]]>
      </doc>
    </method>
    <method name="visit" return="V"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="binding" type="com.google.inject.spi.ProvisionListenerBinding"/>
      <doc>
      <![CDATA[Visit a provision listener binding.

 @since 4.0]]>
      </doc>
    </method>
    <method name="visit" return="V"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="option" type="com.google.inject.spi.RequireExplicitBindingsOption"/>
      <doc>
      <![CDATA[Visit a require explicit bindings command.
 
 @since 3.0]]>
      </doc>
    </method>
    <method name="visit" return="V"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="option" type="com.google.inject.spi.DisableCircularProxiesOption"/>
      <doc>
      <![CDATA[Visit a disable circular proxies command.
 
 @since 3.0]]>
      </doc>
    </method>
    <method name="visit" return="V"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="option" type="com.google.inject.spi.RequireAtInjectOnConstructorsOption"/>
      <doc>
      <![CDATA[Visit a require explicit {@literal @}{@link Inject} command.
 
 @since 4.0]]>
      </doc>
    </method>
    <method name="visit" return="V"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="option" type="com.google.inject.spi.RequireExactBindingAnnotationsOption"/>
      <doc>
      <![CDATA[Visit a require exact binding annotations command.

 @since 4.0]]>
      </doc>
    </method>
    <method name="visit" return="V"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="binding" type="com.google.inject.spi.ModuleAnnotatedMethodScannerBinding"/>
      <doc>
      <![CDATA[Visits a {@link Binder#scanModulesForAnnotatedMethods} command.

 @since 4.0]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Visit elements.

 @param <V> any type to be returned by the visit method. Use {@link Void} with
     {@code return null} if no return type is needed.
 
 @since 2.0]]>
    </doc>
  </interface>
  <!-- end interface com.google.inject.spi.ElementVisitor -->
  <!-- start interface com.google.inject.spi.ExposedBinding -->
  <interface name="ExposedBinding"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.inject.Binding&lt;T&gt;"/>
    <implements name="com.google.inject.spi.HasDependencies"/>
    <method name="getPrivateElements" return="com.google.inject.spi.PrivateElements"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the enclosed environment that holds the original binding.]]>
      </doc>
    </method>
    <method name="applyTo"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="binder" type="com.google.inject.Binder"/>
      <doc>
      <![CDATA[Unsupported. Always throws {@link UnsupportedOperationException}.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A binding to a key exposed from an enclosed private environment.

 @author jessewilson@google.com (Jesse Wilson)
 @since 2.0]]>
    </doc>
  </interface>
  <!-- end interface com.google.inject.spi.ExposedBinding -->
  <!-- start interface com.google.inject.spi.HasDependencies -->
  <interface name="HasDependencies"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="getDependencies" return="java.util.Set&lt;com.google.inject.spi.Dependency&lt;?&gt;&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the known dependencies for this type. If this has dependencies whose values are not
 known statically, a dependency for the {@link com.google.inject.Injector Injector} will be
 included in the returned set.
 
 @return a possibly empty set]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Implemented by {@link com.google.inject.Binding bindings}, {@link com.google.inject.Provider
 providers} and instances that expose their dependencies explicitly.

 @author jessewilson@google.com (Jesse Wilson)
 @since 2.0]]>
    </doc>
  </interface>
  <!-- end interface com.google.inject.spi.HasDependencies -->
  <!-- start interface com.google.inject.spi.InjectionListener -->
  <interface name="InjectionListener"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="afterInjection"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="injectee" type="I"/>
      <doc>
      <![CDATA[Invoked by Guice after it injects the fields and methods of instance.

 @param injectee instance that Guice injected dependencies into]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Listens for injections into instances of type {@code I}. Useful for performing further
 injections, post-injection initialization, and more.

 @author crazybob@google.com (Bob Lee)
 @author jessewilson@google.com (Jesse Wilson)
 @since 2.0]]>
    </doc>
  </interface>
  <!-- end interface com.google.inject.spi.InjectionListener -->
  <!-- start class com.google.inject.spi.InjectionPoint -->
  <class name="InjectionPoint" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="getMember" return="java.lang.reflect.Member"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the injected constructor, field, or method.]]>
      </doc>
    </method>
    <method name="getDependencies" return="java.util.List&lt;com.google.inject.spi.Dependency&lt;?&gt;&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the dependencies for this injection point. If the injection point is for a method or
 constructor, the dependencies will correspond to that member's parameters. Field injection
 points always have a single dependency for the field itself.

 @return a possibly-empty list]]>
      </doc>
    </method>
    <method name="isOptional" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns true if this injection point shall be skipped if the injector cannot resolve bindings
 for all required dependencies. Both explicit bindings (as specified in a module), and implicit
 bindings ({@literal @}{@link com.google.inject.ImplementedBy ImplementedBy}, default
 constructors etc.) may be used to satisfy optional injection points.]]>
      </doc>
    </method>
    <method name="isToolable" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns true if the element is annotated with {@literal @}{@link Toolable}.
 
 @since 3.0]]>
      </doc>
    </method>
    <method name="getDeclaringType" return="com.google.inject.TypeLiteral&lt;?&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the generic type that defines this injection point. If the member exists on a
 parameterized type, the result will include more type information than the member's {@link
 Member#getDeclaringClass() raw declaring class}.
 
 @since 3.0]]>
      </doc>
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="o" type="java.lang.Object"/>
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="forConstructor" return="com.google.inject.spi.InjectionPoint"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="constructor" type="java.lang.reflect.Constructor&lt;T&gt;"/>
      <doc>
      <![CDATA[Returns a new injection point for the specified constructor. If the declaring type of {@code
 constructor} is parameterized (such as {@code List<T>}), prefer the overload that includes a
 type literal.

 @param constructor any single constructor present on {@code type}.
 
 @since 3.0]]>
      </doc>
    </method>
    <method name="forConstructor" return="com.google.inject.spi.InjectionPoint"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="constructor" type="java.lang.reflect.Constructor&lt;T&gt;"/>
      <param name="type" type="com.google.inject.TypeLiteral&lt;? extends T&gt;"/>
      <doc>
      <![CDATA[Returns a new injection point for the specified constructor of {@code type}.

 @param constructor any single constructor present on {@code type}.
 @param type the concrete type that defines {@code constructor}.
 
 @since 3.0]]>
      </doc>
    </method>
    <method name="forConstructorOf" return="com.google.inject.spi.InjectionPoint"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="com.google.inject.TypeLiteral&lt;?&gt;"/>
      <doc>
      <![CDATA[Returns a new injection point for the injectable constructor of {@code type}.

 @param type a concrete type with exactly one constructor annotated {@literal @}{@link Inject},
     or a no-arguments constructor that is not private.
 @throws ConfigurationException if there is no injectable constructor, more than one injectable
     constructor, or if parameters of the injectable constructor are malformed, such as a
     parameter with multiple binding annotations.]]>
      </doc>
    </method>
    <method name="forConstructorOf" return="com.google.inject.spi.InjectionPoint"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="java.lang.Class&lt;?&gt;"/>
      <doc>
      <![CDATA[Returns a new injection point for the injectable constructor of {@code type}.

 @param type a concrete type with exactly one constructor annotated {@literal @}{@link Inject},
     or a no-arguments constructor that is not private.
 @throws ConfigurationException if there is no injectable constructor, more than one injectable
     constructor, or if parameters of the injectable constructor are malformed, such as a
     parameter with multiple binding annotations.]]>
      </doc>
    </method>
    <method name="forMethod" return="com.google.inject.spi.InjectionPoint"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="method" type="java.lang.reflect.Method"/>
      <param name="type" type="com.google.inject.TypeLiteral&lt;T&gt;"/>
      <doc>
      <![CDATA[Returns a new injection point for the specified method of {@code type}.
 This is useful for extensions that need to build dependency graphs from
 arbitrary methods.

 @param method any single method present on {@code type}.
 @param type the concrete type that defines {@code method}.

 @since 4.0]]>
      </doc>
    </method>
    <method name="forStaticMethodsAndFields" return="java.util.Set&lt;com.google.inject.spi.InjectionPoint&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="com.google.inject.TypeLiteral&lt;?&gt;"/>
      <doc>
      <![CDATA[Returns all static method and field injection points on {@code type}.

 @return a possibly empty set of injection points. The set has a specified iteration order. All
      fields are returned and then all methods. Within the fields, supertype fields are returned
      before subtype fields. Similarly, supertype methods are returned before subtype methods.
 @throws ConfigurationException if there is a malformed injection point on {@code type}, such as
      a field with multiple binding annotations. The exception's {@link
      ConfigurationException#getPartialValue() partial value} is a {@code Set<InjectionPoint>}
      of the valid injection points.]]>
      </doc>
    </method>
    <method name="forStaticMethodsAndFields" return="java.util.Set&lt;com.google.inject.spi.InjectionPoint&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="java.lang.Class&lt;?&gt;"/>
      <doc>
      <![CDATA[Returns all static method and field injection points on {@code type}.

 @return a possibly empty set of injection points. The set has a specified iteration order. All
      fields are returned and then all methods. Within the fields, supertype fields are returned
      before subtype fields. Similarly, supertype methods are returned before subtype methods.
 @throws ConfigurationException if there is a malformed injection point on {@code type}, such as
      a field with multiple binding annotations. The exception's {@link
      ConfigurationException#getPartialValue() partial value} is a {@code Set<InjectionPoint>}
      of the valid injection points.]]>
      </doc>
    </method>
    <method name="forInstanceMethodsAndFields" return="java.util.Set&lt;com.google.inject.spi.InjectionPoint&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="com.google.inject.TypeLiteral&lt;?&gt;"/>
      <doc>
      <![CDATA[Returns all instance method and field injection points on {@code type}.

 @return a possibly empty set of injection points. The set has a specified iteration order. All
      fields are returned and then all methods. Within the fields, supertype fields are returned
      before subtype fields. Similarly, supertype methods are returned before subtype methods.
 @throws ConfigurationException if there is a malformed injection point on {@code type}, such as
      a field with multiple binding annotations. The exception's {@link
      ConfigurationException#getPartialValue() partial value} is a {@code Set<InjectionPoint>}
      of the valid injection points.]]>
      </doc>
    </method>
    <method name="forInstanceMethodsAndFields" return="java.util.Set&lt;com.google.inject.spi.InjectionPoint&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="java.lang.Class&lt;?&gt;"/>
      <doc>
      <![CDATA[Returns all instance method and field injection points on {@code type}.

 @return a possibly empty set of injection points. The set has a specified iteration order. All
      fields are returned and then all methods. Within the fields, supertype fields are returned
      before subtype fields. Similarly, supertype methods are returned before subtype methods.
 @throws ConfigurationException if there is a malformed injection point on {@code type}, such as
      a field with multiple binding annotations. The exception's {@link
      ConfigurationException#getPartialValue() partial value} is a {@code Set<InjectionPoint>}
      of the valid injection points.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A constructor, field or method that can receive injections. Typically this is a member with the
 {@literal @}{@link Inject} annotation. For non-private, no argument constructors, the member may
 omit the annotation.

 @author crazybob@google.com (Bob Lee)
 @since 2.0]]>
    </doc>
  </class>
  <!-- end class com.google.inject.spi.InjectionPoint -->
  <!-- start class com.google.inject.spi.InjectionRequest -->
  <class name="InjectionRequest" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.inject.spi.Element"/>
    <constructor name="InjectionRequest" type="java.lang.Object, com.google.inject.TypeLiteral&lt;T&gt;, T"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getSource" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getInstance" return="T"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getType" return="com.google.inject.TypeLiteral&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getInjectionPoints" return="java.util.Set&lt;com.google.inject.spi.InjectionPoint&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="ConfigurationException" type="com.google.inject.ConfigurationException"/>
      <doc>
      <![CDATA[Returns the instance methods and fields of {@code instance} that will be injected to fulfill
 this request.

 @return a possibly empty set of injection points. The set has a specified iteration order. All
      fields are returned and then all methods. Within the fields, supertype fields are returned
      before subtype fields. Similarly, supertype methods are returned before subtype methods.
 @throws ConfigurationException if there is a malformed injection point on the class of {@code
      instance}, such as a field with multiple binding annotations. The exception's {@link
      ConfigurationException#getPartialValue() partial value} is a {@code Set<InjectionPoint>}
      of the valid injection points.]]>
      </doc>
    </method>
    <method name="acceptVisitor" return="R"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="visitor" type="com.google.inject.spi.ElementVisitor&lt;R&gt;"/>
    </method>
    <method name="applyTo"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="binder" type="com.google.inject.Binder"/>
    </method>
    <doc>
    <![CDATA[A request to inject the instance fields and methods of an instance. Requests are created
 explicitly in a module using {@link com.google.inject.Binder#requestInjection(Object)
 requestInjection()} statements:
 <pre>
     requestInjection(serviceInstance);</pre>

 @author mikeward@google.com (Mike Ward)
 @since 2.0]]>
    </doc>
  </class>
  <!-- end class com.google.inject.spi.InjectionRequest -->
  <!-- start interface com.google.inject.spi.InstanceBinding -->
  <interface name="InstanceBinding"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.inject.Binding&lt;T&gt;"/>
    <implements name="com.google.inject.spi.HasDependencies"/>
    <method name="getInstance" return="T"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the user-supplied instance.]]>
      </doc>
    </method>
    <method name="getInjectionPoints" return="java.util.Set&lt;com.google.inject.spi.InjectionPoint&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the field and method injection points of the instance, injected at injector-creation
 time only.

 @return a possibly empty set]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A binding to a single instance. The same instance is returned for every injection.

 @author jessewilson@google.com (Jesse Wilson)
 @since 2.0]]>
    </doc>
  </interface>
  <!-- end interface com.google.inject.spi.InstanceBinding -->
  <!-- start class com.google.inject.spi.InterceptorBinding -->
  <class name="InterceptorBinding" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.inject.spi.Element"/>
    <method name="getSource" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getClassMatcher" return="com.google.inject.matcher.Matcher&lt;? super java.lang.Class&lt;?&gt;&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getMethodMatcher" return="com.google.inject.matcher.Matcher&lt;? super java.lang.reflect.Method&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getInterceptors" return="java.util.List&lt;org.aopalliance.intercept.MethodInterceptor&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="acceptVisitor" return="T"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="visitor" type="com.google.inject.spi.ElementVisitor&lt;T&gt;"/>
    </method>
    <method name="applyTo"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="binder" type="com.google.inject.Binder"/>
    </method>
    <doc>
    <![CDATA[Registration of interceptors for matching methods of matching classes. Instances are created
 explicitly in a module using {@link com.google.inject.Binder#bindInterceptor(
 Matcher, Matcher, MethodInterceptor[]) bindInterceptor()} statements:
 <pre>
     bindInterceptor(Matchers.subclassesOf(MyAction.class),
         Matchers.annotatedWith(Transactional.class),
         new MyTransactionInterceptor());</pre>

 or from an injectable type listener using {@link TypeEncounter#bindInterceptor(Matcher,
 org.aopalliance.intercept.MethodInterceptor[]) TypeEncounter.bindInterceptor()}.

 @author jessewilson@google.com (Jesse Wilson)
 @since 2.0]]>
    </doc>
  </class>
  <!-- end class com.google.inject.spi.InterceptorBinding -->
  <!-- start interface com.google.inject.spi.LinkedKeyBinding -->
  <interface name="LinkedKeyBinding"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.inject.Binding&lt;T&gt;"/>
    <method name="getLinkedKey" return="com.google.inject.Key&lt;? extends T&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the linked key used to resolve injections. That binding can be retrieved from an
 injector using {@link com.google.inject.Injector#getBinding(Key) Injector.getBinding(key)}.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A binding to a linked key. The other key's binding is used to resolve injections.

 @author jessewilson@google.com (Jesse Wilson)
 @since 2.0]]>
    </doc>
  </interface>
  <!-- end interface com.google.inject.spi.LinkedKeyBinding -->
  <!-- start class com.google.inject.spi.MembersInjectorLookup -->
  <class name="MembersInjectorLookup" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.inject.spi.Element"/>
    <constructor name="MembersInjectorLookup" type="java.lang.Object, com.google.inject.TypeLiteral&lt;T&gt;"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getSource" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getType" return="com.google.inject.TypeLiteral&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the type containing the members to be injected.]]>
      </doc>
    </method>
    <method name="acceptVisitor" return="T"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="visitor" type="com.google.inject.spi.ElementVisitor&lt;T&gt;"/>
    </method>
    <method name="initializeDelegate"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="delegate" type="com.google.inject.MembersInjector&lt;T&gt;"/>
      <doc>
      <![CDATA[Sets the actual members injector.

 @throws IllegalStateException if the delegate is already set]]>
      </doc>
    </method>
    <method name="applyTo"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="binder" type="com.google.inject.Binder"/>
    </method>
    <method name="getDelegate" return="com.google.inject.MembersInjector&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the delegate members injector, or {@code null} if it has not yet been initialized.
 The delegate will be initialized when this element is processed, or otherwise used to create
 an injector.]]>
      </doc>
    </method>
    <method name="getMembersInjector" return="com.google.inject.MembersInjector&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the looked up members injector. The result is not valid until this lookup has been
 initialized, which usually happens when the injector is created. The members injector will
 throw an {@code IllegalStateException} if you try to use it beforehand.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A lookup of the members injector for a type. Lookups are created explicitly in a module using
 {@link com.google.inject.Binder#getMembersInjector(Class) getMembersInjector()} statements:
 <pre>
     MembersInjector&lt;PaymentService&gt; membersInjector
         = getMembersInjector(PaymentService.class);</pre>

 @author crazybob@google.com (Bob Lee)
 @since 2.0]]>
    </doc>
  </class>
  <!-- end class com.google.inject.spi.MembersInjectorLookup -->
  <!-- start class com.google.inject.spi.Message -->
  <class name="Message" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="java.io.Serializable"/>
    <implements name="com.google.inject.spi.Element"/>
    <constructor name="Message" type="java.util.List&lt;java.lang.Object&gt;, java.lang.String, java.lang.Throwable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@since 2.0]]>
      </doc>
    </constructor>
    <constructor name="Message" type="java.lang.String, java.lang.Throwable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@since 4.0]]>
      </doc>
    </constructor>
    <constructor name="Message" type="java.lang.Object, java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="Message" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getSource" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getSources" return="java.util.List&lt;java.lang.Object&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@since 2.0]]>
      </doc>
    </method>
    <method name="getMessage" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the error message text.]]>
      </doc>
    </method>
    <method name="acceptVisitor" return="T"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="visitor" type="com.google.inject.spi.ElementVisitor&lt;T&gt;"/>
      <doc>
      <![CDATA[@since 2.0]]>
      </doc>
    </method>
    <method name="getCause" return="java.lang.Throwable"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the throwable that caused this message, or {@code null} if this
 message was not caused by a throwable.

 @since 2.0]]>
      </doc>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="o" type="java.lang.Object"/>
    </method>
    <method name="applyTo"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="binder" type="com.google.inject.Binder"/>
      <doc>
      <![CDATA[@since 2.0]]>
      </doc>
    </method>
    <doc>
    <![CDATA[An error message and the context in which it occured. Messages are usually created internally by
 Guice and its extensions. Messages can be created explicitly in a module using {@link
 com.google.inject.Binder#addError(Throwable) addError()} statements:
 <pre>
     try {
       bindPropertiesFromFile();
     } catch (IOException e) {
       addError(e);
     }</pre>

 @author crazybob@google.com (Bob Lee)]]>
    </doc>
  </class>
  <!-- end class com.google.inject.spi.Message -->
  <!-- start class com.google.inject.spi.ModuleAnnotatedMethodScanner -->
  <class name="ModuleAnnotatedMethodScanner" extends="java.lang.Object"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="ModuleAnnotatedMethodScanner"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="annotationClasses" return="java.util.Set&lt;? extends java.lang.Class&lt;? extends java.lang.annotation.Annotation&gt;&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the annotations this should scan for. Every method in the module that has one of these
 annotations will create a Provider binding, with the return value of the binding being what's
 provided and the parameters of the method being dependencies of the provider.]]>
      </doc>
    </method>
    <method name="prepareMethod" return="com.google.inject.Key&lt;T&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="binder" type="com.google.inject.Binder"/>
      <param name="annotation" type="java.lang.annotation.Annotation"/>
      <param name="key" type="com.google.inject.Key&lt;T&gt;"/>
      <param name="injectionPoint" type="com.google.inject.spi.InjectionPoint"/>
      <doc>
      <![CDATA[Prepares a method for binding. This {@code key} parameter is the key discovered from looking at
 the binding annotation and return value of the method. Implementations can modify the key to
 instead bind to another key. For example, Multibinder may want to change
 {@code @SetProvides String provideFoo()} to bind into a unique Key within the multibinder
 instead of binding {@code String}.

 <p>The injection point and annotation are provided in case the implementation wants to set the
 key based on the property of the annotation or if any additional preparation is needed for any
 of the dependencies. The annotation is guaranteed to be an instance of one the classes returned
 by {@link #annotationClasses}.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Allows extensions to scan modules for annotated methods and bind those methods
 as providers, similar to {@code @Provides} methods.

 @since 4.0]]>
    </doc>
  </class>
  <!-- end class com.google.inject.spi.ModuleAnnotatedMethodScanner -->
  <!-- start class com.google.inject.spi.ModuleAnnotatedMethodScannerBinding -->
  <class name="ModuleAnnotatedMethodScannerBinding" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.inject.spi.Element"/>
    <constructor name="ModuleAnnotatedMethodScannerBinding" type="java.lang.Object, com.google.inject.spi.ModuleAnnotatedMethodScanner"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getSource" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getScanner" return="com.google.inject.spi.ModuleAnnotatedMethodScanner"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="acceptVisitor" return="T"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="visitor" type="com.google.inject.spi.ElementVisitor&lt;T&gt;"/>
    </method>
    <method name="applyTo"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="binder" type="com.google.inject.Binder"/>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Represents a call to {@link Binder#scanModulesForAnnotatedMethods} in a module.
 
 @author sameb@google.com (Sam Berlin)
 @since 4.0]]>
    </doc>
  </class>
  <!-- end class com.google.inject.spi.ModuleAnnotatedMethodScannerBinding -->
  <!-- start interface com.google.inject.spi.PrivateElements -->
  <interface name="PrivateElements"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.inject.spi.Element"/>
    <method name="getElements" return="java.util.List&lt;com.google.inject.spi.Element&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the configuration information in this private environment.]]>
      </doc>
    </method>
    <method name="getInjector" return="com.google.inject.Injector"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the child injector that hosts these private elements, or null if the elements haven't
 been used to create an injector.]]>
      </doc>
    </method>
    <method name="getExposedKeys" return="java.util.Set&lt;com.google.inject.Key&lt;?&gt;&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the unique exposed keys for these private elements.]]>
      </doc>
    </method>
    <method name="getExposedSource" return="java.lang.Object"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="com.google.inject.Key&lt;?&gt;"/>
      <doc>
      <![CDATA[Returns an arbitrary object containing information about the "place" where this key was
 exposed. Used by Guice in the production of descriptive error messages.

 <p>Tools might specially handle types they know about; {@code StackTraceElement} is a good
 example. Tools should simply call {@code toString()} on the source object if the type is
 unfamiliar.

 @param key one of the keys exposed by this module.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A private collection of elements that are hidden from the enclosing injector or module by
 default. See {@link com.google.inject.PrivateModule PrivateModule} for details.

 @author jessewilson@google.com (Jesse Wilson)
 @since 2.0]]>
    </doc>
  </interface>
  <!-- end interface com.google.inject.spi.PrivateElements -->
  <!-- start interface com.google.inject.spi.ProviderBinding -->
  <interface name="ProviderBinding"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.inject.Binding&lt;T&gt;"/>
    <method name="getProvidedKey" return="com.google.inject.Key&lt;?&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the key whose binding is used to {@link Provider#get provide instances}. That binding
 can be retrieved from an injector using {@link com.google.inject.Injector#getBinding(Key)
 Injector.getBinding(providedKey)}]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A binding to a {@link Provider} that delegates to the binding for the provided type. This binding
 is used whenever a {@code Provider<T>} is injected (as opposed to injecting {@code T} directly).

 @author jessewilson@google.com (Jesse Wilson)
 @since 2.0]]>
    </doc>
  </interface>
  <!-- end interface com.google.inject.spi.ProviderBinding -->
  <!-- start interface com.google.inject.spi.ProviderInstanceBinding -->
  <interface name="ProviderInstanceBinding"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.inject.Binding&lt;T&gt;"/>
    <implements name="com.google.inject.spi.HasDependencies"/>
    <method name="getProviderInstance" return="com.google.inject.Provider&lt;? extends T&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="Use {@link #getUserSuppliedProvider} instead.">
      <doc>
      <![CDATA[If the user supplied a JSR330 binding, then this will wrap that one. To always return the
 user-supplied provider, use {@link #getUserSuppliedProvider}.
 
 @deprecated Use {@link #getUserSuppliedProvider} instead.]]>
      </doc>
    </method>
    <method name="getUserSuppliedProvider" return="javax.inject.Provider&lt;? extends T&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the user-supplied, unscoped provider.
 @since 4.0]]>
      </doc>
    </method>
    <method name="getInjectionPoints" return="java.util.Set&lt;com.google.inject.spi.InjectionPoint&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the field and method injection points of the provider, injected at injector-creation
 time only.

 @return a possibly empty set]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A binding to a provider instance. The provider's {@code get} method is invoked to resolve
 injections.

 @author jessewilson@google.com (Jesse Wilson)
 @since 2.0]]>
    </doc>
  </interface>
  <!-- end interface com.google.inject.spi.ProviderInstanceBinding -->
  <!-- start interface com.google.inject.spi.ProviderKeyBinding -->
  <interface name="ProviderKeyBinding"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.inject.Binding&lt;T&gt;"/>
    <method name="getProviderKey" return="com.google.inject.Key&lt;? extends javax.inject.Provider&lt;? extends T&gt;&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the key used to resolve the provider's binding. That binding can be retrieved from an
 injector using {@link com.google.inject.Injector#getBinding(Key)
 Injector.getBinding(providerKey)}]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A binding to a provider key. To resolve injections, the provider key is first resolved, then that
 provider's {@code get} method is invoked.

 @author jessewilson@google.com (Jesse Wilson)
 @since 2.0]]>
    </doc>
  </interface>
  <!-- end interface com.google.inject.spi.ProviderKeyBinding -->
  <!-- start class com.google.inject.spi.ProviderLookup -->
  <class name="ProviderLookup" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.inject.spi.Element"/>
    <constructor name="ProviderLookup" type="java.lang.Object, com.google.inject.Key&lt;T&gt;"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="ProviderLookup" type="java.lang.Object, com.google.inject.spi.Dependency&lt;T&gt;"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@since 4.0]]>
      </doc>
    </constructor>
    <method name="getSource" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getKey" return="com.google.inject.Key&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getDependency" return="com.google.inject.spi.Dependency&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@since 4.0]]>
      </doc>
    </method>
    <method name="acceptVisitor" return="T"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="visitor" type="com.google.inject.spi.ElementVisitor&lt;T&gt;"/>
    </method>
    <method name="initializeDelegate"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="delegate" type="com.google.inject.Provider&lt;T&gt;"/>
      <doc>
      <![CDATA[Sets the actual provider.

 @throws IllegalStateException if the delegate is already set]]>
      </doc>
    </method>
    <method name="applyTo"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="binder" type="com.google.inject.Binder"/>
    </method>
    <method name="getDelegate" return="com.google.inject.Provider&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the delegate provider, or {@code null} if it has not yet been initialized. The delegate
 will be initialized when this element is processed, or otherwise used to create an injector.]]>
      </doc>
    </method>
    <method name="getProvider" return="com.google.inject.Provider&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the looked up provider. The result is not valid until this lookup has been initialized,
 which usually happens when the injector is created. The provider will throw an {@code
 IllegalStateException} if you try to use it beforehand.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A lookup of the provider for a type. Lookups are created explicitly in a module using
 {@link com.google.inject.Binder#getProvider(Class) getProvider()} statements:
 <pre>
     Provider&lt;PaymentService&gt; paymentServiceProvider
         = getProvider(PaymentService.class);</pre>

 @author jessewilson@google.com (Jesse Wilson)
 @since 2.0]]>
    </doc>
  </class>
  <!-- end class com.google.inject.spi.ProviderLookup -->
  <!-- start interface com.google.inject.spi.ProviderWithDependencies -->
  <interface name="ProviderWithDependencies"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.inject.Provider&lt;T&gt;"/>
    <implements name="com.google.inject.spi.HasDependencies"/>
    <doc>
    <![CDATA[A provider with dependencies on other injected types. If a {@link Provider} has dependencies that
 aren't specified in injections, this interface should be used to expose all dependencies.

 @since 2.0]]>
    </doc>
  </interface>
  <!-- end interface com.google.inject.spi.ProviderWithDependencies -->
  <!-- start interface com.google.inject.spi.ProviderWithExtensionVisitor -->
  <interface name="ProviderWithExtensionVisitor"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.inject.Provider&lt;T&gt;"/>
    <method name="acceptExtensionVisitor" return="V"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="visitor" type="com.google.inject.spi.BindingTargetVisitor&lt;B, V&gt;"/>
      <param name="binding" type="com.google.inject.spi.ProviderInstanceBinding&lt;? extends B&gt;"/>
      <doc>
      <![CDATA[Instructs the extension determine if the visitor is an instance of a custom
 extension visitor, and if so, visit it using that method. If the visitor is
 not an instance of the custom extension visitor, this method <b>MUST</b>
 call visitor.visit(binding).
 <p> 
 Due to issues with generics, the type parameters of this method do not
 relate to the type of the provider. In practice, the 'B' type will always
 be a supertype of 'T'.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A Provider that is part of an extension which supports a custom
 BindingTargetVisitor.
 <p> 
 When an extension binds a provider instance, the provider can implement this
 interface to allow users using the
 {@link Binding#acceptTargetVisitor(BindingTargetVisitor)} method to visit a
 custom visitor designed for that extension. A typical implementation within
 the extension would look like
 <pre> 
 &lt;V, B> V acceptExtensionVisitor(BindingTargetVisitor&lt;B, V> visitor, ProviderInstanceBinding&lt;? extends B> binding) {
   if(visitor instanceof MyCustomExtensionVisitor) {
     return ((MyCustomExtensionVisitor&lt;B, V>)visitor).visitCustomExtension(customProperties, binding);
   } else {
     return visitor.visit(binding);
   }
 }</pre> 
 'MyCustomExtensionVisitor' in the example above would be an interface the
 extension provides that users can implement in order to be notified of custom
 extension information. These visitor interfaces must extend from
 BindingTargetVisitor.

 @since 3.0
 @author sameb@google.com (Sam Berlin)]]>
    </doc>
  </interface>
  <!-- end interface com.google.inject.spi.ProviderWithExtensionVisitor -->
  <!-- start interface com.google.inject.spi.ProvidesMethodBinding -->
  <interface name="ProvidesMethodBinding"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.inject.spi.HasDependencies"/>
    <method name="getMethod" return="java.lang.reflect.Method"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the method this binding uses.]]>
      </doc>
    </method>
    <method name="getEnclosingInstance" return="java.lang.Object"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the instance of the object the method is defined in.]]>
      </doc>
    </method>
    <method name="getKey" return="com.google.inject.Key&lt;T&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the key of the binding.]]>
      </doc>
    </method>
    <method name="getAnnotation" return="java.lang.annotation.Annotation"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the annotation that caused this binding to be created. For {@code @Provides} methods,
 this is an instance of the {@code @Provides} annotation. For bindings from
 {@link ModuleAnnotatedMethodScanner}, this is the annotation that caused the scanner to produce
 the binding.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[An {@literal @}{@link Provides} binding or binding produced by a
 {@link ModuleAnnotatedMethodScanner}.

 @since 4.0
 @author sameb@google.com (Sam Berlin)]]>
    </doc>
  </interface>
  <!-- end interface com.google.inject.spi.ProvidesMethodBinding -->
  <!-- start interface com.google.inject.spi.ProvidesMethodTargetVisitor -->
  <interface name="ProvidesMethodTargetVisitor"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.inject.spi.BindingTargetVisitor&lt;T, V&gt;"/>
    <method name="visit" return="V"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="providesMethodBinding" type="com.google.inject.spi.ProvidesMethodBinding&lt;? extends T&gt;"/>
      <doc>
      <![CDATA[Visits an {@link ProvidesMethodBinding} created with an {@literal @}{@link Provides} method.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A visitor for the {@literal @}{@link Provides} bindings.
 <p>
 If your {@link BindingTargetVisitor} implements this interface, bindings created by using
 {@code @Provides} will be visited through this interface.

 @since 4.0
 @author sameb@google.com (Sam Berlin)]]>
    </doc>
  </interface>
  <!-- end interface com.google.inject.spi.ProvidesMethodTargetVisitor -->
  <!-- start interface com.google.inject.spi.ProvisionListener -->
  <interface name="ProvisionListener"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="onProvision"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="provision" type="com.google.inject.spi.ProvisionListener.ProvisionInvocation&lt;T&gt;"/>
      <doc>
      <![CDATA[Invoked by Guice when an object requires provisioning. Provisioning occurs
 when Guice locates and injects the dependencies for a binding. For types
 bound to a Provider, provisioning encapsulates the {@link Provider#get}
 method. For toInstance or constant bindings, provisioning encapsulates
 the injecting of {@literal @}{@code Inject}ed fields or methods.
 For other types, provisioning encapsulates the construction of the
 object. If a type is bound within a {@link Scope}, provisioning depends on
 the scope. Types bound in Singleton scope will only be provisioned once.
 Types bound in no scope will be provisioned every time they are injected.
 Other scopes define their own behavior for provisioning.
 <p>
 To perform the provision, call {@link ProvisionInvocation#provision()}.
 If you do not explicitly call provision, it will be automatically done after
 this method returns.  It is an error to call provision more than once.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Listens for provisioning of objects. Useful for gathering timing information
 about provisioning, post-provision initialization, and more.
 
 @author sameb@google.com (Sam Berlin)
 @since 4.0]]>
    </doc>
  </interface>
  <!-- end interface com.google.inject.spi.ProvisionListener -->
  <!-- start class com.google.inject.spi.ProvisionListener.ProvisionInvocation -->
  <class name="ProvisionListener.ProvisionInvocation" extends="java.lang.Object"
    abstract="true"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="ProvisionInvocation"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getBinding" return="com.google.inject.Binding&lt;T&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the Binding this is provisioning.
 <p>
 You must not call {@link Provider#get()} on the provider returned by
 {@link Binding#getProvider}, otherwise you will get confusing error messages.]]>
      </doc>
    </method>
    <method name="provision" return="T"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Performs the provision, returning the object provisioned.]]>
      </doc>
    </method>
    <method name="getDependencyChain" return="java.util.List&lt;com.google.inject.spi.DependencyAndSource&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the dependency chain that led to this object being provisioned.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Encapsulates a single act of provisioning.

 @since 4.0]]>
    </doc>
  </class>
  <!-- end class com.google.inject.spi.ProvisionListener.ProvisionInvocation -->
  <!-- start class com.google.inject.spi.ProvisionListenerBinding -->
  <class name="ProvisionListenerBinding" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.inject.spi.Element"/>
    <method name="getListeners" return="java.util.List&lt;com.google.inject.spi.ProvisionListener&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the registered listeners.]]>
      </doc>
    </method>
    <method name="getBindingMatcher" return="com.google.inject.matcher.Matcher&lt;? super com.google.inject.Binding&lt;?&gt;&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the binding matcher which chooses which bindings the listener should be notified of.]]>
      </doc>
    </method>
    <method name="getSource" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="acceptVisitor" return="R"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="visitor" type="com.google.inject.spi.ElementVisitor&lt;R&gt;"/>
    </method>
    <method name="applyTo"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="binder" type="com.google.inject.Binder"/>
    </method>
    <doc>
    <![CDATA[Binds keys (picked using a Matcher) to a provision listener. Listeners are created explicitly in
 a module using {@link Binder#bindListener(Matcher, ProvisionListener...)} statements:

 @author sameb@google.com (Sam Berlin)
 @since 4.0]]>
    </doc>
  </class>
  <!-- end class com.google.inject.spi.ProvisionListenerBinding -->
  <!-- start class com.google.inject.spi.RequireAtInjectOnConstructorsOption -->
  <class name="RequireAtInjectOnConstructorsOption" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.inject.spi.Element"/>
    <method name="getSource" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="applyTo"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="binder" type="com.google.inject.Binder"/>
    </method>
    <method name="acceptVisitor" return="T"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="visitor" type="com.google.inject.spi.ElementVisitor&lt;T&gt;"/>
    </method>
    <doc>
    <![CDATA[A request to require explicit {@literal @}{@link Inject} annotations on constructors.

 @author sameb@google.com (Sam Berlin)
 @since 4.0]]>
    </doc>
  </class>
  <!-- end class com.google.inject.spi.RequireAtInjectOnConstructorsOption -->
  <!-- start class com.google.inject.spi.RequireExactBindingAnnotationsOption -->
  <class name="RequireExactBindingAnnotationsOption" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.inject.spi.Element"/>
    <method name="getSource" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="applyTo"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="binder" type="com.google.inject.Binder"/>
    </method>
    <method name="acceptVisitor" return="T"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="visitor" type="com.google.inject.spi.ElementVisitor&lt;T&gt;"/>
    </method>
    <doc>
    <![CDATA[A request to require exact binding annotations.

 @author sameb@google.com (Sam Berlin)
 @since 4.0]]>
    </doc>
  </class>
  <!-- end class com.google.inject.spi.RequireExactBindingAnnotationsOption -->
  <!-- start class com.google.inject.spi.RequireExplicitBindingsOption -->
  <class name="RequireExplicitBindingsOption" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.inject.spi.Element"/>
    <method name="getSource" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="applyTo"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="binder" type="com.google.inject.Binder"/>
    </method>
    <method name="acceptVisitor" return="T"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="visitor" type="com.google.inject.spi.ElementVisitor&lt;T&gt;"/>
    </method>
    <doc>
    <![CDATA[A request to require explicit bindings.

 @author sameb@google.com (Sam Berlin)
 @since 3.0]]>
    </doc>
  </class>
  <!-- end class com.google.inject.spi.RequireExplicitBindingsOption -->
  <!-- start class com.google.inject.spi.ScopeBinding -->
  <class name="ScopeBinding" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.inject.spi.Element"/>
    <method name="getSource" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getAnnotationType" return="java.lang.Class&lt;? extends java.lang.annotation.Annotation&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getScope" return="com.google.inject.Scope"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="acceptVisitor" return="T"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="visitor" type="com.google.inject.spi.ElementVisitor&lt;T&gt;"/>
    </method>
    <method name="applyTo"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="binder" type="com.google.inject.Binder"/>
    </method>
    <doc>
    <![CDATA[Registration of a scope annotation with the scope that implements it. Instances are created
 explicitly in a module using {@link com.google.inject.Binder#bindScope(Class, Scope) bindScope()}
 statements:
 <pre>
     Scope recordScope = new RecordScope();
     bindScope(RecordScoped.class, new RecordScope());</pre>

 @author jessewilson@google.com (Jesse Wilson)
 @since 2.0]]>
    </doc>
  </class>
  <!-- end class com.google.inject.spi.ScopeBinding -->
  <!-- start class com.google.inject.spi.StaticInjectionRequest -->
  <class name="StaticInjectionRequest" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.inject.spi.Element"/>
    <method name="getSource" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getType" return="java.lang.Class&lt;?&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getInjectionPoints" return="java.util.Set&lt;com.google.inject.spi.InjectionPoint&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="ConfigurationException" type="com.google.inject.ConfigurationException"/>
      <doc>
      <![CDATA[Returns the static methods and fields of {@code type} that will be injected to fulfill this
 request.

 @return a possibly empty set of injection points. The set has a specified iteration order. All
      fields are returned and then all methods. Within the fields, supertype fields are returned
      before subtype fields. Similarly, supertype methods are returned before subtype methods.
 @throws ConfigurationException if there is a malformed injection point on {@code type}, such as
      a field with multiple binding annotations. The exception's {@link
      ConfigurationException#getPartialValue() partial value} is a {@code Set<InjectionPoint>}
      of the valid injection points.]]>
      </doc>
    </method>
    <method name="applyTo"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="binder" type="com.google.inject.Binder"/>
    </method>
    <method name="acceptVisitor" return="T"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="visitor" type="com.google.inject.spi.ElementVisitor&lt;T&gt;"/>
    </method>
    <doc>
    <![CDATA[A request to inject the static fields and methods of a type. Requests are created
 explicitly in a module using {@link com.google.inject.Binder#requestStaticInjection(Class[])
 requestStaticInjection()} statements:
 <pre>
     requestStaticInjection(MyLegacyService.class);</pre>

 @author jessewilson@google.com (Jesse Wilson)
 @since 2.0]]>
    </doc>
  </class>
  <!-- end class com.google.inject.spi.StaticInjectionRequest -->
  <!-- start class com.google.inject.spi.Toolable -->
  <class name="Toolable"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.lang.annotation.Annotation"/>
    <doc>
    <![CDATA[Instructs an {@link Injector} running in {@link Stage#TOOL} that a method should be injected.
 This is typically useful for for extensions to Guice that perform additional validation in an
 injected method or field.  This only applies to objects that are already constructed when
 bindings are created (ie., something bound using {@link
 com.google.inject.binder.LinkedBindingBuilder#toProvider toProvider}, {@link
 com.google.inject.binder.LinkedBindingBuilder#toInstance toInstance}, or {@link
 com.google.inject.Binder#requestInjection requestInjection}.
 
 @author sberlin@gmail.com (Sam Berlin)
 @since 3.0]]>
    </doc>
  </class>
  <!-- end class com.google.inject.spi.Toolable -->
  <!-- start interface com.google.inject.spi.TypeConverter -->
  <interface name="TypeConverter"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="convert" return="java.lang.Object"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="java.lang.String"/>
      <param name="toType" type="com.google.inject.TypeLiteral&lt;?&gt;"/>
      <doc>
      <![CDATA[Converts a string value. Throws an exception if a conversion error occurs.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Converts constant string values to a different type.

 @author crazybob@google.com (Bob Lee)
 @since 2.0]]>
    </doc>
  </interface>
  <!-- end interface com.google.inject.spi.TypeConverter -->
  <!-- start class com.google.inject.spi.TypeConverterBinding -->
  <class name="TypeConverterBinding" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.inject.spi.Element"/>
    <constructor name="TypeConverterBinding" type="java.lang.Object, com.google.inject.matcher.Matcher&lt;? super com.google.inject.TypeLiteral&lt;?&gt;&gt;, com.google.inject.spi.TypeConverter"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@since 3.0]]>
      </doc>
    </constructor>
    <method name="getSource" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getTypeMatcher" return="com.google.inject.matcher.Matcher&lt;? super com.google.inject.TypeLiteral&lt;?&gt;&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getTypeConverter" return="com.google.inject.spi.TypeConverter"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="acceptVisitor" return="T"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="visitor" type="com.google.inject.spi.ElementVisitor&lt;T&gt;"/>
    </method>
    <method name="applyTo"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="binder" type="com.google.inject.Binder"/>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Registration of type converters for matching target types. Instances are created
 explicitly in a module using {@link com.google.inject.Binder#convertToTypes(Matcher,
 TypeConverter) convertToTypes()} statements:
 <pre>
     convertToTypes(Matchers.only(TypeLiteral.get(DateTime.class)), new DateTimeConverter());</pre>

 @author jessewilson@google.com (Jesse Wilson)
 @since 2.0]]>
    </doc>
  </class>
  <!-- end class com.google.inject.spi.TypeConverterBinding -->
  <!-- start interface com.google.inject.spi.TypeEncounter -->
  <interface name="TypeEncounter"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="addError"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="message" type="java.lang.String"/>
      <param name="arguments" type="java.lang.Object[]"/>
      <doc>
      <![CDATA[Records an error message for type {@code I} which will be presented to the user at a later
 time. Unlike throwing an exception, this enable us to continue configuring the Injector and
 discover more errors. Uses {@link String#format(String, Object[])} to insert the arguments
 into the message.]]>
      </doc>
    </method>
    <method name="addError"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="t" type="java.lang.Throwable"/>
      <doc>
      <![CDATA[Records an exception for type {@code I}, the full details of which will be logged, and the
 message of which will be presented to the user at a later time. If your type listener calls
 something that you worry may fail, you should catch the exception and pass it to this method.]]>
      </doc>
    </method>
    <method name="addError"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="message" type="com.google.inject.spi.Message"/>
      <doc>
      <![CDATA[Records an error message to be presented to the user at a later time.]]>
      </doc>
    </method>
    <method name="getProvider" return="com.google.inject.Provider&lt;T&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="com.google.inject.Key&lt;T&gt;"/>
      <doc>
      <![CDATA[Returns the provider used to obtain instances for the given injection key. The returned
 provider will not be valid until the injector has been created. The provider will throw an
 {@code IllegalStateException} if you try to use it beforehand.]]>
      </doc>
    </method>
    <method name="getProvider" return="com.google.inject.Provider&lt;T&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="java.lang.Class&lt;T&gt;"/>
      <doc>
      <![CDATA[Returns the provider used to obtain instances for the given injection type. The returned
 provider will not be valid until the injector has been created. The provider will throw an
 {@code IllegalStateException} if you try to use it beforehand.]]>
      </doc>
    </method>
    <method name="getMembersInjector" return="com.google.inject.MembersInjector&lt;T&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="typeLiteral" type="com.google.inject.TypeLiteral&lt;T&gt;"/>
      <doc>
      <![CDATA[Returns the members injector used to inject dependencies into methods and fields on instances
 of the given type {@code T}. The returned members injector will not be valid until the main
 injector has been created. The members injector will throw an {@code IllegalStateException}
 if you try to use it beforehand.

 @param typeLiteral type to get members injector for]]>
      </doc>
    </method>
    <method name="getMembersInjector" return="com.google.inject.MembersInjector&lt;T&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="java.lang.Class&lt;T&gt;"/>
      <doc>
      <![CDATA[Returns the members injector used to inject dependencies into methods and fields on instances
 of the given type {@code T}. The returned members injector will not be valid until the main
 injector has been created. The members injector will throw an {@code IllegalStateException}
 if you try to use it beforehand.

 @param type type to get members injector for]]>
      </doc>
    </method>
    <method name="register"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="membersInjector" type="com.google.inject.MembersInjector&lt;? super I&gt;"/>
      <doc>
      <![CDATA[Registers a members injector for type {@code I}. Guice will use the members injector after its
 performed its own injections on an instance of {@code I}.]]>
      </doc>
    </method>
    <method name="register"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="listener" type="com.google.inject.spi.InjectionListener&lt;? super I&gt;"/>
      <doc>
      <![CDATA[Registers an injection listener for type {@code I}. Guice will notify the listener after all
 injections have been performed on an instance of {@code I}.]]>
      </doc>
    </method>
    <method name="bindInterceptor"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="methodMatcher" type="com.google.inject.matcher.Matcher&lt;? super java.lang.reflect.Method&gt;"/>
      <param name="interceptors" type="org.aopalliance.intercept.MethodInterceptor[]"/>
      <doc>
      <![CDATA[Binds method interceptor[s] to methods matched in type {@code I} and its supertypes. A
 method is eligible for interception if:

 <ul>
  <li>Guice created the instance the method is on</li>
  <li>Neither the enclosing type nor the method is final</li>
  <li>And the method is package-private or more accessible</li>
 </ul>

 @param methodMatcher matches methods the interceptor should apply to. For
     example: {@code annotatedWith(Transactional.class)}.
 @param interceptors to bind]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Context of an injectable type encounter. Enables reporting errors, registering injection
 listeners and binding method interceptors for injectable type {@code I}. It is an error to use
 an encounter after the {@link TypeListener#hear(TypeLiteral, TypeEncounter) hear()} method has
 returned.

 @param <I> the injectable type encountered
 @since 2.0]]>
    </doc>
  </interface>
  <!-- end interface com.google.inject.spi.TypeEncounter -->
  <!-- start interface com.google.inject.spi.TypeListener -->
  <interface name="TypeListener"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="hear"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="com.google.inject.TypeLiteral&lt;I&gt;"/>
      <param name="encounter" type="com.google.inject.spi.TypeEncounter&lt;I&gt;"/>
      <doc>
      <![CDATA[Invoked when Guice encounters a new type eligible for constructor or members injection.
 Called during injector creation (or afterwards if Guice encounters a type at run time and
 creates a JIT binding).

 @param type encountered by Guice
 @param encounter context of this encounter, enables reporting errors, registering injection
     listeners and binding method interceptors for {@code type}.

 @param <I> the injectable type]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Listens for Guice to encounter injectable types. If a given type has its constructor injected in
 one situation but only its methods and fields injected in another, Guice will notify this
 listener once.

 <p>Useful for extra type checking, {@linkplain TypeEncounter#register(InjectionListener)
 registering injection listeners}, and {@linkplain TypeEncounter#bindInterceptor(
 com.google.inject.matcher.Matcher, org.aopalliance.intercept.MethodInterceptor[])
 binding method interceptors}.
 
 @since 2.0]]>
    </doc>
  </interface>
  <!-- end interface com.google.inject.spi.TypeListener -->
  <!-- start class com.google.inject.spi.TypeListenerBinding -->
  <class name="TypeListenerBinding" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.inject.spi.Element"/>
    <method name="getListener" return="com.google.inject.spi.TypeListener"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the registered listener.]]>
      </doc>
    </method>
    <method name="getTypeMatcher" return="com.google.inject.matcher.Matcher&lt;? super com.google.inject.TypeLiteral&lt;?&gt;&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the type matcher which chooses which types the listener should be notified of.]]>
      </doc>
    </method>
    <method name="getSource" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="acceptVisitor" return="T"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="visitor" type="com.google.inject.spi.ElementVisitor&lt;T&gt;"/>
    </method>
    <method name="applyTo"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="binder" type="com.google.inject.Binder"/>
    </method>
    <doc>
    <![CDATA[Binds types (picked using a Matcher) to an type listener. Registrations are created explicitly in
 a module using {@link com.google.inject.Binder#bindListener(Matcher, TypeListener)} statements:

 <pre>
     register(only(new TypeLiteral&lt;PaymentService&lt;CreditCard>>() {}), listener);</pre>

 @author jessewilson@google.com (Jesse Wilson)
 @since 2.0]]>
    </doc>
  </class>
  <!-- end class com.google.inject.spi.TypeListenerBinding -->
  <!-- start interface com.google.inject.spi.UntargettedBinding -->
  <interface name="UntargettedBinding"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.inject.Binding&lt;T&gt;"/>
    <doc>
    <![CDATA[An untargetted binding. This binding indicates that the injector should use its implicit binding
 strategies to resolve injections.

 @author jessewilson@google.com (Jesse Wilson)
 @since 2.0]]>
    </doc>
  </interface>
  <!-- end interface com.google.inject.spi.UntargettedBinding -->
</package>
<package name="com.google.inject.spring">
  <!-- start class com.google.inject.spring.SpringIntegration -->
  <class name="SpringIntegration" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="fromSpring" return="com.google.inject.Provider&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="java.lang.Class&lt;T&gt;"/>
      <param name="name" type="java.lang.String"/>
      <doc>
      <![CDATA[Creates a provider which looks up objects from Spring using the given name.
 Expects a binding to {@link
 org.springframework.beans.factory.BeanFactory}. Example usage:

 <pre>
 bind(DataSource.class)
   .toProvider(fromSpring(DataSource.class, "dataSource"));
 </pre>]]>
      </doc>
    </method>
    <method name="bindAll"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="binder" type="com.google.inject.Binder"/>
      <param name="beanFactory" type="org.springframework.beans.factory.ListableBeanFactory"/>
      <doc>
      <![CDATA[Binds all Spring beans from the given factory by name. For a Spring bean
 named "foo", this method creates a binding to the bean's type and
 {@code @Named("foo")}.

 @see com.google.inject.name.Named
 @see com.google.inject.name.Names#named(String)]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Integrates Guice with Spring.

 @author crazybob@google.com (Bob Lee)]]>
    </doc>
  </class>
  <!-- end class com.google.inject.spring.SpringIntegration -->
</package>
<package name="com.google.inject.struts2">
  <!-- start class com.google.inject.struts2.GuiceObjectFactory -->
  <class name="GuiceObjectFactory" extends="com.opensymphony.xwork2.ObjectFactory"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="Use {@link com.google.inject.struts2.Struts2Factory} instead.">
    <constructor name="GuiceObjectFactory"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="isNoArgConstructorRequired" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getClassInstance" return="java.lang.Class"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <exception name="ClassNotFoundException" type="java.lang.ClassNotFoundException"/>
    </method>
    <method name="buildBean" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="clazz" type="java.lang.Class"/>
      <param name="extraContext" type="java.util.Map"/>
    </method>
    <method name="buildInterceptor" return="com.opensymphony.xwork2.interceptor.Interceptor"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="interceptorConfig" type="com.opensymphony.xwork2.config.entities.InterceptorConfig"/>
      <param name="interceptorRefParams" type="java.util.Map"/>
      <exception name="ConfigurationException" type="com.opensymphony.xwork2.config.ConfigurationException"/>
    </method>
    <doc>
    <![CDATA[@deprecated Use {@link com.google.inject.struts2.Struts2Factory} instead.]]>
    </doc>
  </class>
  <!-- end class com.google.inject.struts2.GuiceObjectFactory -->
  <!-- start class com.google.inject.struts2.Struts2Factory -->
  <class name="Struts2Factory" extends="com.opensymphony.xwork2.ObjectFactory"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="Struts2Factory"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="isNoArgConstructorRequired" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getClassInstance" return="java.lang.Class&lt;?&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <exception name="ClassNotFoundException" type="java.lang.ClassNotFoundException"/>
    </method>
    <method name="buildBean" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="clazz" type="java.lang.Class"/>
      <param name="extraContext" type="java.util.Map&lt;java.lang.String, java.lang.Object&gt;"/>
    </method>
    <method name="buildInterceptor" return="com.opensymphony.xwork2.interceptor.Interceptor"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="interceptorConfig" type="com.opensymphony.xwork2.config.entities.InterceptorConfig"/>
      <param name="interceptorRefParams" type="java.util.Map"/>
      <exception name="ConfigurationException" type="com.opensymphony.xwork2.config.ConfigurationException"/>
    </method>
    <doc>
    <![CDATA[Cleanup up version from Bob's GuiceObjectFactory. Now works properly with
 GS2 and fixes several bugs.

 @author dhanji@gmail.com
 @author benmccann.com]]>
    </doc>
  </class>
  <!-- end class com.google.inject.struts2.Struts2Factory -->
  <!-- start class com.google.inject.struts2.Struts2GuicePluginModule -->
  <class name="Struts2GuicePluginModule" extends="com.google.inject.AbstractModule"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="Struts2GuicePluginModule"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="configure"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Initializes the Struts 2 Guice Plugin. Must be added to the injector returned
 by {@link com.google.inject.servlet.GuiceServletContextListener#getInjector}.

 @author benmccann.com]]>
    </doc>
  </class>
  <!-- end class com.google.inject.struts2.Struts2GuicePluginModule -->
</package>
<package name="com.google.inject.testing.fieldbinder">
  <!-- start class com.google.inject.testing.fieldbinder.Bind -->
  <class name="Bind"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.lang.annotation.Annotation"/>
    <doc>
    <![CDATA[Annotation used by {@link BoundFieldModule} to indicate that a field should be bound to its
 value using Guice.

 <p>Binding to {@code null} is only allowed for fields that are annotated {@code @Nullable}. See
 <a href="https://github.com/google/guice/wiki/UseNullable">https://github.com/google/guice/wiki/UseNullable</a>

 @see BoundFieldModule
 @author eatnumber1@google.com (Russ Harmon)]]>
    </doc>
  </class>
  <!-- end class com.google.inject.testing.fieldbinder.Bind -->
  <!-- start class com.google.inject.testing.fieldbinder.BoundFieldModule -->
  <class name="BoundFieldModule" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.inject.Module"/>
    <method name="of" return="com.google.inject.testing.fieldbinder.BoundFieldModule"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="instance" type="java.lang.Object"/>
      <doc>
      <![CDATA[Create a BoundFieldModule which binds the {@link Bind} annotated fields of {@code instance}.

 @param instance the instance whose fields will be bound.
 @return a module which will bind the {@link Bind} annotated fields of {@code instance}.]]>
      </doc>
    </method>
    <method name="configure"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="binder" type="com.google.inject.Binder"/>
    </method>
    <doc>
    <![CDATA[Automatically creates Guice bindings for fields in an object annotated with {@link Bind}.

 <p>This module is intended for use in tests to reduce the code needed to bind local fields
 (usually mocks) for injection.

 <p>The following rules are followed in determining how fields are bound using this module:

 <ul>
 <li>
 For each {@link Bind} annotated field of an object and its superclasses, this module will bind
 that field's type to that field's value at injector creation time. This includes both instance
 and static fields.
 </li>
 <li>
 If {@link Bind#to} is specified, the field's value will be bound to the class specified by
 {@link Bind#to} instead of the field's actual type.
 </li>
 <li>
 If a {@link BindingAnnotation} or {@link javax.inject.Qualifier} is present on the field,
 that field will be bound using that annotation via {@link AnnotatedBindingBuilder#annotatedWith}.
 For example, {@code bind(Foo.class).annotatedWith(BarAnnotation.class).toInstance(theValue)}.
 It is an error to supply more than one {@link BindingAnnotation} or
 {@link javax.inject.Qualifier}.
 </li>
 <li>
 If the field is of type {@link Provider}, the field's value will be bound as a {@link Provider}
 using {@link LinkedBindingBuilder#toProvider} to the provider's parameterized type. For example,
 {@code Provider<Integer>} binds to {@link Integer}. Attempting to bind a non-parameterized
 {@link Provider} without a {@link Bind#to} clause is an error.
 </li>
 </ul>

 <p>Example use:
 <pre><code>
 public class TestFoo {
   // bind(new TypeLiteral{@code <List<Object>>}() {}).toInstance(listOfObjects);
   {@literal @}Bind private List{@code <Object>} listOfObjects = Lists.of();

   // bind(String.class).toProvider(new Provider() { public String get() { return userName; }});
   {@literal @}Bind(lazy = true) private String userName;

   // bind(SuperClass.class).toInstance(aSubClass);
   {@literal @}Bind(to = SuperClass.class) private SubClass aSubClass = new SubClass();

   // bind(String.class).annotatedWith(MyBindingAnnotation.class).toInstance(myString);
   {@literal @}Bind
   {@literal @}MyBindingAnnotation
   private String myString = "hello";

   // bind(Object.class).toProvider(myProvider);
   {@literal @}Bind private Provider{@code <Object>} myProvider = getProvider();

   {@literal @}Before public void setUp() {
     Guice.createInjector(BoundFieldModule.of(this)).injectMembers(this);
   }
 }
 </code></pre>

 @see Bind
 @author eatnumber1@google.com (Russ Harmon)]]>
    </doc>
  </class>
  <!-- end class com.google.inject.testing.fieldbinder.BoundFieldModule -->
</package>
<package name="com.google.inject.throwingproviders">
  <!-- start interface com.google.inject.throwingproviders.CheckedProvider -->
  <interface name="CheckedProvider"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="get" return="T"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="Exception" type="java.lang.Exception"/>
    </method>
    <doc>
    <![CDATA[Alternative to the Guice {@link com.google.inject.Provider} that throws
 a checked Exception. Users may not inject {@code T} directly.

 <p>This interface must be extended to use application-specific exception types.
 Such subinterfaces may not define new methods, but may narrow the exception type.
 <pre>
 public interface RemoteProvider&lt;T&gt; extends CheckedProvider&lt;T&gt; { 
   T get() throws CustomExceptionOne, CustomExceptionTwo;
 }
 </pre>

 <p>When this type is bound using {@link ThrowingProviderBinder}, the value returned
 or exception thrown by {@link #get} will be scoped. As a consequence, {@link #get}
 will invoked at most once within each scope.
 
 @since 3.0]]>
    </doc>
  </interface>
  <!-- end interface com.google.inject.throwingproviders.CheckedProvider -->
  <!-- start class com.google.inject.throwingproviders.CheckedProvides -->
  <class name="CheckedProvides"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.lang.annotation.Annotation"/>
    <doc>
    <![CDATA[Annotates methods of a {@link com.google.inject.Module} to create a
 {@link CheckedProvider} method binding that can throw exceptions. The
 method's return type is bound to a {@link CheckedProvider} that can be
 injected. Guice will pass dependencies to the method as parameters. Install
 {@literal @}CheckedProvides methods by using
 {@link ThrowingProviderBinder#forModule(com.google.inject.Module)} on the
 module where the methods are declared.
 
 @author sameb@google.com (Sam Berlin)
 @since 3.0]]>
    </doc>
  </class>
  <!-- end class com.google.inject.throwingproviders.CheckedProvides -->
  <!-- start class com.google.inject.throwingproviders.ThrowingInject -->
  <class name="ThrowingInject"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.lang.annotation.Annotation"/>
    <doc>
    <![CDATA[A version of {@literal @}{@link Inject} designed for ThrowingProviders.  Use by:
 <pre><code>ThrowingProviderBinder.create(binder())
    .bind(RemoteProvider.class, Customer.class)
    .providing(CustomerImpl.class);
 </code></pre>
 where CustomerImpl has a constructor annotated with ThrowingInject.

 @author sameb@google.com (Sam Berlin)
 @since 4.0]]>
    </doc>
  </class>
  <!-- end class com.google.inject.throwingproviders.ThrowingInject -->
  <!-- start interface com.google.inject.throwingproviders.ThrowingProvider -->
  <interface name="ThrowingProvider"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="use {@link CheckedProvider} instead.">
    <implements name="com.google.inject.throwingproviders.CheckedProvider&lt;T&gt;"/>
    <method name="get" return="T"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="Exception" type="java.lang.Exception"/>
    </method>
    <doc>
    <![CDATA[Alternative to the Guice {@link com.google.inject.Provider} that throws
 a checked Exception. Users may not inject {@code T} directly.

 <p>This interface must be extended to use application-specific exception types.
 Such subinterfaces may not define new methods:
 <pre>
 public interface RemoteProvider&lt;T&gt; extends ThrowingProvider&lt;T, RemoteException&gt; { }
 </pre>

 <p>When this type is bound using {@link ThrowingProviderBinder}, the value returned
 or exception thrown by {@link #get} will be scoped. As a consequence, {@link #get}
 will invoked at most once within each scope.

 @author jmourits@google.com (Jerome Mourits)
 @author jessewilson@google.com (Jesse Wilson)
 @deprecated use {@link CheckedProvider} instead.]]>
    </doc>
  </interface>
  <!-- end interface com.google.inject.throwingproviders.ThrowingProvider -->
  <!-- start class com.google.inject.throwingproviders.ThrowingProviderBinder -->
  <class name="ThrowingProviderBinder" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="create" return="com.google.inject.throwingproviders.ThrowingProviderBinder"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="binder" type="com.google.inject.Binder"/>
    </method>
    <method name="forModule" return="com.google.inject.Module"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="module" type="com.google.inject.Module"/>
      <doc>
      <![CDATA[Returns a module that installs {@literal @}{@link CheckedProvides} methods.
 
 @since 3.0]]>
      </doc>
    </method>
    <method name="bind" return="com.google.inject.throwingproviders.ThrowingProviderBinder.SecondaryBinder&lt;P, ?&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="Use {@link #bind(Class, Class)} or {@link #bind(Class, TypeLiteral)} instead.">
      <param name="interfaceType" type="java.lang.Class&lt;P&gt;"/>
      <param name="clazz" type="java.lang.reflect.Type"/>
      <doc>
      <![CDATA[@deprecated Use {@link #bind(Class, Class)} or {@link #bind(Class, TypeLiteral)} instead.]]>
      </doc>
    </method>
    <method name="bind" return="com.google.inject.throwingproviders.ThrowingProviderBinder.SecondaryBinder&lt;P, T&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="interfaceType" type="java.lang.Class&lt;P&gt;"/>
      <param name="clazz" type="java.lang.Class&lt;T&gt;"/>
      <doc>
      <![CDATA[@since 4.0]]>
      </doc>
    </method>
    <method name="bind" return="com.google.inject.throwingproviders.ThrowingProviderBinder.SecondaryBinder&lt;P, T&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="interfaceType" type="java.lang.Class&lt;P&gt;"/>
      <param name="typeLiteral" type="com.google.inject.TypeLiteral&lt;T&gt;"/>
      <doc>
      <![CDATA[@since 4.0]]>
      </doc>
    </method>
    <doc>
    <![CDATA[<p>Builds a binding for a {@link CheckedProvider}.
 
 <p>You can use a fluent API and custom providers:
 <pre><code>ThrowingProviderBinder.create(binder())
    .bind(RemoteProvider.class, Customer.class)
    .to(RemoteCustomerProvider.class)
    .in(RequestScope.class);
 </code></pre>
 or, you can use throwing provider methods:
 <pre><code>class MyModule extends AbstractModule {
   configure() {
     ThrowingProviderBinder.install(this, binder());
   }
   
   {@literal @}CheckedProvides(RemoteProvider.class)
   {@literal @}RequestScope
   Customer provideCustomer(FlakyCustomerCreator creator) throws RemoteException {
     return creator.getCustomerOrThrow();
   }
 }
 </code></pre>
 You also can declare that a CheckedProvider construct
 a particular class whose constructor throws an exception:
 <pre><code>ThrowingProviderBinder.create(binder())
    .bind(RemoteProvider.class, Customer.class)
    .providing(CustomerImpl.class)
    .in(RequestScope.class);
 </code></pre>
 
 @author jmourits@google.com (Jerome Mourits)
 @author jessewilson@google.com (Jesse Wilson)
 @author sameb@google.com (Sam Berlin)]]>
    </doc>
  </class>
  <!-- end class com.google.inject.throwingproviders.ThrowingProviderBinder -->
  <!-- start class com.google.inject.throwingproviders.ThrowingProviderBinder.SecondaryBinder -->
  <class name="ThrowingProviderBinder.SecondaryBinder" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="SecondaryBinder" type="java.lang.Class&lt;P&gt;, java.lang.reflect.Type"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="annotatedWith" return="com.google.inject.throwingproviders.ThrowingProviderBinder.SecondaryBinder&lt;P, T&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="annotationType" type="java.lang.Class&lt;? extends java.lang.annotation.Annotation&gt;"/>
    </method>
    <method name="annotatedWith" return="com.google.inject.throwingproviders.ThrowingProviderBinder.SecondaryBinder&lt;P, T&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="annotation" type="java.lang.annotation.Annotation"/>
    </method>
    <method name="scopeExceptions" return="com.google.inject.throwingproviders.ThrowingProviderBinder.SecondaryBinder&lt;P, T&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="scopeExceptions" type="boolean"/>
      <doc>
      <![CDATA[Determines if exceptions should be scoped. By default exceptions are scoped.

 @param scopeExceptions whether exceptions should be scoped.
 @since 4.0]]>
      </doc>
    </method>
    <method name="to" return="com.google.inject.binder.ScopedBindingBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="target" type="P extends com.google.inject.throwingproviders.CheckedProvider"/>
    </method>
    <method name="to" return="com.google.inject.binder.ScopedBindingBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="targetType" type="java.lang.Class&lt;? extends P&gt;"/>
    </method>
    <method name="providing" return="com.google.inject.binder.ScopedBindingBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="cxtorClass" type="java.lang.Class&lt;? extends T&gt;"/>
      <doc>
      <![CDATA[@since 4.0]]>
      </doc>
    </method>
    <method name="providing" return="com.google.inject.binder.ScopedBindingBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="cxtorLiteral" type="com.google.inject.TypeLiteral&lt;? extends T&gt;"/>
      <doc>
      <![CDATA[@since 4.0]]>
      </doc>
    </method>
    <method name="to" return="com.google.inject.binder.ScopedBindingBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="targetKey" type="com.google.inject.Key&lt;? extends P&gt;"/>
    </method>
  </class>
  <!-- end class com.google.inject.throwingproviders.ThrowingProviderBinder.SecondaryBinder -->
</package>
<package name="com.google.inject.tools.jmx">
  <!-- start interface com.google.inject.tools.jmx.ManagedBindingMBean -->
  <interface name="ManagedBindingMBean"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="getSource" return="java.lang.String"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the source of this binding.]]>
      </doc>
    </method>
    <method name="getProvider" return="java.lang.String"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the provider to which this binding is bound.]]>
      </doc>
    </method>
    <method name="getKey" return="java.lang.String"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the binding key.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[JMX interface to bindings.

 @author crazybob@google.com (Bob Lee)]]>
    </doc>
  </interface>
  <!-- end interface com.google.inject.tools.jmx.ManagedBindingMBean -->
  <!-- start class com.google.inject.tools.jmx.Manager -->
  <class name="Manager" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="Manager"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="manage"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="domain" type="java.lang.String"/>
      <param name="injector" type="com.google.inject.Injector"/>
      <doc>
      <![CDATA[Registers all the bindings of an Injector with the platform MBean server.
 Consider using the name of your root {@link Module} class as the domain.]]>
      </doc>
    </method>
    <method name="manage"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="server" type="javax.management.MBeanServer"/>
      <param name="domain" type="java.lang.String"/>
      <param name="injector" type="com.google.inject.Injector"/>
      <doc>
      <![CDATA[Registers all the bindings of an Injector with the given MBean server.
 Consider using the name of your root {@link Module} class as the domain.]]>
      </doc>
    </method>
    <method name="main"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="args" type="java.lang.String[]"/>
      <exception name="Exception" type="java.lang.Exception"/>
      <doc>
      <![CDATA[Run with no arguments for usage instructions.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Provides a JMX interface to Guice.

 @author crazybob@google.com (Bob Lee)]]>
    </doc>
  </class>
  <!-- end class com.google.inject.tools.jmx.Manager -->
</package>
<package name="com.google.inject.util">
  <!-- start class com.google.inject.util.Modules -->
  <class name="Modules" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="override" return="com.google.inject.util.Modules.OverriddenModuleBuilder"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="modules" type="com.google.inject.Module[]"/>
      <doc>
      <![CDATA[Returns a builder that creates a module that overlays override modules over the given
 modules. If a key is bound in both sets of modules, only the binding from the override modules
 is kept. If a single {@link PrivateModule} is supplied or all elements are from
 a single {@link PrivateBinder}, then this will overwrite the private bindings.
 Otherwise, private bindings will not be overwritten unless they are exposed. 
 This can be used to replace the bindings of a production module with test bindings:
 <pre>
 Module functionalTestModule
     = Modules.override(new ProductionModule()).with(new TestModule());
 </pre>

 <p>Prefer to write smaller modules that can be reused and tested without overrides.

 @param modules the modules whose bindings are open to be overridden]]>
      </doc>
    </method>
    <method name="override" return="com.google.inject.util.Modules.OverriddenModuleBuilder"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="modules" type="java.lang.Iterable&lt;? extends com.google.inject.Module&gt;"/>
      <doc>
      <![CDATA[Returns a builder that creates a module that overlays override modules over the given
 modules. If a key is bound in both sets of modules, only the binding from the override modules
 is kept. If a single {@link PrivateModule} is supplied or all elements are from
 a single {@link PrivateBinder}, then this will overwrite the private bindings.
 Otherwise, private bindings will not be overwritten unless they are exposed. 
 This can be used to replace the bindings of a production module with test bindings:
 <pre>
 Module functionalTestModule
     = Modules.override(getProductionModules()).with(getTestModules());
 </pre>

 <p>Prefer to write smaller modules that can be reused and tested without overrides.

 @param modules the modules whose bindings are open to be overridden]]>
      </doc>
    </method>
    <method name="combine" return="com.google.inject.Module"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="modules" type="com.google.inject.Module[]"/>
      <doc>
      <![CDATA[Returns a new module that installs all of {@code modules}.]]>
      </doc>
    </method>
    <method name="combine" return="com.google.inject.Module"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="modules" type="java.lang.Iterable&lt;? extends com.google.inject.Module&gt;"/>
      <doc>
      <![CDATA[Returns a new module that installs all of {@code modules}.]]>
      </doc>
    </method>
    <field name="EMPTY_MODULE" type="com.google.inject.Module"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[Static utility methods for creating and working with instances of {@link Module}.

 @author jessewilson@google.com (Jesse Wilson)
 @since 2.0]]>
    </doc>
  </class>
  <!-- end class com.google.inject.util.Modules -->
  <!-- start interface com.google.inject.util.Modules.OverriddenModuleBuilder -->
  <interface name="Modules.OverriddenModuleBuilder"    abstract="true"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="with" return="com.google.inject.Module"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="overrides" type="com.google.inject.Module[]"/>
      <doc>
      <![CDATA[See the EDSL example at {@link Modules#override(Module[]) override()}.]]>
      </doc>
    </method>
    <method name="with" return="com.google.inject.Module"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="overrides" type="java.lang.Iterable&lt;? extends com.google.inject.Module&gt;"/>
      <doc>
      <![CDATA[See the EDSL example at {@link Modules#override(Module[]) override()}.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[See the EDSL example at {@link Modules#override(Module[]) override()}.]]>
    </doc>
  </interface>
  <!-- end interface com.google.inject.util.Modules.OverriddenModuleBuilder -->
  <!-- start class com.google.inject.util.Providers -->
  <class name="Providers" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="of" return="com.google.inject.Provider&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="instance" type="T"/>
      <doc>
      <![CDATA[Returns a provider which always provides {@code instance}.  This should not
 be necessary to use in your application, but is helpful for several types
 of unit tests.

 @param instance the instance that should always be provided.  This is also
     permitted to be null, to enable aggressive testing, although in real
     life a Guice-supplied Provider will never return null.]]>
      </doc>
    </method>
    <method name="guicify" return="com.google.inject.Provider&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="provider" type="javax.inject.Provider&lt;T&gt;"/>
      <doc>
      <![CDATA[Returns a Guice-friendly {@code com.google.inject.Provider} for the given
 JSR-330 {@code javax.inject.Provider}. The converse method is unnecessary,
 since Guice providers directly implement the JSR-330 interface.
 
 @since 3.0]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Static utility methods for creating and working with instances of
 {@link Provider}.

 @author Kevin Bourrillion (kevinb9n@gmail.com)
 @since 2.0]]>
    </doc>
  </class>
  <!-- end class com.google.inject.util.Providers -->
  <!-- start class com.google.inject.util.Types -->
  <class name="Types" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="newParameterizedType" return="java.lang.reflect.ParameterizedType"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="rawType" type="java.lang.reflect.Type"/>
      <param name="typeArguments" type="java.lang.reflect.Type[]"/>
      <doc>
      <![CDATA[Returns a new parameterized type, applying {@code typeArguments} to
 {@code rawType}. The returned type does not have an owner type.

 @return a {@link java.io.Serializable serializable} parameterized type.]]>
      </doc>
    </method>
    <method name="newParameterizedTypeWithOwner" return="java.lang.reflect.ParameterizedType"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="ownerType" type="java.lang.reflect.Type"/>
      <param name="rawType" type="java.lang.reflect.Type"/>
      <param name="typeArguments" type="java.lang.reflect.Type[]"/>
      <doc>
      <![CDATA[Returns a new parameterized type, applying {@code typeArguments} to
 {@code rawType} and enclosed by {@code ownerType}.

 @return a {@link java.io.Serializable serializable} parameterized type.]]>
      </doc>
    </method>
    <method name="arrayOf" return="java.lang.reflect.GenericArrayType"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="componentType" type="java.lang.reflect.Type"/>
      <doc>
      <![CDATA[Returns an array type whose elements are all instances of
 {@code componentType}.

 @return a {@link java.io.Serializable serializable} generic array type.]]>
      </doc>
    </method>
    <method name="subtypeOf" return="java.lang.reflect.WildcardType"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="bound" type="java.lang.reflect.Type"/>
      <doc>
      <![CDATA[Returns a type that represents an unknown type that extends {@code bound}.
 For example, if {@code bound} is {@code CharSequence.class}, this returns
 {@code ? extends CharSequence}. If {@code bound} is {@code Object.class},
 this returns {@code ?}, which is shorthand for {@code ? extends Object}.]]>
      </doc>
    </method>
    <method name="supertypeOf" return="java.lang.reflect.WildcardType"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="bound" type="java.lang.reflect.Type"/>
      <doc>
      <![CDATA[Returns a type that represents an unknown supertype of {@code bound}. For
 example, if {@code bound} is {@code String.class}, this returns {@code ?
 super String}.]]>
      </doc>
    </method>
    <method name="listOf" return="java.lang.reflect.ParameterizedType"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="elementType" type="java.lang.reflect.Type"/>
      <doc>
      <![CDATA[Returns a type modelling a {@link List} whose elements are of type
 {@code elementType}.

 @return a {@link java.io.Serializable serializable} parameterized type.]]>
      </doc>
    </method>
    <method name="collectionOf" return="java.lang.reflect.ParameterizedType"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="elementType" type="java.lang.reflect.Type"/>
      <doc>
      <![CDATA[Returns a type modelling a {@link Collection} whose elements are of type
 {@code elementType}.

 @return a {@link java.io.Serializable serializable} parameterized type.]]>
      </doc>
    </method>
    <method name="setOf" return="java.lang.reflect.ParameterizedType"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="elementType" type="java.lang.reflect.Type"/>
      <doc>
      <![CDATA[Returns a type modelling a {@link Set} whose elements are of type
 {@code elementType}.

 @return a {@link java.io.Serializable serializable} parameterized type.]]>
      </doc>
    </method>
    <method name="mapOf" return="java.lang.reflect.ParameterizedType"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="keyType" type="java.lang.reflect.Type"/>
      <param name="valueType" type="java.lang.reflect.Type"/>
      <doc>
      <![CDATA[Returns a type modelling a {@link Map} whose keys are of type
 {@code keyType} and whose values are of type {@code valueType}.

 @return a {@link java.io.Serializable serializable} parameterized type.]]>
      </doc>
    </method>
    <method name="providerOf" return="java.lang.reflect.ParameterizedType"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="providedType" type="java.lang.reflect.Type"/>
      <doc>
      <![CDATA[Returns a type modelling a {@link Provider} that provides elements of type
 {@code elementType}.

 @return a {@link java.io.Serializable serializable} parameterized type.]]>
      </doc>
    </method>
    <method name="javaxProviderOf" return="java.lang.reflect.Type"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="java.lang.reflect.Type"/>
      <doc>
      <![CDATA[Returns a type modelling a {@link javax.inject.Provider} that provides elements of type
 {@code elementType}.

 @return a {@link java.io.Serializable serializable} parameterized type.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Static methods for working with types.

 @author crazybob@google.com (Bob Lee)
 @since 2.0]]>
    </doc>
  </class>
  <!-- end class com.google.inject.util.Types -->
</package>

</api>
