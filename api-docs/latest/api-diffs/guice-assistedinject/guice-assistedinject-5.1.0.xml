<?xml version="1.0" encoding="iso-8859-1" standalone="no"?>
<!-- Generated by the JDiff Javadoc doclet -->
<!-- (http://www.jdiff.org) -->
<!-- on Fri Apr 21 19:30:40 UTC 2023 -->

<api
  xmlns:xsi='http://www.w3.org/2001/XMLSchema-instance'
  xsi:noNamespaceSchemaLocation='api.xsd'
  name="guice-assistedinject-5.1.0"
  jdversion="1.0.9">

<!--  Command line arguments =  -doclet jdiff.JDiff -docletpath /home/runner/.m2/repository/xml-apis/xml-apis/1.4.01/xml-apis-1.4.01.jar:/home/runner/.m2/repository/xml-resolver/xml-resolver/1.2/xml-resolver-1.2.jar:/home/runner/.m2/repository/xerces/xercesImpl/2.10.0/xercesImpl-2.10.0.jar:/home/runner/.m2/repository/jdiff/jdiff/1.0.9/jdiff-1.0.9.jar -doclet jdiff.JDiff -docletpath /home/runner/.m2/repository/xml-apis/xml-apis/1.4.01/xml-apis-1.4.01.jar:/home/runner/.m2/repository/xml-resolver/xml-resolver/1.2/xml-resolver-1.2.jar:/home/runner/.m2/repository/xerces/xercesImpl/2.10.0/xercesImpl-2.10.0.jar:/home/runner/.m2/repository/jdiff/jdiff/1.0.9/jdiff-1.0.9.jar -apiname guice-assistedinject-5.1.0 -apidir /home/runner/work/guice/guice/extensions/assistedinject/target/site/api-diffs/guice-assistedinject -classpath /home/runner/.m2/repository/com/google/guava/failureaccess/1.0.1/failureaccess-1.0.1.jar:/home/runner/.m2/repository/com/google/code/findbugs/jsr305/3.0.1/jsr305-3.0.1.jar:/home/runner/.m2/repository/com/google/inject/extensions/guice-assistedinject/5.1.0/guice-assistedinject-5.1.0.jar:/home/runner/.m2/repository/org/checkerframework/checker-qual/3.5.0/checker-qual-3.5.0.jar:/home/runner/.m2/repository/com/google/inject/guice/5.1.0/guice-5.1.0.jar:/home/runner/.m2/repository/javax/inject/javax.inject/1/javax.inject-1.jar:/home/runner/.m2/repository/com/google/guava/listenablefuture/9999.0-empty-to-avoid-conflict-with-guava/listenablefuture-9999.0-empty-to-avoid-conflict-with-guava.jar:/home/runner/.m2/repository/com/google/j2objc/j2objc-annotations/1.3/j2objc-annotations-1.3.jar:/home/runner/.m2/repository/com/google/errorprone/error_prone_annotations/2.3.4/error_prone_annotations-2.3.4.jar:/home/runner/.m2/repository/com/google/guava/guava/30.1-jre/guava-30.1-jre.jar:/home/runner/.m2/repository/aopalliance/aopalliance/1.0/aopalliance-1.0.jar -sourcepath /tmp/jdiff9106912395810038833/guice-assistedinject/5.1.0/sources -->
<package name="com.google.inject.assistedinject">
  <!-- start interface com.google.inject.assistedinject.Assisted -->
  <interface name="Assisted"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.lang.annotation.Annotation"/>
    <method name="value" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The unique name for this parameter. This is matched to the {@literal @Assisted} constructor
 parameter with the same value. Names are not necessary when the parameter types are distinct.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Annotates an injected parameter or field whose value comes from an argument to a factory method.

 @author jmourits@google.com (Jerome Mourits)
 @author jessewilson@google.com (Jesse Wilson)]]>
    </doc>
  </interface>
  <!-- end interface com.google.inject.assistedinject.Assisted -->
  <!-- start interface com.google.inject.assistedinject.AssistedInject -->
  <interface name="AssistedInject"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.lang.annotation.Annotation"/>
    <doc>
    <![CDATA[When used in tandem with {@link FactoryModuleBuilder}, constructors annotated with
 {@code @AssistedInject} indicate that multiple constructors can be injected, each with different
 parameters. AssistedInject annotations should not be mixed with {@literal @}{@link Inject}
 annotations. The assisted parameters must exactly match one corresponding factory method within
 the factory interface, but the parameters do not need to be in the same order. Constructors
 annotated with AssistedInject <b>are</b> created by Guice and receive all the benefits (such as
 AOP).

 <p><strong>Obsolete Usage:</strong> When used in tandem with {@link FactoryProvider},
 constructors annotated with {@code @AssistedInject} trigger a "backwards compatibility mode". The
 assisted parameters must exactly match one corresponding factory method within the factory
 interface and all must be in the same order as listed in the factory. In this backwards
 compatable mode, constructors annotated with AssistedInject <b>are not</b> created by Guice and
 thus receive none of the benefits.

 <p>Constructor parameters must be either supplied by the factory interface and marked with <code>
 {@literal @}Assisted</code>, or they must be injectable.

 @author jmourits@google.com (Jerome Mourits)
 @author jessewilson@google.com (Jesse Wilson)]]>
    </doc>
  </interface>
  <!-- end interface com.google.inject.assistedinject.AssistedInject -->
  <!-- start interface com.google.inject.assistedinject.AssistedInjectBinding -->
  <interface name="AssistedInjectBinding"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="getKey" return="com.google.inject.Key"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the {@link Key} for the factory binding.]]>
      </doc>
    </method>
    <method name="getAssistedMethods" return="java.util.Collection"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns an {@link AssistedMethod} for each method in the factory.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A binding for a factory created by FactoryModuleBuilder.

 @param <T> The fully qualified type of the factory.
 @since 3.0
 @author ramakrishna@google.com (Ramakrishna Rajanna)]]>
    </doc>
  </interface>
  <!-- end interface com.google.inject.assistedinject.AssistedInjectBinding -->
  <!-- start interface com.google.inject.assistedinject.AssistedInjectTargetVisitor -->
  <interface name="AssistedInjectTargetVisitor"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.inject.spi.BindingTargetVisitor"/>
    <method name="visit" return="java.lang.Object"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="assistedInjectBinding" type="com.google.inject.assistedinject.AssistedInjectBinding"/>
      <doc>
      <![CDATA[Visits an {@link AssistedInjectBinding} created through {@link FactoryModuleBuilder}.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A visitor for the AssistedInject extension.

 <p>If your {@link BindingTargetVisitor} implements this interface, bindings created by using
 {@link FactoryModuleBuilder} will be visited through this interface.

 @since 3.0
 @author ramakrishna@google.com (Ramakrishna Rajanna)]]>
    </doc>
  </interface>
  <!-- end interface com.google.inject.assistedinject.AssistedInjectTargetVisitor -->
  <!-- start interface com.google.inject.assistedinject.AssistedMethod -->
  <interface name="AssistedMethod"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="getFactoryMethod" return="java.lang.reflect.Method"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the factory method that is being assisted.]]>
      </doc>
    </method>
    <method name="getImplementationType" return="com.google.inject.TypeLiteral"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the implementation type that will be created when the method is used.]]>
      </doc>
    </method>
    <method name="getImplementationConstructor" return="java.lang.reflect.Constructor"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the constructor that will be used to construct instances of the implementation.]]>
      </doc>
    </method>
    <method name="getDependencies" return="java.util.Set"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns all non-assisted dependencies required to construct and inject the implementation.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Details about how a method in an assisted inject factory will be assisted.

 @since 3.0
 @author ramakrishna@google.com (Ramakrishna Rajanna)]]>
    </doc>
  </interface>
  <!-- end interface com.google.inject.assistedinject.AssistedMethod -->
  <!-- start class com.google.inject.assistedinject.FactoryModuleBuilder -->
  <class name="FactoryModuleBuilder" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="FactoryModuleBuilder"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="implement" return="com.google.inject.assistedinject.FactoryModuleBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="source" type="java.lang.Class"/>
      <param name="target" type="java.lang.Class"/>
      <doc>
      <![CDATA[See the factory configuration examples at {@link FactoryModuleBuilder}.]]>
      </doc>
    </method>
    <method name="implement" return="com.google.inject.assistedinject.FactoryModuleBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="source" type="java.lang.Class"/>
      <param name="target" type="com.google.inject.TypeLiteral"/>
      <doc>
      <![CDATA[See the factory configuration examples at {@link FactoryModuleBuilder}.]]>
      </doc>
    </method>
    <method name="implement" return="com.google.inject.assistedinject.FactoryModuleBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="source" type="com.google.inject.TypeLiteral"/>
      <param name="target" type="java.lang.Class"/>
      <doc>
      <![CDATA[See the factory configuration examples at {@link FactoryModuleBuilder}.]]>
      </doc>
    </method>
    <method name="implement" return="com.google.inject.assistedinject.FactoryModuleBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="source" type="com.google.inject.TypeLiteral"/>
      <param name="target" type="com.google.inject.TypeLiteral"/>
      <doc>
      <![CDATA[See the factory configuration examples at {@link FactoryModuleBuilder}.]]>
      </doc>
    </method>
    <method name="implement" return="com.google.inject.assistedinject.FactoryModuleBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="source" type="java.lang.Class"/>
      <param name="annotation" type="java.lang.annotation.Annotation"/>
      <param name="target" type="java.lang.Class"/>
      <doc>
      <![CDATA[See the factory configuration examples at {@link FactoryModuleBuilder}.]]>
      </doc>
    </method>
    <method name="implement" return="com.google.inject.assistedinject.FactoryModuleBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="source" type="java.lang.Class"/>
      <param name="annotation" type="java.lang.annotation.Annotation"/>
      <param name="target" type="com.google.inject.TypeLiteral"/>
      <doc>
      <![CDATA[See the factory configuration examples at {@link FactoryModuleBuilder}.]]>
      </doc>
    </method>
    <method name="implement" return="com.google.inject.assistedinject.FactoryModuleBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="source" type="com.google.inject.TypeLiteral"/>
      <param name="annotation" type="java.lang.annotation.Annotation"/>
      <param name="target" type="java.lang.Class"/>
      <doc>
      <![CDATA[See the factory configuration examples at {@link FactoryModuleBuilder}.]]>
      </doc>
    </method>
    <method name="implement" return="com.google.inject.assistedinject.FactoryModuleBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="source" type="com.google.inject.TypeLiteral"/>
      <param name="annotation" type="java.lang.annotation.Annotation"/>
      <param name="target" type="com.google.inject.TypeLiteral"/>
      <doc>
      <![CDATA[See the factory configuration examples at {@link FactoryModuleBuilder}.]]>
      </doc>
    </method>
    <method name="implement" return="com.google.inject.assistedinject.FactoryModuleBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="source" type="java.lang.Class"/>
      <param name="annotationType" type="java.lang.Class"/>
      <param name="target" type="java.lang.Class"/>
      <doc>
      <![CDATA[See the factory configuration examples at {@link FactoryModuleBuilder}.]]>
      </doc>
    </method>
    <method name="implement" return="com.google.inject.assistedinject.FactoryModuleBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="source" type="java.lang.Class"/>
      <param name="annotationType" type="java.lang.Class"/>
      <param name="target" type="com.google.inject.TypeLiteral"/>
      <doc>
      <![CDATA[See the factory configuration examples at {@link FactoryModuleBuilder}.]]>
      </doc>
    </method>
    <method name="implement" return="com.google.inject.assistedinject.FactoryModuleBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="source" type="com.google.inject.TypeLiteral"/>
      <param name="annotationType" type="java.lang.Class"/>
      <param name="target" type="java.lang.Class"/>
      <doc>
      <![CDATA[See the factory configuration examples at {@link FactoryModuleBuilder}.]]>
      </doc>
    </method>
    <method name="implement" return="com.google.inject.assistedinject.FactoryModuleBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="source" type="com.google.inject.TypeLiteral"/>
      <param name="annotationType" type="java.lang.Class"/>
      <param name="target" type="com.google.inject.TypeLiteral"/>
      <doc>
      <![CDATA[See the factory configuration examples at {@link FactoryModuleBuilder}.]]>
      </doc>
    </method>
    <method name="implement" return="com.google.inject.assistedinject.FactoryModuleBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="source" type="com.google.inject.Key"/>
      <param name="target" type="java.lang.Class"/>
      <doc>
      <![CDATA[See the factory configuration examples at {@link FactoryModuleBuilder}.]]>
      </doc>
    </method>
    <method name="implement" return="com.google.inject.assistedinject.FactoryModuleBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="source" type="com.google.inject.Key"/>
      <param name="target" type="com.google.inject.TypeLiteral"/>
      <doc>
      <![CDATA[See the factory configuration examples at {@link FactoryModuleBuilder}.]]>
      </doc>
    </method>
    <method name="withLookups" return="com.google.inject.assistedinject.FactoryModuleBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="lookups" type="java.lang.invoke.MethodHandles.Lookup"/>
      <doc>
      <![CDATA[Typically called via {@code withLookups(MethodHandles.lookup())}. Sets the MethodHandles.Lookup
 that the factory implementation will use to call default methods on the factory interface.
 While this is not always required, it is always OK to set it. It is required if the factory
 passed to {@link #build} is non-public and javac generated default methods while compiling it
 (which javac can sometimes do if the factory uses generic types).

 <p>Guice will try to work properly even if this method is not called (or called with a lookups
 that doesn't have access to the factory), but doing so requires reflection into the JDK, which
 may break at any time (and trigger unsafe access warnings).

 @since 5.0]]>
      </doc>
    </method>
    <method name="build" return="com.google.inject.Module"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="factoryInterface" type="java.lang.Class"/>
      <doc>
      <![CDATA[See the factory configuration examples at {@link FactoryModuleBuilder}.]]>
      </doc>
    </method>
    <method name="build" return="com.google.inject.Module"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="factoryInterface" type="com.google.inject.TypeLiteral"/>
      <doc>
      <![CDATA[See the factory configuration examples at {@link FactoryModuleBuilder}.]]>
      </doc>
    </method>
    <method name="build" return="com.google.inject.Module"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="factoryInterface" type="com.google.inject.Key"/>
    </method>
    <doc>
    <![CDATA[Provides a factory that combines the caller's arguments with injector-supplied values to
 construct objects.

 <h3>Defining a factory</h3>

 Create an interface whose methods return the constructed type, or any of its supertypes. The
 method's parameters are the arguments required to build the constructed type.

 <pre>public interface PaymentFactory {
   Payment create(Date startDate, Money amount);
 }</pre>

 You can name your factory methods whatever you like, such as <i>create</i>, <i>createPayment</i>
 or <i>newPayment</i>.

 <h3>Creating a type that accepts factory parameters</h3>

 {@code constructedType} is a concrete class with an {@literal @}{@link com.google.inject.Inject
 Inject}-annotated constructor. In addition to injector-supplied parameters, the constructor
 should have parameters that match each of the factory method's parameters. Each factory-supplied
 parameter requires an {@literal @}{@link Assisted} annotation. This serves to document that the
 parameter is not bound by your application's modules.

 <pre>public class RealPayment implements Payment {
   {@literal @}Inject
   public RealPayment(
      CreditService creditService,
      AuthService authService,
      <strong>{@literal @}Assisted Date startDate</strong>,
      <strong>{@literal @}Assisted Money amount</strong>) {
     ...
   }
 }</pre>

 <h3>Multiple factory methods for the same type</h3>

 If the factory contains many methods that return the same type, you can create multiple
 constructors in your concrete class, each constructor marked with with {@literal @}{@link
 AssistedInject}, in order to match the different parameters types of the factory methods.

 <pre>public interface PaymentFactory {
    Payment create(Date startDate, Money amount);
    Payment createWithoutDate(Money amount);
 }

 public class RealPayment implements Payment {
  {@literal @}AssistedInject
   public RealPayment(
      CreditService creditService,
      AuthService authService,
     <strong>{@literal @}Assisted Date startDate</strong>,
     <strong>{@literal @}Assisted Money amount</strong>) {
     ...
   }

  {@literal @}AssistedInject
   public RealPayment(
      CreditService creditService,
      AuthService authService,
     <strong>{@literal @}Assisted Money amount</strong>) {
     ...
   }
 }</pre>

 <h3>Configuring simple factories</h3>

 In your {@link Module module}, install a {@code FactoryModuleBuilder} that creates the factory:

 <pre>install(new FactoryModuleBuilder()
     .implement(Payment.class, RealPayment.class)
     .build(PaymentFactory.class));</pre>

 As a side-effect of this binding, Guice will inject the factory to initialize it for use. The
 factory cannot be used until the injector has been initialized.

 <h3>Configuring complex factories</h3>

 Factories can create an arbitrary number of objects, one per each method. Each factory method can
 be configured using <code>.implement</code>.

 <pre>public interface OrderFactory {
    Payment create(Date startDate, Money amount);
    Shipment create(Customer customer, Item item);
    Receipt create(Payment payment, Shipment shipment);
 }

 [...]

 install(new FactoryModuleBuilder()
     .implement(Payment.class, RealPayment.class)
     // excluding .implement for Shipment means the implementation class
     // will be 'Shipment' itself, which is legal if it's not an interface.
     .implement(Receipt.class, RealReceipt.class)
     .build(OrderFactory.class));</pre>

 </pre>

 <h3>Using the factory</h3>

 Inject your factory into your application classes. When you use the factory, your arguments will
 be combined with values from the injector to construct an instance.

 <pre>public class PaymentAction {
   {@literal @}Inject private PaymentFactory paymentFactory;

   public void doPayment(Money amount) {
     Payment payment = paymentFactory.create(new Date(), amount);
     payment.apply();
   }
 }</pre>

 <h3>Making parameter types distinct</h3>

 The types of the factory method's parameters must be distinct. To use multiple parameters of the
 same type, use a named {@literal @}{@link Assisted} annotation to disambiguate the parameters.
 The names must be applied to the factory method's parameters:

 <pre>public interface PaymentFactory {
   Payment create(
       <strong>{@literal @}Assisted("startDate")</strong> Date startDate,
       <strong>{@literal @}Assisted("dueDate")</strong> Date dueDate,
       Money amount);
 } </pre>

 ...and to the concrete type's constructor parameters:

 <pre>public class RealPayment implements Payment {
   {@literal @}Inject
   public RealPayment(
      CreditService creditService,
      AuthService authService,
      <strong>{@literal @}Assisted("startDate")</strong> Date startDate,
      <strong>{@literal @}Assisted("dueDate")</strong> Date dueDate,
      <strong>{@literal @}Assisted</strong> Money amount) {
     ...
   }
 }</pre>

 <h3>Values are created by Guice</h3>

 Returned factories use child injectors to create values. The values are eligible for method
 interception. In addition, {@literal @}{@literal Inject} members will be injected before they are
 returned.

 <h3>More configuration options</h3>

 In addition to simply specifying an implementation class for any returned type, factories' return
 values can be automatic or can be configured to use annotations:

 <p>If you just want to return the types specified in the factory, do not configure any
 implementations:

 <pre>public interface FruitFactory {
   Apple getApple(Color color);
 }
 ...
 protected void configure() {
   install(new FactoryModuleBuilder().build(FruitFactory.class));
 }</pre>

 Note that any type returned by the factory in this manner needs to be an implementation class.

 <p>To return two different implementations for the same interface from your factory, use binding
 annotations on your return types:

 <pre>interface CarFactory {
   {@literal @}Named("fast") Car getFastCar(Color color);
   {@literal @}Named("clean") Car getCleanCar(Color color);
 }
 ...
 protected void configure() {
   install(new FactoryModuleBuilder()
       .implement(Car.class, Names.named("fast"), Porsche.class)
       .implement(Car.class, Names.named("clean"), Prius.class)
       .build(CarFactory.class));
 }</pre>

 <h3>Implementation limitations</h3>

 As a limitation of the implementation, it is prohibited to declare a factory method that accepts
 a {@code Provider} as one of its arguments.

 @since 3.0
 @author schmitt@google.com (Peter Schmitt)]]>
    </doc>
  </class>
  <!-- end class com.google.inject.assistedinject.FactoryModuleBuilder -->
  <!-- start class com.google.inject.assistedinject.FactoryProvider -->
  <class name="FactoryProvider" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="use {@link FactoryModuleBuilder} instead.">
    <implements name="com.google.inject.Provider"/>
    <implements name="com.google.inject.spi.HasDependencies"/>
    <method name="newFactory" return="com.google.inject.Provider"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="factoryType" type="java.lang.Class"/>
      <param name="implementationType" type="java.lang.Class"/>
    </method>
    <method name="newFactory" return="com.google.inject.Provider"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="factoryType" type="com.google.inject.TypeLiteral"/>
      <param name="implementationType" type="com.google.inject.TypeLiteral"/>
    </method>
    <method name="getDependencies" return="java.util.Set"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="get" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="obj" type="java.lang.Object"/>
    </method>
    <doc>
    <![CDATA[<strong>Obsolete.</strong> Prefer {@link FactoryModuleBuilder} for its more concise API and
 additional capability.

 <p>Provides a factory that combines the caller's arguments with injector-supplied values to
 construct objects.

 <h3>Defining a factory</h3>

 Create an interface whose methods return the constructed type, or any of its supertypes. The
 method's parameters are the arguments required to build the constructed type.

 <pre>public interface PaymentFactory {
   Payment create(Date startDate, Money amount);
 }</pre>

 You can name your factory methods whatever you like, such as <i>create</i>, <i>createPayment</i>
 or <i>newPayment</i>.

 <h3>Creating a type that accepts factory parameters</h3>

 {@code constructedType} is a concrete class with an {@literal @}{@link Inject}-annotated
 constructor. In addition to injector-supplied parameters, the constructor should have parameters
 that match each of the factory method's parameters. Each factory-supplied parameter requires an
 {@literal @}{@link Assisted} annotation. This serves to document that the parameter is not bound
 by your application's modules.

 <pre>public class RealPayment implements Payment {
   {@literal @}Inject
   public RealPayment(
      CreditService creditService,
      AuthService authService,
      <strong>{@literal @}Assisted Date startDate</strong>,
      <strong>{@literal @}Assisted Money amount</strong>) {
     ...
   }
 }</pre>

 Any parameter that permits a null value should also be annotated {@code @Nullable}.

 <h3>Configuring factories</h3>

 In your {@link com.google.inject.Module module}, bind the factory interface to the returned
 factory:

 <pre>bind(PaymentFactory.class).toProvider(
     FactoryProvider.newFactory(PaymentFactory.class, RealPayment.class));</pre>

 As a side-effect of this binding, Guice will inject the factory to initialize it for use. The
 factory cannot be used until the injector has been initialized.

 <h3>Using the factory</h3>

 Inject your factory into your application classes. When you use the factory, your arguments will
 be combined with values from the injector to construct an instance.

 <pre>public class PaymentAction {
   {@literal @}Inject private PaymentFactory paymentFactory;

   public void doPayment(Money amount) {
     Payment payment = paymentFactory.create(new Date(), amount);
     payment.apply();
   }
 }</pre>

 <h3>Making parameter types distinct</h3>

 The types of the factory method's parameters must be distinct. To use multiple parameters of the
 same type, use a named {@literal @}{@link Assisted} annotation to disambiguate the parameters.
 The names must be applied to the factory method's parameters:

 <pre>public interface PaymentFactory {
   Payment create(
       <strong>{@literal @}Assisted("startDate")</strong> Date startDate,
       <strong>{@literal @}Assisted("dueDate")</strong> Date dueDate,
       Money amount);
 } </pre>

 ...and to the concrete type's constructor parameters:

 <pre>public class RealPayment implements Payment {
   {@literal @}Inject
   public RealPayment(
      CreditService creditService,
      AuthService authService,
      <strong>{@literal @}Assisted("startDate")</strong> Date startDate,
      <strong>{@literal @}Assisted("dueDate")</strong> Date dueDate,
      <strong>{@literal @}Assisted</strong> Money amount) {
     ...
   }
 }</pre>

 <h3>Values are created by Guice</h3>

 Returned factories use child injectors to create values. The values are eligible for method
 interception. In addition, {@literal @}{@literal Inject} members will be injected before they are
 returned.

 <h3>Backwards compatibility using {@literal @}AssistedInject</h3>

 Instead of the {@literal @}Inject annotation, you may annotate the constructed classes with
 {@literal @}{@link AssistedInject}. This triggers a limited backwards-compatability mode.

 <p>Instead of matching factory method arguments to constructor parameters using their names, the
 <strong>parameters are matched by their order</strong>. The first factory method argument is used
 for the first {@literal @}Assisted constructor parameter, etc.. Annotation names have no effect.

 <p>Returned values are <strong>not created by Guice</strong>. These types are not eligible for
 method interception. They do receive post-construction member injection.

 @param <F> The factory interface
 @author jmourits@google.com (Jerome Mourits)
 @author jessewilson@google.com (Jesse Wilson)
 @author dtm@google.com (Daniel Martin)
 @deprecated use {@link FactoryModuleBuilder} instead.]]>
    </doc>
  </class>
  <!-- end class com.google.inject.assistedinject.FactoryProvider -->
</package>
<package name="com.google.inject.assistedinject.internal">
</package>

</api>
