<?xml version="1.0" encoding="iso-8859-1" standalone="no"?>
<!-- Generated by the JDiff Javadoc doclet -->
<!-- (http://www.jdiff.org) -->
<!-- on Mon Nov 14 22:26:37 UTC 2022 -->

<api
  xmlns:xsi='http://www.w3.org/2001/XMLSchema-instance'
  xsi:noNamespaceSchemaLocation='api.xsd'
  name="guice-5.1.1-SNAPSHOT"
  jdversion="1.0.9">

<!--  Command line arguments =  -doclet jdiff.JDiff -docletpath /home/runner/.m2/repository/xml-apis/xml-apis/1.4.01/xml-apis-1.4.01.jar:/home/runner/.m2/repository/xml-resolver/xml-resolver/1.2/xml-resolver-1.2.jar:/home/runner/.m2/repository/xerces/xercesImpl/2.10.0/xercesImpl-2.10.0.jar:/home/runner/.m2/repository/jdiff/jdiff/1.0.9/jdiff-1.0.9.jar -doclet jdiff.JDiff -docletpath /home/runner/.m2/repository/xml-apis/xml-apis/1.4.01/xml-apis-1.4.01.jar:/home/runner/.m2/repository/xml-resolver/xml-resolver/1.2/xml-resolver-1.2.jar:/home/runner/.m2/repository/xerces/xercesImpl/2.10.0/xercesImpl-2.10.0.jar:/home/runner/.m2/repository/jdiff/jdiff/1.0.9/jdiff-1.0.9.jar -apiname guice-5.1.1-SNAPSHOT -apidir /home/runner/work/guice/guice/core/target/site/api-diffs/guice -classpath /home/runner/.m2/repository/com/google/guava/failureaccess/1.0.1/failureaccess-1.0.1.jar:/home/runner/.m2/repository/com/google/code/findbugs/jsr305/3.0.1/jsr305-3.0.1.jar:/home/runner/.m2/repository/com/google/guava/guava/31.0.1-jre/guava-31.0.1-jre.jar:/home/runner/.m2/repository/org/checkerframework/checker-qual/3.12.0/checker-qual-3.12.0.jar:/home/runner/.m2/repository/javax/inject/javax.inject/1/javax.inject-1.jar:/home/runner/.m2/repository/com/google/guava/listenablefuture/9999.0-empty-to-avoid-conflict-with-guava/listenablefuture-9999.0-empty-to-avoid-conflict-with-guava.jar:/home/runner/.m2/repository/com/google/errorprone/error_prone_annotations/2.7.1/error_prone_annotations-2.7.1.jar:/home/runner/.m2/repository/com/google/j2objc/j2objc-annotations/1.3/j2objc-annotations-1.3.jar:/home/runner/work/guice/guice/core/target/guice-5.1.1-SNAPSHOT.jar:/home/runner/.m2/repository/org/ow2/asm/asm/9.2/asm-9.2.jar:/home/runner/.m2/repository/aopalliance/aopalliance/1.0/aopalliance-1.0.jar -sourcepath /tmp/jdiff7754445423825645406/guice/5.1.1-SNAPSHOT/sources -->
<package name="com.google.inject.multibindings">
  <!-- start interface com.google.inject.multibindings.ClassMapKey -->
  <interface name="ClassMapKey"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.lang.annotation.Annotation"/>
    <method name="value" return="java.lang.Class"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Allows {@literal @}{@link ProvidesIntoMap} to specify a class map key.

 @since 4.0]]>
    </doc>
  </interface>
  <!-- end interface com.google.inject.multibindings.ClassMapKey -->
  <!-- start class com.google.inject.multibindings.MapBinder -->
  <class name="MapBinder" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="newMapBinder" return="com.google.inject.multibindings.MapBinder"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="binder" type="com.google.inject.Binder"/>
      <param name="keyType" type="com.google.inject.TypeLiteral"/>
      <param name="valueType" type="com.google.inject.TypeLiteral"/>
      <doc>
      <![CDATA[Returns a new mapbinder that collects entries of {@code keyType}/{@code valueType} in a {@link
 Map} that is itself bound with no binding annotation.]]>
      </doc>
    </method>
    <method name="newMapBinder" return="com.google.inject.multibindings.MapBinder"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="binder" type="com.google.inject.Binder"/>
      <param name="keyType" type="java.lang.Class"/>
      <param name="valueType" type="java.lang.Class"/>
      <doc>
      <![CDATA[Returns a new mapbinder that collects entries of {@code keyType}/{@code valueType} in a {@link
 Map} that is itself bound with no binding annotation.]]>
      </doc>
    </method>
    <method name="newMapBinder" return="com.google.inject.multibindings.MapBinder"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="binder" type="com.google.inject.Binder"/>
      <param name="keyType" type="com.google.inject.TypeLiteral"/>
      <param name="valueType" type="com.google.inject.TypeLiteral"/>
      <param name="annotation" type="java.lang.annotation.Annotation"/>
      <doc>
      <![CDATA[Returns a new mapbinder that collects entries of {@code keyType}/{@code valueType} in a {@link
 Map} that is itself bound with {@code annotation}.]]>
      </doc>
    </method>
    <method name="newMapBinder" return="com.google.inject.multibindings.MapBinder"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="binder" type="com.google.inject.Binder"/>
      <param name="keyType" type="java.lang.Class"/>
      <param name="valueType" type="java.lang.Class"/>
      <param name="annotation" type="java.lang.annotation.Annotation"/>
      <doc>
      <![CDATA[Returns a new mapbinder that collects entries of {@code keyType}/{@code valueType} in a {@link
 Map} that is itself bound with {@code annotation}.]]>
      </doc>
    </method>
    <method name="newMapBinder" return="com.google.inject.multibindings.MapBinder"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="binder" type="com.google.inject.Binder"/>
      <param name="keyType" type="com.google.inject.TypeLiteral"/>
      <param name="valueType" type="com.google.inject.TypeLiteral"/>
      <param name="annotationType" type="java.lang.Class"/>
      <doc>
      <![CDATA[Returns a new mapbinder that collects entries of {@code keyType}/{@code valueType} in a {@link
 Map} that is itself bound with {@code annotationType}.]]>
      </doc>
    </method>
    <method name="newMapBinder" return="com.google.inject.multibindings.MapBinder"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="binder" type="com.google.inject.Binder"/>
      <param name="keyType" type="java.lang.Class"/>
      <param name="valueType" type="java.lang.Class"/>
      <param name="annotationType" type="java.lang.Class"/>
      <doc>
      <![CDATA[Returns a new mapbinder that collects entries of {@code keyType}/{@code valueType} in a {@link
 Map} that is itself bound with {@code annotationType}.]]>
      </doc>
    </method>
    <method name="permitDuplicates" return="com.google.inject.multibindings.MapBinder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Configures the {@code MapBinder} to handle duplicate entries.

 <p>When multiple equal keys are bound, the value that gets included in the map is arbitrary.

 <p>In addition to the {@code Map<K, V>} and {@code Map<K, Provider<V>>} maps that are normally
 bound, a {@code Map<K, Set<V>>} and {@code Map<K, Set<Provider<V>>>} are <em>also</em> bound,
 which contain all values bound to each key.

 <p>When multiple modules contribute elements to the map, this configuration option impacts all
 of them.

 @return this map binder
 @since 3.0]]>
      </doc>
    </method>
    <method name="addBinding" return="com.google.inject.binder.LinkedBindingBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.lang.Object"/>
      <doc>
      <![CDATA[Returns a binding builder used to add a new entry in the map. Each key must be distinct (and
 non-null). Bound providers will be evaluated each time the map is injected.

 <p>It is an error to call this method without also calling one of the {@code to} methods on the
 returned binding builder.

 <p>Scoping elements independently is supported. Use the {@code in} method to specify a binding
 scope.]]>
      </doc>
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="obj" type="java.lang.Object"/>
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[An API to bind multiple map entries separately, only to later inject them as a complete map.
 MapBinder is intended for use in your application's module:

 <pre><code>
 public class SnacksModule extends AbstractModule {
   protected void configure() {
     MapBinder&lt;String, Snack&gt; mapbinder
         = MapBinder.newMapBinder(binder(), String.class, Snack.class);
     mapbinder.addBinding("twix").toInstance(new Twix());
     mapbinder.addBinding("snickers").toProvider(SnickersProvider.class);
     mapbinder.addBinding("skittles").to(Skittles.class);
   }
 }</code></pre>

 <p>With this binding, a {@link Map}{@code <String, Snack>} can now be injected:

 <pre><code>
 class SnackMachine {
   {@literal @}Inject
   public SnackMachine(Map&lt;String, Snack&gt; snacks) { ... }
 }</code></pre>

 <p>In addition to binding {@code Map<K, V>}, a mapbinder will also bind {@code Map<K,
 Provider<V>>} for lazy value provision:

 <pre><code>
 class SnackMachine {
   {@literal @}Inject
   public SnackMachine(Map&lt;String, Provider&lt;Snack&gt;&gt; snackProviders) { ... }
 }</code></pre>

 <p>Contributing mapbindings from different modules is supported. For example, it is okay to have
 both {@code CandyModule} and {@code ChipsModule} both create their own {@code MapBinder<String,
 Snack>}, and to each contribute bindings to the snacks map. When that map is injected, it will
 contain entries from both modules.

 <p>The map's iteration order is consistent with the binding order. This is convenient when
 multiple elements are contributed by the same module because that module can order its bindings
 appropriately. Avoid relying on the iteration order of elements contributed by different modules,
 since there is no equivalent mechanism to order modules.

 <p>The map is unmodifiable. Elements can only be added to the map by configuring the MapBinder.
 Elements can never be removed from the map.

 <p>Values are resolved at map injection time. If a value is bound to a provider, that provider's
 get method will be called each time the map is injected (unless the binding is also scoped, or a
 map of providers is injected).

 <p>Annotations are used to create different maps of the same key/value type. Each distinct
 annotation gets its own independent map.

 <p><strong>Keys must be distinct.</strong> If the same key is bound more than once, map injection
 will fail. However, use {@link #permitDuplicates()} in order to allow duplicate keys; extra
 bindings to {@code Map<K, Set<V>>} and {@code Map<K, Set<Provider<V>>} will be added.

 <p><strong>Keys must be non-null.</strong> {@code addBinding(null)} will throw an unchecked
 exception.

 <p><strong>Values must be non-null to use map injection.</strong> If any value is null, map
 injection will fail (although injecting a map of providers will not).

 @author dpb@google.com (David P. Baker)]]>
    </doc>
  </class>
  <!-- end class com.google.inject.multibindings.MapBinder -->
  <!-- start interface com.google.inject.multibindings.MapBinderBinding -->
  <interface name="MapBinderBinding"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="getMapKey" return="com.google.inject.Key"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the {@link Key} for the map.]]>
      </doc>
    </method>
    <method name="getAlternateMapKeys" return="java.util.Set"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the keys of other bindings that represent this map. This will return an entry for
 {@code Map<K, com.google.inject.Provider<V>>}, {@code Map<K, javax.inject.Provider<V>>}, {@code
 Map<K, Set<com.google.inject.Provider<V>>>}, {@code Map<K, Set<javax.inject.Provider<V>>>},
 {@code Map<K, Collection<com.google.inject.Provider<V>>>}, {@code Map<K,
 Collection<javax.inject.Provider<V>>>}, {@code Map<K, Set<V>}, and {@code Map<K, ? extends V>}.

 @since 4.2.3]]>
      </doc>
    </method>
    <method name="getKeyTypeLiteral" return="com.google.inject.TypeLiteral"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the TypeLiteral describing the keys of the map.

 <p>The TypeLiteral will always match the type Map's generic type. For example, if getMapKey
 returns a key of {@code Map<String, Snack>}, then this will always return a {@code
 TypeLiteral<String>}.]]>
      </doc>
    </method>
    <method name="getValueTypeLiteral" return="com.google.inject.TypeLiteral"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the TypeLiteral describing the values of the map.

 <p>The TypeLiteral will always match the type Map's generic type. For example, if getMapKey
 returns a key of {@code Map<String, Snack>}, then this will always return a {@code
 TypeLiteral<Snack>}.]]>
      </doc>
    </method>
    <method name="getEntries" return="java.util.List"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns all entries in the Map. The returned list of Map.Entries contains the key and a binding
 to the value. Duplicate keys or values will exist as separate Map.Entries in the returned list.
 This is only supported on bindings returned from an injector. This will throw {@link
 UnsupportedOperationException} if it is called on an element retrieved from {@link
 Elements#getElements}.

 <p>The elements will always match the type Map's generic type. For example, if getMapKey
 returns a key of {@code Map<String, Snack>}, then this will always return a list of type {@code
 List<Map.Entry<String, Binding<Snack>>>}.]]>
      </doc>
    </method>
    <method name="getEntries" return="java.util.List"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="elements" type="java.lang.Iterable"/>
      <doc>
      <![CDATA[Similar to {@link #getEntries()}, but can be used on a MapBinderBinding retrieved from {@link
 Elements#getElements}.

 <p>One way to use this is to pass in the results of {@link Elements#getElements} as the {@code
 elements} parameter.

 <p>This differs from {@link #getEntries()} in that it will return duplicates if they are
 present in the {@code elements} passed in. This does not run the normal Guice de-duplication
 that {@link #getEntries()} does.

 @throws IllegalArgumentException if the provided elements contain partial map entries. If the
     elements come from {@link Elements#getElements} on a module with a MapBinder, there will be
     a 1:1 relationship and no exception will be thrown.
 @since 4.2]]>
      </doc>
    </method>
    <method name="permitsDuplicates" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns true if the MapBinder permits duplicates. This is only supported on bindings returned
 from an injector. This will throw {@link UnsupportedOperationException} if it is called on a
 MapBinderBinding retrieved from {@link Elements#getElements}.]]>
      </doc>
    </method>
    <method name="containsElement" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="element" type="com.google.inject.spi.Element"/>
      <doc>
      <![CDATA[Returns true if this MapBinder contains the given Element in order to build the map or uses the
 given Element in order to support building and injecting the map. This will work for
 MapBinderBindings retrieved from an injector and {@link Elements#getElements}. Usually this is
 only necessary if you are working with elements retrieved from modules (without an Injector),
 otherwise {@link #getEntries} and {@link #permitsDuplicates} are better options.

 <p>If you need to introspect the details of the map, such as the keys, values or if it permits
 duplicates, it is necessary to pass the elements through an Injector and use {@link
 #getEntries()} and {@link #permitsDuplicates()}.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A binding for a MapBinder.

 <p>Although MapBinders may be injected through a variety of generic types ({@code Map<K, V>},
 {@code Map<K, ? extends V>}, {@code Map<K, Provider<V>>}, {@code Map<K, Set<V>>}, {@code Map<K,
 Set<Provider<V>>}, and even {@code Set<Map.Entry<K, Provider<V>>}), a MapBinderBinding exists
 only on the Binding associated with the {@code Map<K, V> key}. Injectable map types can be
 discovered using {@link #getMapKey} (which will return the {@code Map<K, V>} key), or{@link
 #getAlternateMapKeys} (which will return the other keys that can inject this data). Other
 bindings can be validated to be derived from this MapBinderBinding using {@link
 #containsElement(Element)}.

 @param <T> The fully qualified type of the map, including Map. For example: {@code
     MapBinderBinding<Map<String, Snack>>}
 @since 3.0
 @author sameb@google.com (Sam Berlin)]]>
    </doc>
  </interface>
  <!-- end interface com.google.inject.multibindings.MapBinderBinding -->
  <!-- start interface com.google.inject.multibindings.MapKey -->
  <interface name="MapKey"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.lang.annotation.Annotation"/>
    <method name="unwrapValue" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[if {@code unwrapValue} is false, then the whole annotation will be the type and annotation
 instances will be the keys. If {@code unwrapValue} is true, the value() type of key type
 annotation will be the key type for injected map and the value instances will be the keys.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Allows users define customized key type annotations for map bindings by annotating an annotation
 of a {@code Map}'s key type. The custom key annotation can be applied to methods also annotated
 with {@literal @}{@link ProvidesIntoMap}.

 <p>A {@link StringMapKey} and {@link ClassMapKey} are provided for convenience with maps whose
 keys are strings or classes. For maps with enums or primitive types as keys, you must provide
 your own MapKey annotation, such as this one for an enum:

 <pre>
 {@literal @}MapKey(unwrapValue = true)
 {@literal @}Retention(RUNTIME)
 public {@literal @}interface MyCustomEnumKey {
   MyCustomEnum value();
 }
 </pre>

 You can also use the whole annotation as the key, if {@code unwrapValue=false}. When unwrapValue
 is false, the annotation type will be the key type for the injected map and the annotation
 instances will be the key values. If {@code unwrapValue=true}, the value() type will be the key
 type for injected map and the value() instances will be the keys values.

 @since 4.0]]>
    </doc>
  </interface>
  <!-- end interface com.google.inject.multibindings.MapKey -->
  <!-- start class com.google.inject.multibindings.Multibinder -->
  <class name="Multibinder" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="newSetBinder" return="com.google.inject.multibindings.Multibinder"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="binder" type="com.google.inject.Binder"/>
      <param name="type" type="com.google.inject.TypeLiteral"/>
      <doc>
      <![CDATA[Returns a new multibinder that collects instances of {@code type} in a {@link Set} that is
 itself bound with no binding annotation.]]>
      </doc>
    </method>
    <method name="newSetBinder" return="com.google.inject.multibindings.Multibinder"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="binder" type="com.google.inject.Binder"/>
      <param name="type" type="java.lang.Class"/>
      <doc>
      <![CDATA[Returns a new multibinder that collects instances of {@code type} in a {@link Set} that is
 itself bound with no binding annotation.]]>
      </doc>
    </method>
    <method name="newSetBinder" return="com.google.inject.multibindings.Multibinder"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="binder" type="com.google.inject.Binder"/>
      <param name="type" type="com.google.inject.TypeLiteral"/>
      <param name="annotation" type="java.lang.annotation.Annotation"/>
      <doc>
      <![CDATA[Returns a new multibinder that collects instances of {@code type} in a {@link Set} that is
 itself bound with {@code annotation}.]]>
      </doc>
    </method>
    <method name="newSetBinder" return="com.google.inject.multibindings.Multibinder"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="binder" type="com.google.inject.Binder"/>
      <param name="type" type="java.lang.Class"/>
      <param name="annotation" type="java.lang.annotation.Annotation"/>
      <doc>
      <![CDATA[Returns a new multibinder that collects instances of {@code type} in a {@link Set} that is
 itself bound with {@code annotation}.]]>
      </doc>
    </method>
    <method name="newSetBinder" return="com.google.inject.multibindings.Multibinder"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="binder" type="com.google.inject.Binder"/>
      <param name="type" type="com.google.inject.TypeLiteral"/>
      <param name="annotationType" type="java.lang.Class"/>
      <doc>
      <![CDATA[Returns a new multibinder that collects instances of {@code type} in a {@link Set} that is
 itself bound with {@code annotationType}.]]>
      </doc>
    </method>
    <method name="newSetBinder" return="com.google.inject.multibindings.Multibinder"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="binder" type="com.google.inject.Binder"/>
      <param name="key" type="com.google.inject.Key"/>
      <doc>
      <![CDATA[Returns a new multibinder that collects instances of the key's type in a {@link Set} that is
 itself bound with the annotation (if any) of the key.

 @since 4.0]]>
      </doc>
    </method>
    <method name="newSetBinder" return="com.google.inject.multibindings.Multibinder"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="binder" type="com.google.inject.Binder"/>
      <param name="type" type="java.lang.Class"/>
      <param name="annotationType" type="java.lang.Class"/>
      <doc>
      <![CDATA[Returns a new multibinder that collects instances of {@code type} in a {@link Set} that is
 itself bound with {@code annotationType}.]]>
      </doc>
    </method>
    <method name="permitDuplicates" return="com.google.inject.multibindings.Multibinder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Configures the bound set to silently discard duplicate elements. When multiple equal values are
 bound, the one that gets included is arbitrary. When multiple modules contribute elements to
 the set, this configuration option impacts all of them.

 @return this multibinder
 @since 3.0]]>
      </doc>
    </method>
    <method name="addBinding" return="com.google.inject.binder.LinkedBindingBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a binding builder used to add a new element in the set. Each bound element must have a
 distinct value. Bound providers will be evaluated each time the set is injected.

 <p>It is an error to call this method without also calling one of the {@code to} methods on the
 returned binding builder.

 <p>Scoping elements independently is supported. Use the {@code in} method to specify a binding
 scope.]]>
      </doc>
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="obj" type="java.lang.Object"/>
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[An API to bind multiple values separately, only to later inject them as a complete collection.
 Multibinder is intended for use in your application's module:

 <pre><code>
 public class SnacksModule extends AbstractModule {
   protected void configure() {
     Multibinder&lt;Snack&gt; multibinder
         = Multibinder.newSetBinder(binder(), Snack.class);
     multibinder.addBinding().toInstance(new Twix());
     multibinder.addBinding().toProvider(SnickersProvider.class);
     multibinder.addBinding().to(Skittles.class);
   }
 }</code></pre>

 <p>With this binding, a {@link Set}{@code <Snack>} can now be injected:

 <pre><code>
 class SnackMachine {
   {@literal @}Inject
   public SnackMachine(Set&lt;Snack&gt; snacks) { ... }
 }</code></pre>

 If desired, {@link Collection}{@code <Provider<Snack>>} can also be injected.

 <p>Contributing multibindings from different modules is supported. For example, it is okay for
 both {@code CandyModule} and {@code ChipsModule} to create their own {@code Multibinder<Snack>},
 and to each contribute bindings to the set of snacks. When that set is injected, it will contain
 elements from both modules.

 <p>The set's iteration order is consistent with the binding order. This is convenient when
 multiple elements are contributed by the same module because that module can order its bindings
 appropriately. Avoid relying on the iteration order of elements contributed by different modules,
 since there is no equivalent mechanism to order modules.

 <p>The set is unmodifiable. Elements can only be added to the set by configuring the multibinder.
 Elements can never be removed from the set.

 <p>Elements are resolved at set injection time. If an element is bound to a provider, that
 provider's get method will be called each time the set is injected (unless the binding is also
 scoped).

 <p>Annotations are used to create different sets of the same element type. Each distinct
 annotation gets its own independent collection of elements.

 <p><strong>Elements must be distinct.</strong> If multiple bound elements have the same value,
 set injection will fail.

 <p><strong>Elements must be non-null.</strong> If any set element is null, set injection will
 fail.

 @author jessewilson@google.com (Jesse Wilson)]]>
    </doc>
  </class>
  <!-- end class com.google.inject.multibindings.Multibinder -->
  <!-- start interface com.google.inject.multibindings.MultibinderBinding -->
  <interface name="MultibinderBinding"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="getSetKey" return="com.google.inject.Key"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the key for the set.]]>
      </doc>
    </method>
    <method name="getAlternateSetKeys" return="java.util.Set"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the keys of other bindings that represent this set. This will return an entry for
 {@code Collection<com.google.inject.Provider<V>>}, {@code
 Collection<javax.inject.Provider<V>>}, and {@code Set<? extends V>}.

 @since 4.2.3]]>
      </doc>
    </method>
    <method name="getElementTypeLiteral" return="com.google.inject.TypeLiteral"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the TypeLiteral that describes the type of elements in the set.

 <p>The elements will always match the type Set's generic type. For example, if getSetKey
 returns a key of {@code Set<String>}, then this will always return a {@code
 TypeLiteral<String>}.]]>
      </doc>
    </method>
    <method name="getElements" return="java.util.List"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns all bindings that make up the set. This is only supported on bindings returned from an
 injector. This will throw {@link UnsupportedOperationException} if it is called on an element
 retrieved from {@link Elements#getElements}.

 <p>The elements will always match the type Set's generic type. For example, if getSetKey
 returns a key of {@code Set<String>}, then this will always return a list of type {@code
 List<Binding<String>>}.]]>
      </doc>
    </method>
    <method name="permitsDuplicates" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns true if the multibinder permits duplicates. This is only supported on bindings returned
 from an injector. This will throw {@link UnsupportedOperationException} if it is called on a
 MultibinderBinding retrieved from {@link Elements#getElements}.]]>
      </doc>
    </method>
    <method name="containsElement" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="element" type="com.google.inject.spi.Element"/>
      <doc>
      <![CDATA[Returns true if this Multibinder uses the given Element. This will be true for bindings that
 derive the elements of the set and other bindings that Multibinder uses internally. This will
 work for MultibinderBindings retrieved from an injector and {@link Elements#getElements}.
 Usually this is only necessary if you are working with elements retrieved from modules (without
 an Injector), otherwise {@link #getElements} and {@link #permitsDuplicates} are better options.

 <p>If you need to introspect the details of the set, such as the values or if it permits
 duplicates, it is necessary to pass the elements through an Injector and use {@link
 #getElements()} and {@link #permitsDuplicates()}.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A binding for a Multibinder.

 <p>Although Multibinders may be injected through a variety of generic types ({@code Set<V>},
 {@code Collection<Provider<V>>}, and {@code Set<? extends V>} ), a MultibinderBinding exists only
 on the Binding associated with the {@code Set<V>} key. Injectable types can be discovered using
 {@link #getSetKey} (which will return the {@code Set<V>} key), or {@link #getAlternateSetKeys}
 (which will return the other keys that can inject this data). Other bindings can be validated to
 be derived from this MultibinderBinding using {@link #containsElement(Element)}.

 @param <T> The fully qualified type of the set, including Set. For example: {@code
     MultibinderBinding<Set<Boolean>>}
 @since 3.0
 @author sameb@google.com (Sam Berlin)]]>
    </doc>
  </interface>
  <!-- end interface com.google.inject.multibindings.MultibinderBinding -->
  <!-- start class com.google.inject.multibindings.MultibindingsScanner -->
  <class name="MultibindingsScanner" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="This functionality is installed by default. All references to this can be safely
     removed. This class will be removed in Guice 4.4">
    <method name="asModule" return="com.google.inject.Module"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="This functionality is now installed by default. All references/installations can be
     eliminated.">
      <doc>
      <![CDATA[Returns a module that, when installed, will scan all modules for methods with the annotations
 {@literal @}{@link ProvidesIntoMap}, {@literal @}{@link ProvidesIntoSet}, and
 {@literal @}{@link ProvidesIntoOptional}.

 <p>This is a convenience method, equivalent to doing {@code
 binder().scanModulesForAnnotatedMethods(MultibindingsScanner.scanner())}.

 @deprecated This functionality is now installed by default. All references/installations can be
     eliminated.]]>
      </doc>
    </method>
    <method name="scanner" return="com.google.inject.spi.ModuleAnnotatedMethodScanner"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="This method returns an empty scanner since the preexisting functionality is
     installed by default.">
      <doc>
      <![CDATA[@deprecated This method returns an empty scanner since the preexisting functionality is
     installed by default.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Scans a module for annotations that signal multibindings, mapbindings, and optional bindings.

 @since 4.0
 @deprecated This functionality is installed by default. All references to this can be safely
     removed. This class will be removed in Guice 4.4]]>
    </doc>
  </class>
  <!-- end class com.google.inject.multibindings.MultibindingsScanner -->
  <!-- start interface com.google.inject.multibindings.MultibindingsTargetVisitor -->
  <interface name="MultibindingsTargetVisitor"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.inject.spi.BindingTargetVisitor"/>
    <method name="visit" return="java.lang.Object"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="multibinding" type="com.google.inject.multibindings.MultibinderBinding"/>
      <doc>
      <![CDATA[Visits a binding created through {@link Multibinder}.]]>
      </doc>
    </method>
    <method name="visit" return="java.lang.Object"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="mapbinding" type="com.google.inject.multibindings.MapBinderBinding"/>
      <doc>
      <![CDATA[Visits a binding created through {@link MapBinder}.]]>
      </doc>
    </method>
    <method name="visit" return="java.lang.Object"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="optionalbinding" type="com.google.inject.multibindings.OptionalBinderBinding"/>
      <doc>
      <![CDATA[Visits a binding created through {@link OptionalBinder}.

 @since 4.0]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A visitor for the multibinder extension.

 <p>If your {@link BindingTargetVisitor} implements this interface, bindings created by using
 {@link Multibinder}, {@link MapBinder} or {@link OptionalBinderBinding} will be visited through
 this interface.

 @since 3.0
 @author sameb@google.com (Sam Berlin)]]>
    </doc>
  </interface>
  <!-- end interface com.google.inject.multibindings.MultibindingsTargetVisitor -->
  <!-- start class com.google.inject.multibindings.OptionalBinder -->
  <class name="OptionalBinder" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="newOptionalBinder" return="com.google.inject.multibindings.OptionalBinder"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="binder" type="com.google.inject.Binder"/>
      <param name="type" type="java.lang.Class"/>
    </method>
    <method name="newOptionalBinder" return="com.google.inject.multibindings.OptionalBinder"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="binder" type="com.google.inject.Binder"/>
      <param name="type" type="com.google.inject.TypeLiteral"/>
    </method>
    <method name="newOptionalBinder" return="com.google.inject.multibindings.OptionalBinder"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="binder" type="com.google.inject.Binder"/>
      <param name="type" type="com.google.inject.Key"/>
    </method>
    <method name="setDefault" return="com.google.inject.binder.LinkedBindingBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a binding builder used to set the default value that will be injected. The binding set
 by this method will be ignored if {@link #setBinding} is called.

 <p>It is an error to call this method without also calling one of the {@code to} methods on the
 returned binding builder.]]>
      </doc>
    </method>
    <method name="setBinding" return="com.google.inject.binder.LinkedBindingBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a binding builder used to set the actual value that will be injected. This overrides
 any binding set by {@link #setDefault}.

 <p>It is an error to call this method without also calling one of the {@code to} methods on the
 returned binding builder.]]>
      </doc>
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="obj" type="java.lang.Object"/>
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[An API to bind optional values, optionally with a default value. OptionalBinder fulfills two
 roles:

 <ol>
   <li>It allows a framework to define an injection point that may or may not be bound by users.
   <li>It allows a framework to supply a default value that can be changed by users.
 </ol>

 <p>When an OptionalBinder is added, it will always supply the bindings: {@code Optional<T>} and
 {@code Optional<Provider<T>>}. Both {@link java.util.Optional java.util.Optional} and {@link
 com.google.common.base.Optional com.google.common.base.Optional} are bound for compatibility. If
 {@link #setBinding} or {@link #setDefault} are called, it will also bind {@code T}.

 <p>{@code setDefault} is intended for use by frameworks that need a default value. User code can
 call {@code setBinding} to override the default. <b>Warning: Even if setBinding is called, the
 default binding will still exist in the object graph. If it is a singleton, it will be
 instantiated in {@code Stage.PRODUCTION}.</b>

 <p>If setDefault or setBinding are linked to Providers, the Provider may return {@code null}. If
 it does, {@code Optional<T>} will be bound to an absent Optional. Binding setBinding to a
 Provider that returns null will not cause OptionalBinder to fall back to the setDefault binding.

 <p>If neither setDefault nor setBinding are called, it will try to link to a user-supplied
 binding of the same type. If no binding exists, the optionals will be absent. Otherwise, if a
 user-supplied binding of that type exists, or if setBinding or setDefault are called, the
 optionals will return present if they are bound to a non-null value.

 <p>Values are resolved at injection time. If a value is bound to a provider, that provider's get
 method will be called each time the optional is injected (unless the binding is also scoped, or
 an optional of provider is injected).

 <p>Annotations are used to create different optionals of the same key/value type. Each distinct
 annotation gets its own independent binding.

 <pre><code>
 public class FrameworkModule extends AbstractModule {
   protected void configure() {
     OptionalBinder.newOptionalBinder(binder(), Renamer.class);
   }
 }</code></pre>

 <p>With this module, an {@code Optional<Renamer>} can now be injected. With no other bindings,
 the optional will be absent. Users can specify bindings in one of two ways:

 <p>Option 1:

 <pre><code>
 public class UserRenamerModule extends AbstractModule {
   protected void configure() {
     bind(Renamer.class).to(ReplacingRenamer.class);
   }
 }</code></pre>

 <p>or Option 2:

 <pre><code>
 public class UserRenamerModule extends AbstractModule {
   protected void configure() {
     OptionalBinder.newOptionalBinder(binder(), Renamer.class)
         .setBinding().to(ReplacingRenamer.class);
   }
 }</code></pre>

 With both options, the {@code Optional<Renamer>} will be present and supply the ReplacingRenamer.

 <p>Default values can be supplied using:

 <pre><code>
 public class FrameworkModule extends AbstractModule {
   protected void configure() {
     OptionalBinder.newOptionalBinder(binder(), Key.get(String.class, LookupUrl.class))
         .setDefault().toInstance(DEFAULT_LOOKUP_URL);
   }
 }</code></pre>

 With the above module, code can inject an {@code @LookupUrl String} and it will supply the
 DEFAULT_LOOKUP_URL. A user can change this value by binding

 <pre><code>
 public class UserLookupModule extends AbstractModule {
   protected void configure() {
     OptionalBinder.newOptionalBinder(binder(), Key.get(String.class, LookupUrl.class))
         .setBinding().toInstance(CUSTOM_LOOKUP_URL);
   }
 }</code></pre>

 ... which will override the default value.

 <p>If one module uses setDefault the only way to override the default is to use setBinding. It is
 an error for a user to specify the binding without using OptionalBinder if setDefault or
 setBinding are called. For example,

 <pre><code>
 public class FrameworkModule extends AbstractModule {
   protected void configure() {
     OptionalBinder.newOptionalBinder(binder(), Key.get(String.class, LookupUrl.class))
         .setDefault().toInstance(DEFAULT_LOOKUP_URL);
   }
 }
 public class UserLookupModule extends AbstractModule {
   protected void configure() {
     bind(Key.get(String.class, LookupUrl.class)).toInstance(CUSTOM_LOOKUP_URL);
   }
 }</code></pre>

 ... would generate an error, because both the framework and the user are trying to bind
 {@code @LookupUrl String}.

 @author sameb@google.com (Sam Berlin)
 @since 4.0]]>
    </doc>
  </class>
  <!-- end class com.google.inject.multibindings.OptionalBinder -->
  <!-- start interface com.google.inject.multibindings.OptionalBinderBinding -->
  <interface name="OptionalBinderBinding"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="getKey" return="com.google.inject.Key"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the {@link Key} for this binding.]]>
      </doc>
    </method>
    <method name="getAlternateKeys" return="java.util.Set"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the keys of other bindings that represent this OptionalBinder. This will return an
 entry for {@code Optional<com.google.inject.Provider<V>>} and {@code
 Optional<javax.inject.Provider<V>>}.

 @since 4.2.3]]>
      </doc>
    </method>
    <method name="getDefaultBinding" return="com.google.inject.Binding"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the default binding (set by {@link OptionalBinder#setDefault}) if one exists or null if
 no default binding is set. This will throw {@link UnsupportedOperationException} if it is
 called on an element retrieved from {@link Elements#getElements}.

 <p>The Binding's type will always match the type Optional's generic type. For example, if
 getKey returns a key of {@code Optional<String>}, then this will always return a {@code
 Binding<String>}.]]>
      </doc>
    </method>
    <method name="getActualBinding" return="com.google.inject.Binding"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the actual binding (set by {@link OptionalBinder#setBinding}) or null if not set. This
 will throw {@link UnsupportedOperationException} if it is called on an element retrieved from
 {@link Elements#getElements}.

 <p>The Binding's type will always match the type Optional's generic type. For example, if
 getKey returns a key of {@code Optional<String>}, then this will always return a {@code
 Binding<String>}.]]>
      </doc>
    </method>
    <method name="containsElement" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="element" type="com.google.inject.spi.Element"/>
      <doc>
      <![CDATA[Returns true if this OptionalBinder contains the given Element in order to build the optional
 binding or uses the given Element in order to support building and injecting its data. This
 will work for OptionalBinderBinding retrieved from an injector and {@link
 Elements#getElements}. Usually this is only necessary if you are working with elements
 retrieved from modules (without an Injector), otherwise {@link #getDefaultBinding} and {@link
 #getActualBinding} are better options.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A binding for a OptionalBinder.

 <p>Although OptionalBinders may be injected through a variety of types {@code V}, {@code
 Optional<V>}, {@code Optional<Provider<V>>}, etc..), an OptionalBinderBinding exists only on the
 Binding associated with the {@code Optional<V>} key. Injectable types can be discovered using
 {@link #getKey} (which will return the {@code Optional<V>} key), or{@link #getAlternateKeys}
 (which will return the other keys that can inject this data). Other bindings can be validated to
 be derived from this OptionalBinderBinding using {@link #containsElement}.

 @param <T> The fully qualified type of the optional binding, including Optional. For example:
     {@code Optional<String>}.
 @since 4.0
 @author sameb@google.com (Sam Berlin)]]>
    </doc>
  </interface>
  <!-- end interface com.google.inject.multibindings.OptionalBinderBinding -->
  <!-- start interface com.google.inject.multibindings.ProvidesIntoMap -->
  <interface name="ProvidesIntoMap"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.lang.annotation.Annotation"/>
    <doc>
    <![CDATA[Annotates methods of a {@link Module} to add items to a {@link MapBinder}. The method's return
 type, binding annotation and additional key annotation determines what Map this will contribute
 to. For example,

 <pre>
 {@literal @}ProvidesIntoMap
 {@literal @}StringMapKey("Foo")
 {@literal @}Named("plugins")
 Plugin provideFooUrl(FooManager fm) { return fm.getPlugin(); }

 {@literal @}ProvidesIntoMap
 {@literal @}StringMapKey("Bar")
 {@literal @}Named("plugins")
 Plugin provideBarUrl(BarManager bm) { return bm.getPlugin(); }
 </pre>

 will add two items to the {@code @Named("plugins") Map<String, Plugin>} map. The key 'Foo' will
 map to the provideFooUrl method, and the key 'Bar' will map to the provideBarUrl method. The
 values are bound as providers and will be evaluated at injection time.

 <p>Because the key is specified as an annotation, only Strings, Classes, enums, primitive types
 and annotation instances are supported as keys.

 @author sameb@google.com (Sam Berlin)
 @since 4.0]]>
    </doc>
  </interface>
  <!-- end interface com.google.inject.multibindings.ProvidesIntoMap -->
  <!-- start interface com.google.inject.multibindings.ProvidesIntoOptional -->
  <interface name="ProvidesIntoOptional"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.lang.annotation.Annotation"/>
    <method name="value" return="com.google.inject.multibindings.ProvidesIntoOptional.Type"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Specifies if the binding is for the actual or default value.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Annotates methods of a {@link Module} to add items to a {@link Multibinder}. The method's return
 type and binding annotation determines what Optional this will contribute to. For example,

 <pre>
 {@literal @}ProvidesIntoOptional(DEFAULT)
 {@literal @}Named("url")
 String provideFooUrl(FooManager fm) { returm fm.getUrl(); }

 {@literal @}ProvidesIntoOptional(ACTUAL)
 {@literal @}Named("url")
 String provideBarUrl(BarManager bm) { return bm.getUrl(); }
 </pre>

 will set the default value of {@code @Named("url") Optional<String>} to foo's URL, and then
 override it to bar's URL.

 @author sameb@google.com (Sam Berlin)
 @since 4.0]]>
    </doc>
  </interface>
  <!-- end interface com.google.inject.multibindings.ProvidesIntoOptional -->
  <!-- start class com.google.inject.multibindings.ProvidesIntoOptional.Type -->
  <class name="ProvidesIntoOptional.Type" extends="java.lang.Enum"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="values" return="com.google.inject.multibindings.ProvidesIntoOptional.Type[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="com.google.inject.multibindings.ProvidesIntoOptional.Type"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <field name="ACTUAL" type="com.google.inject.multibindings.ProvidesIntoOptional.Type"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Corresponds to {@link OptionalBinder#setBinding}.]]>
      </doc>
    </field>
    <field name="DEFAULT" type="com.google.inject.multibindings.ProvidesIntoOptional.Type"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Corresponds to {@link OptionalBinder#setDefault}.]]>
      </doc>
    </field>
    <doc>
    <![CDATA[@since 4.0]]>
    </doc>
  </class>
  <!-- end class com.google.inject.multibindings.ProvidesIntoOptional.Type -->
  <!-- start interface com.google.inject.multibindings.ProvidesIntoSet -->
  <interface name="ProvidesIntoSet"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.lang.annotation.Annotation"/>
    <doc>
    <![CDATA[Annotates methods of a {@link Module} to add items to a {@link Multibinder}. The method's return
 type and binding annotation determines what Set this will contribute to. For example,

 <pre>
 {@literal @}ProvidesIntoSet
 {@literal @}Named("urls")
 String provideFooUrl(FooManager fm) { returm fm.getUrl(); }

 {@literal @}ProvidesIntoSet
 {@literal @}Named("urls")
 String provideBarUrl(BarManager bm) { return bm.getUrl(); }
 </pre>

 will add two items to the {@code @Named("urls") Set<String>} set. The items are bound as
 providers and will be evaluated at injection time.

 @author sameb@google.com (Sam Berlin)
 @since 4.0]]>
    </doc>
  </interface>
  <!-- end interface com.google.inject.multibindings.ProvidesIntoSet -->
  <!-- start interface com.google.inject.multibindings.StringMapKey -->
  <interface name="StringMapKey"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.lang.annotation.Annotation"/>
    <method name="value" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Allows {@literal @}{@link ProvidesIntoMap} to specify a string map key.

 @since 4.0]]>
    </doc>
  </interface>
  <!-- end interface com.google.inject.multibindings.StringMapKey -->
</package>
<package name="com.google.inject.matcher">
  <!-- start class com.google.inject.matcher.AbstractMatcher -->
  <class name="AbstractMatcher" extends="java.lang.Object"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.inject.matcher.Matcher"/>
    <constructor name="AbstractMatcher"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="and" return="com.google.inject.matcher.Matcher"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="other" type="com.google.inject.matcher.Matcher"/>
    </method>
    <method name="or" return="com.google.inject.matcher.Matcher"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="other" type="com.google.inject.matcher.Matcher"/>
    </method>
    <doc>
    <![CDATA[Implements {@code and()} and {@code or()}.

 @author crazybob@google.com (Bob Lee)]]>
    </doc>
  </class>
  <!-- end class com.google.inject.matcher.AbstractMatcher -->
  <!-- start interface com.google.inject.matcher.Matcher -->
  <interface name="Matcher"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="matches" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="t" type="java.lang.Object"/>
      <doc>
      <![CDATA[Returns {@code true} if this matches {@code t}, {@code false} otherwise.]]>
      </doc>
    </method>
    <method name="and" return="com.google.inject.matcher.Matcher"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="other" type="com.google.inject.matcher.Matcher"/>
      <doc>
      <![CDATA[Returns a new matcher which returns {@code true} if both this and the given matcher return
 {@code true}.]]>
      </doc>
    </method>
    <method name="or" return="com.google.inject.matcher.Matcher"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="other" type="com.google.inject.matcher.Matcher"/>
      <doc>
      <![CDATA[Returns a new matcher which returns {@code true} if either this or the given matcher return
 {@code true}.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Returns {@code true} or {@code false} for a given input.

 @author crazybob@google.com (Bob Lee)]]>
    </doc>
  </interface>
  <!-- end interface com.google.inject.matcher.Matcher -->
  <!-- start class com.google.inject.matcher.Matchers -->
  <class name="Matchers" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="any" return="com.google.inject.matcher.Matcher"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a matcher which matches any input.]]>
      </doc>
    </method>
    <method name="not" return="com.google.inject.matcher.Matcher"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="p" type="com.google.inject.matcher.Matcher"/>
      <doc>
      <![CDATA[Inverts the given matcher.]]>
      </doc>
    </method>
    <method name="annotatedWith" return="com.google.inject.matcher.Matcher"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="annotationType" type="java.lang.Class"/>
      <doc>
      <![CDATA[Returns a matcher which matches elements (methods, classes, etc.) with a given annotation.]]>
      </doc>
    </method>
    <method name="annotatedWith" return="com.google.inject.matcher.Matcher"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="annotation" type="java.lang.annotation.Annotation"/>
      <doc>
      <![CDATA[Returns a matcher which matches elements (methods, classes, etc.) with a given annotation.]]>
      </doc>
    </method>
    <method name="subclassesOf" return="com.google.inject.matcher.Matcher"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="superclass" type="java.lang.Class"/>
      <doc>
      <![CDATA[Returns a matcher which matches subclasses of the given type (as well as the given type).]]>
      </doc>
    </method>
    <method name="only" return="com.google.inject.matcher.Matcher"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="java.lang.Object"/>
      <doc>
      <![CDATA[Returns a matcher which matches objects equal to the given object.]]>
      </doc>
    </method>
    <method name="identicalTo" return="com.google.inject.matcher.Matcher"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="java.lang.Object"/>
      <doc>
      <![CDATA[Returns a matcher which matches only the given object.]]>
      </doc>
    </method>
    <method name="inPackage" return="com.google.inject.matcher.Matcher"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="targetPackage" type="java.lang.Package"/>
      <doc>
      <![CDATA[Returns a matcher which matches classes in the given package. Packages are specific to their
 classloader, so classes with the same package name may not have the same package at runtime.]]>
      </doc>
    </method>
    <method name="inSubpackage" return="com.google.inject.matcher.Matcher"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="targetPackageName" type="java.lang.String"/>
      <doc>
      <![CDATA[Returns a matcher which matches classes in the given package and its subpackages. Unlike {@link
 #inPackage(Package) inPackage()}, this matches classes from any classloader.

 @since 2.0]]>
      </doc>
    </method>
    <method name="returns" return="com.google.inject.matcher.Matcher"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="returnType" type="com.google.inject.matcher.Matcher"/>
      <doc>
      <![CDATA[Returns a matcher which matches methods with matching return types.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Matcher implementations. Supports matching classes and methods.

 @author crazybob@google.com (Bob Lee)]]>
    </doc>
  </class>
  <!-- end class com.google.inject.matcher.Matchers -->
</package>
<package name="com.google.inject.internal">
  <!-- start class com.google.inject.internal.AbstractBindingBuilder -->
  <class name="AbstractBindingBuilder" extends="java.lang.Object"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="AbstractBindingBuilder" type="com.google.inject.Binder, java.util.List, java.lang.Object, com.google.inject.Key"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getBinding" return="com.google.inject.internal.BindingImpl"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </method>
    <method name="setBinding" return="com.google.inject.internal.BindingImpl"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="binding" type="com.google.inject.internal.BindingImpl"/>
    </method>
    <method name="annotatedWithInternal" return="com.google.inject.internal.BindingImpl"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="annotationType" type="java.lang.Class"/>
      <doc>
      <![CDATA[Sets the binding to a copy with the specified annotation on the bound key]]>
      </doc>
    </method>
    <method name="annotatedWithInternal" return="com.google.inject.internal.BindingImpl"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="annotation" type="java.lang.annotation.Annotation"/>
      <doc>
      <![CDATA[Sets the binding to a copy with the specified annotation on the bound key]]>
      </doc>
    </method>
    <method name="in"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="scopeAnnotation" type="java.lang.Class"/>
    </method>
    <method name="in"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="scope" type="com.google.inject.Scope"/>
    </method>
    <method name="asEagerSingleton"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="keyTypeIsSet" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </method>
    <method name="checkNotTargetted"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </method>
    <method name="checkNotAnnotated"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </method>
    <method name="checkNotScoped"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </method>
    <field name="IMPLEMENTATION_ALREADY_SET" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="SINGLE_INSTANCE_AND_SCOPE" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="SCOPE_ALREADY_SET" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="BINDING_TO_NULL" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="CONSTANT_VALUE_ALREADY_SET" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="ANNOTATION_ALREADY_SPECIFIED" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="NULL_KEY" type="com.google.inject.Key"
      transient="false" volatile="false"
      static="true" final="true" visibility="protected"
      deprecated="not deprecated">
    </field>
    <field name="binder" type="com.google.inject.Binder"
      transient="false" volatile="false"
      static="false" final="true" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The binder that the new binding will be added to.]]>
      </doc>
    </field>
    <field name="elements" type="java.util.List"
      transient="false" volatile="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The list of elements stored inside the {@link #binder}. The new binding is added to this list.]]>
      </doc>
    </field>
    <field name="position" type="int"
      transient="false" volatile="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The index of the new binding in {@link #elements}. This is used by subclasses of
 AbstractBindingBuilder to repeatedly replace the binding object in {@link #elements} as more
 Guice EDSL methods are called to update the binding.]]>
      </doc>
    </field>
    <doc>
    <![CDATA[Base class used to create a new binding with the Guice EDSL described in {@link Binder}.
 Constructing an AbstractBindingBuilder will create a new binding and add it into the {@link
 Binder}.

 @author jessewilson@google.com (Jesse Wilson)]]>
    </doc>
  </class>
  <!-- end class com.google.inject.internal.AbstractBindingBuilder -->
  <!-- start class com.google.inject.internal.Annotations -->
  <class name="Annotations" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="Annotations"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="isMarker" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="annotationType" type="java.lang.Class"/>
      <doc>
      <![CDATA[Returns {@code true} if the given annotation type has no attributes.]]>
      </doc>
    </method>
    <method name="isAllDefaultMethods" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="annotationType" type="java.lang.Class"/>
    </method>
    <method name="generateAnnotation" return="java.lang.annotation.Annotation"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="annotationType" type="java.lang.Class"/>
      <doc>
      <![CDATA[Generates an Annotation for the annotation class. Requires that the annotation is all
 optionals.]]>
      </doc>
    </method>
    <method name="isRetainedAtRuntime" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="annotationType" type="java.lang.Class"/>
      <doc>
      <![CDATA[Returns true if the given annotation is retained at runtime.]]>
      </doc>
    </method>
    <method name="findScopeAnnotation" return="java.lang.Class"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="errors" type="com.google.inject.internal.Errors"/>
      <param name="implementation" type="java.lang.Class"/>
      <doc>
      <![CDATA[Returns the scope annotation on {@code type}, or null if none is specified.]]>
      </doc>
    </method>
    <method name="findScopeAnnotation" return="java.lang.Class"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="errors" type="com.google.inject.internal.Errors"/>
      <param name="annotations" type="java.lang.annotation.Annotation[]"/>
      <doc>
      <![CDATA[Returns the scoping annotation, or null if there isn't one.]]>
      </doc>
    </method>
    <method name="memberValueString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="java.lang.String"/>
      <doc>
      <![CDATA[Returns {@code value}, quoted if annotation implementations quote their member values. In Java
 9, annotations quote their string members.]]>
      </doc>
    </method>
    <method name="memberValueString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="memberName" type="java.lang.String"/>
      <param name="value" type="java.lang.Object"/>
      <doc>
      <![CDATA[Returns string representation of the annotation memeber.

 <p>The value of the member is prefixed with `memberName=` unless the runtime omits the member
 name. The value of the member is quoted if annotation implementations quote their member values
 and the value type is String.

 <p>In Java 9, annotations quote their string members and in Java 15, the member name is
 omitted.]]>
      </doc>
    </method>
    <method name="annotationInstanceClassString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="ann" type="java.lang.Class"/>
      <param name="includePackage" type="boolean"/>
      <doc>
      <![CDATA[Returns the string representation of the annotation class as it would appear in an annotation
 instance's toString() method.

 <p>In earlier JDKs, the string representation mirrored Class.getName() (which uses $ to
 separate outer and inner classes), but newer JDKs use . as the separator).]]>
      </doc>
    </method>
    <method name="isScopeAnnotation" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="annotationType" type="java.lang.Class"/>
    </method>
    <method name="checkForMisplacedScopeAnnotations"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="java.lang.Class"/>
      <param name="source" type="java.lang.Object"/>
      <param name="errors" type="com.google.inject.internal.Errors"/>
      <doc>
      <![CDATA[Adds an error if there is a misplaced annotations on {@code type}. Scoping annotations are not
 allowed on abstract classes or interfaces.]]>
      </doc>
    </method>
    <method name="getKey" return="com.google.inject.Key"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="com.google.inject.TypeLiteral"/>
      <param name="member" type="java.lang.reflect.Member"/>
      <param name="annotations" type="java.lang.annotation.Annotation[]"/>
      <param name="errors" type="com.google.inject.internal.Errors"/>
      <exception name="ErrorsException" type="com.google.inject.internal.ErrorsException"/>
      <doc>
      <![CDATA[Gets a key for the given type, member and annotations.]]>
      </doc>
    </method>
    <method name="findBindingAnnotation" return="java.lang.annotation.Annotation"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="errors" type="com.google.inject.internal.Errors"/>
      <param name="member" type="java.lang.reflect.Member"/>
      <param name="annotations" type="java.lang.annotation.Annotation[]"/>
      <doc>
      <![CDATA[Returns the binding annotation on {@code member}, or null if there isn't one.]]>
      </doc>
    </method>
    <method name="isBindingAnnotation" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="annotationType" type="java.lang.Class"/>
      <doc>
      <![CDATA[Returns true if annotations of the specified type are binding annotations.]]>
      </doc>
    </method>
    <method name="canonicalizeIfNamed" return="java.lang.annotation.Annotation"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="annotation" type="java.lang.annotation.Annotation"/>
      <doc>
      <![CDATA[If the annotation is an instance of {@code javax.inject.Named}, canonicalizes to
 com.google.guice.name.Named. Returns the given annotation otherwise.]]>
      </doc>
    </method>
    <method name="canonicalizeIfNamed" return="java.lang.Class"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="annotationType" type="java.lang.Class"/>
      <doc>
      <![CDATA[If the annotation is the class {@code javax.inject.Named}, canonicalizes to
 com.google.guice.name.Named. Returns the given annotation class otherwise.]]>
      </doc>
    </method>
    <method name="nameOf" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="com.google.inject.Key"/>
      <doc>
      <![CDATA[Returns the name the binding should use. This is based on the annotation. If the annotation has
 an instance and is not a marker annotation, we ask the annotation for its toString. If it was a
 marker annotation or just an annotation type, we use the annotation's name. Otherwise, the name
 is the empty string.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Annotation utilities.

 @author crazybob@google.com (Bob Lee)]]>
    </doc>
  </class>
  <!-- end class com.google.inject.internal.Annotations -->
  <!-- start class com.google.inject.internal.BindingBuilder -->
  <class name="BindingBuilder" extends="com.google.inject.internal.AbstractBindingBuilder"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.inject.binder.AnnotatedBindingBuilder"/>
    <constructor name="BindingBuilder" type="com.google.inject.Binder, java.util.List, java.lang.Object, com.google.inject.Key"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="annotatedWith" return="com.google.inject.internal.BindingBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="annotationType" type="java.lang.Class"/>
    </method>
    <method name="annotatedWith" return="com.google.inject.internal.BindingBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="annotation" type="java.lang.annotation.Annotation"/>
    </method>
    <method name="to" return="com.google.inject.internal.BindingBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="implementation" type="java.lang.Class"/>
    </method>
    <method name="to" return="com.google.inject.internal.BindingBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="implementation" type="com.google.inject.TypeLiteral"/>
    </method>
    <method name="to" return="com.google.inject.internal.BindingBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="linkedKey" type="com.google.inject.Key"/>
    </method>
    <method name="toInstance"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="instance" type="java.lang.Object"/>
    </method>
    <method name="toProvider" return="com.google.inject.internal.BindingBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="provider" type="com.google.inject.Provider"/>
    </method>
    <method name="toProvider" return="com.google.inject.internal.BindingBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="provider" type="javax.inject.Provider"/>
    </method>
    <method name="toProvider" return="com.google.inject.internal.BindingBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="providerType" type="java.lang.Class"/>
    </method>
    <method name="toProvider" return="com.google.inject.internal.BindingBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="providerType" type="com.google.inject.TypeLiteral"/>
    </method>
    <method name="toProvider" return="com.google.inject.internal.BindingBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="providerKey" type="com.google.inject.Key"/>
    </method>
    <method name="toConstructor" return="com.google.inject.binder.ScopedBindingBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="constructor" type="java.lang.reflect.Constructor"/>
    </method>
    <method name="toConstructor" return="com.google.inject.binder.ScopedBindingBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="constructor" type="java.lang.reflect.Constructor"/>
      <param name="type" type="com.google.inject.TypeLiteral"/>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Bind a non-constant key.

 @author jessewilson@google.com (Jesse Wilson)]]>
    </doc>
  </class>
  <!-- end class com.google.inject.internal.BindingBuilder -->
  <!-- start class com.google.inject.internal.BindingImpl -->
  <class name="BindingImpl" extends="java.lang.Object"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.inject.Binding"/>
    <method name="getKey" return="com.google.inject.Key"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getSource" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getProvider" return="com.google.inject.Provider"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getInternalFactory" return="com.google.inject.internal.InternalFactory"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getScoping" return="com.google.inject.internal.Scoping"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="isConstant" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Is this a constant binding? This returns true for constant bindings as well as toInstance()
 bindings.]]>
      </doc>
    </method>
    <method name="acceptVisitor" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="visitor" type="com.google.inject.spi.ElementVisitor"/>
    </method>
    <method name="acceptScopingVisitor" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="visitor" type="com.google.inject.spi.BindingScopingVisitor"/>
    </method>
    <method name="withScoping" return="com.google.inject.internal.BindingImpl"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="scoping" type="com.google.inject.internal.Scoping"/>
    </method>
    <method name="withKey" return="com.google.inject.internal.BindingImpl"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="key" type="com.google.inject.Key"/>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getInjector" return="com.google.inject.internal.InjectorImpl"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[@author crazybob@google.com (Bob Lee)]]>
    </doc>
  </class>
  <!-- end class com.google.inject.internal.BindingImpl -->
  <!-- start class com.google.inject.internal.BytecodeGen -->
  <class name="BytecodeGen" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="BytecodeGen"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="isCircularProxy" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="object" type="java.lang.Object"/>
      <doc>
      <![CDATA[Returns true if the given object is a circular proxy.]]>
      </doc>
    </method>
    <field name="ENHANCER_BY_GUICE_MARKER" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="FASTCLASS_BY_GUICE_MARKER" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[Utility methods for circular proxies, faster reflection, and method interception.

 <p>This class makes heavy use of {@link Function} and {@link BiFunction} types when interacting
 with generated fast-classes and enhanced proxies. This is a deliberate design decision to avoid
 using Guice-specific types in the generated classes. This means generated classes can be defined
 in the same {@link ClassLoader} as their host class without needing access to Guice's own {@link
 ClassLoader}. (In other words it removes any need for bridge {@link ClassLoader}s.)

 @author mcculls@gmail.com (Stuart McCulloch)
 @author jessewilson@google.com (Jesse Wilson)]]>
    </doc>
  </class>
  <!-- end class com.google.inject.internal.BytecodeGen -->
  <!-- start interface com.google.inject.internal.BytecodeGen.EnhancerBuilder -->
  <interface name="BytecodeGen.EnhancerBuilder"    abstract="true"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="getEnhanceableMethods" return="java.lang.reflect.Method[]"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Lists the methods in the host class that can be enhanced.

 <p>This always includes public and protected methods that are neither static nor final.

 <p>Package-private methods can only be enhanced if they're in the same package as the host
 and we can define types in the same class loader with Unsafe. The {@link #finalize} method
 can never be enhanced.]]>
      </doc>
    </method>
    <method name="buildEnhancer" return="java.util.function.Function"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="methodIndices" type="java.util.BitSet"/>
      <doc>
      <![CDATA[Generates an enhancer for the selected subset of methods.

 <p>The enhancer maps constructor and method signatures to invokers, where each invoker is
 represented as a {@link BiFunction} that accepts a context object and an argument array.

 <p>Constructor invokers take an array of {@link InvocationHandler}s as their context object.
 This is stored in the enhanced class before the original host class constructor is called,
 with arguments unpacked from the argument array. The enhanced instance is then returned.

 <p>Method invokers take an enhanced instance as their context object and call the original
 super-method with arguments unpacked from the argument array, ie. provides super-invocation.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Builder of enhanced classes.]]>
    </doc>
  </interface>
  <!-- end interface com.google.inject.internal.BytecodeGen.EnhancerBuilder -->
  <!-- start class com.google.inject.internal.ConstantBindingBuilderImpl -->
  <class name="ConstantBindingBuilderImpl" extends="com.google.inject.internal.AbstractBindingBuilder"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.inject.binder.AnnotatedConstantBindingBuilder"/>
    <implements name="com.google.inject.binder.ConstantBindingBuilder"/>
    <constructor name="ConstantBindingBuilderImpl" type="com.google.inject.Binder, java.util.List, java.lang.Object"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="annotatedWith" return="com.google.inject.binder.ConstantBindingBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="annotationType" type="java.lang.Class"/>
    </method>
    <method name="annotatedWith" return="com.google.inject.binder.ConstantBindingBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="annotation" type="java.lang.annotation.Annotation"/>
    </method>
    <method name="to"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="java.lang.String"/>
    </method>
    <method name="to"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="int"/>
    </method>
    <method name="to"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="long"/>
    </method>
    <method name="to"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="boolean"/>
    </method>
    <method name="to"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="double"/>
    </method>
    <method name="to"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="float"/>
    </method>
    <method name="to"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="short"/>
    </method>
    <method name="to"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="char"/>
    </method>
    <method name="to"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="byte"/>
    </method>
    <method name="to"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="java.lang.Class"/>
    </method>
    <method name="to"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="java.lang.Enum"/>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Bind a constant.

 @author jessewilson@google.com (Jesse Wilson)]]>
    </doc>
  </class>
  <!-- end class com.google.inject.internal.ConstantBindingBuilderImpl -->
  <!-- start class com.google.inject.internal.DeclaredMembers -->
  <class name="DeclaredMembers" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="getDeclaredFields" return="java.lang.reflect.Field[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="java.lang.Class"/>
    </method>
    <method name="getDeclaredMethods" return="java.lang.reflect.Method[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="java.lang.Class"/>
    </method>
    <doc>
    <![CDATA[Utility class for retrieving declared fields or methods in a particular order, because the JVM
 doesn't guarantee ordering for listing declared methods. We don't externally guarantee an
 ordering, but having a consistent ordering allows deterministic behavior and simpler tests.

 <p>For class ordering, within a single classloader there can only be one class with a given name,
 so we just compare the names.

 <p>For method ordering, within a single class it is sufficient to compare the non-generic method
 signature which consists of the name, return type and parameter types.]]>
    </doc>
  </class>
  <!-- end class com.google.inject.internal.DeclaredMembers -->
  <!-- start class com.google.inject.internal.ErrorId -->
  <class name="ErrorId" extends="java.lang.Enum"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="values" return="com.google.inject.internal.ErrorId[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="com.google.inject.internal.ErrorId"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <field name="AMBIGUOUS_TYPE_CONVERSION" type="com.google.inject.internal.ErrorId"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="AOP_DISABLED" type="com.google.inject.internal.ErrorId"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="AT_INJECT_REQUIRED" type="com.google.inject.internal.ErrorId"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="AT_TARGET_IS_MISSING_PARAMETER" type="com.google.inject.internal.ErrorId"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="BINDING_ALREADY_SET" type="com.google.inject.internal.ErrorId"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="BINDING_TO_GUICE_TYPE" type="com.google.inject.internal.ErrorId"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="BINDING_TO_PROVIDER" type="com.google.inject.internal.ErrorId"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="CAN_NOT_PROXY_CLASS" type="com.google.inject.internal.ErrorId"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="CHILD_BINDING_ALREADY_SET" type="com.google.inject.internal.ErrorId"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="CIRCULAR_PROXY_DISABLED" type="com.google.inject.internal.ErrorId"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="CONSTRUCTOR_NOT_DEFINED_BY_TYPE" type="com.google.inject.internal.ErrorId"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="CONVERSION_TYPE_ERROR" type="com.google.inject.internal.ErrorId"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="CONVERTER_RETURNED_NULL" type="com.google.inject.internal.ErrorId"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="DUPLICATE_BINDING_ANNOTATIONS" type="com.google.inject.internal.ErrorId"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="DUPLICATE_ELEMENT" type="com.google.inject.internal.ErrorId"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="DUPLICATE_MAP_KEY" type="com.google.inject.internal.ErrorId"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="DUPLICATE_SCOPES" type="com.google.inject.internal.ErrorId"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="DUPLICATE_SCOPE_ANNOTATIONS" type="com.google.inject.internal.ErrorId"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="ERROR_ENHANCING_CLASS" type="com.google.inject.internal.ErrorId"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="ERROR_INJECTING_CONSTRUCTOR" type="com.google.inject.internal.ErrorId"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="ERROR_INJECTING_METHOD" type="com.google.inject.internal.ErrorId"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="ERROR_IN_CUSTOM_PROVIDER" type="com.google.inject.internal.ErrorId"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="ERROR_IN_USER_CODE" type="com.google.inject.internal.ErrorId"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="ERROR_IN_USER_INJECTOR" type="com.google.inject.internal.ErrorId"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="ERROR_NOTIFYING_TYPE_LISTENER" type="com.google.inject.internal.ErrorId"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="EXPOSED_BUT_NOT_BOUND" type="com.google.inject.internal.ErrorId"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="INJECT_ABSTRACT_METHOD" type="com.google.inject.internal.ErrorId"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="INJECT_FINAL_FIELD" type="com.google.inject.internal.ErrorId"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="INJECT_INNER_CLASS" type="com.google.inject.internal.ErrorId"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="INJECT_LOCAL_CLASS" type="com.google.inject.internal.ErrorId"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="INJECT_METHOD_WITH_TYPE_PARAMETER" type="com.google.inject.internal.ErrorId"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="INJECT_RAW_MEMBERS_INJECTOR" type="com.google.inject.internal.ErrorId"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="INJECT_RAW_PROVIDER" type="com.google.inject.internal.ErrorId"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="INJECT_RAW_TYPE_LITERAL" type="com.google.inject.internal.ErrorId"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="JIT_BINDING_ALREADY_SET" type="com.google.inject.internal.ErrorId"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="JIT_DISABLED" type="com.google.inject.internal.ErrorId"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="JIT_DISABLED_IN_PARENT" type="com.google.inject.internal.ErrorId"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="KEY_NOT_FULLY_SPECIFIED" type="com.google.inject.internal.ErrorId"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="MISPLACED_BINDING_ANNOTATION" type="com.google.inject.internal.ErrorId"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="MISSING_CONSTANT_VALUES" type="com.google.inject.internal.ErrorId"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="MISSING_CONSTRUCTOR" type="com.google.inject.internal.ErrorId"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="MISSING_IMPLEMENTATION" type="com.google.inject.internal.ErrorId"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="MISSING_RUNTIME_RETENTION" type="com.google.inject.internal.ErrorId"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="MISSING_SCOPE_ANNOTATION" type="com.google.inject.internal.ErrorId"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="NOT_A_SUBTYPE" type="com.google.inject.internal.ErrorId"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="NULL_ELEMENT_IN_SET" type="com.google.inject.internal.ErrorId"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="NULL_INJECTED_INTO_NON_NULLABLE" type="com.google.inject.internal.ErrorId"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="NULL_VALUE_IN_MAP" type="com.google.inject.internal.ErrorId"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="OPTIONAL_CONSTRUCTOR" type="com.google.inject.internal.ErrorId"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="RECURSIVE_BINDING" type="com.google.inject.internal.ErrorId"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="RECURSIVE_IMPLEMENTATION_TYPE" type="com.google.inject.internal.ErrorId"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="RECURSIVE_PROVIDER_TYPE" type="com.google.inject.internal.ErrorId"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="SCOPE_ANNOTATION_ON_ABSTRACT_TYPE" type="com.google.inject.internal.ErrorId"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="SCOPE_NOT_FOUND" type="com.google.inject.internal.ErrorId"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="STATIC_INJECTION_ON_INTERFACE" type="com.google.inject.internal.ErrorId"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="SUBTYPE_NOT_PROVIDED" type="com.google.inject.internal.ErrorId"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="TOO_MANY_CONSTRUCTORS" type="com.google.inject.internal.ErrorId"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="VOID_PROVIDER_METHOD" type="com.google.inject.internal.ErrorId"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="OTHER" type="com.google.inject.internal.ErrorId"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[Enum used to identify a specific Guice error.]]>
    </doc>
  </class>
  <!-- end class com.google.inject.internal.ErrorId -->
  <!-- start class com.google.inject.internal.Errors -->
  <class name="Errors" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="java.io.Serializable"/>
    <constructor name="Errors"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="Errors" type="java.lang.Object"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="withSource" return="com.google.inject.internal.Errors"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="source" type="java.lang.Object"/>
      <doc>
      <![CDATA[Returns an instance that uses {@code source} as a reference point for newly added errors.]]>
      </doc>
    </method>
    <method name="aopDisabled" return="com.google.inject.internal.Errors"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="binding" type="com.google.inject.spi.InterceptorBinding"/>
    </method>
    <method name="missingImplementation" return="com.google.inject.internal.Errors"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="com.google.inject.Key"/>
      <doc>
      <![CDATA[We use a fairly generic error message here. The motivation is to share the same message for
 both bind time errors:

 <pre><code>Guice.createInjector(new AbstractModule() {
   public void configure() {
     bind(Runnable.class);
   }
 }</code></pre>

 ...and at provide-time errors:

 <pre><code>Guice.createInjector().getInstance(Runnable.class);</code></pre>

 Otherwise we need to know who's calling when resolving a just-in-time binding, which makes
 things unnecessarily complex.]]>
      </doc>
    </method>
    <method name="jitDisabled" return="com.google.inject.internal.Errors"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="com.google.inject.Key"/>
    </method>
    <method name="jitDisabledInParent" return="com.google.inject.internal.Errors"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="com.google.inject.Key"/>
    </method>
    <method name="atInjectRequired" return="com.google.inject.internal.Errors"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="com.google.inject.TypeLiteral"/>
    </method>
    <method name="converterReturnedNull" return="com.google.inject.internal.Errors"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="stringValue" type="java.lang.String"/>
      <param name="source" type="java.lang.Object"/>
      <param name="type" type="com.google.inject.TypeLiteral"/>
      <param name="typeConverterBinding" type="com.google.inject.spi.TypeConverterBinding"/>
    </method>
    <method name="conversionTypeError" return="com.google.inject.internal.Errors"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="stringValue" type="java.lang.String"/>
      <param name="source" type="java.lang.Object"/>
      <param name="type" type="com.google.inject.TypeLiteral"/>
      <param name="typeConverterBinding" type="com.google.inject.spi.TypeConverterBinding"/>
      <param name="converted" type="java.lang.Object"/>
    </method>
    <method name="conversionError" return="com.google.inject.internal.Errors"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="stringValue" type="java.lang.String"/>
      <param name="source" type="java.lang.Object"/>
      <param name="type" type="com.google.inject.TypeLiteral"/>
      <param name="typeConverterBinding" type="com.google.inject.spi.TypeConverterBinding"/>
      <param name="cause" type="java.lang.RuntimeException"/>
    </method>
    <method name="ambiguousTypeConversion" return="com.google.inject.internal.Errors"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="stringValue" type="java.lang.String"/>
      <param name="source" type="java.lang.Object"/>
      <param name="type" type="com.google.inject.TypeLiteral"/>
      <param name="a" type="com.google.inject.spi.TypeConverterBinding"/>
      <param name="b" type="com.google.inject.spi.TypeConverterBinding"/>
    </method>
    <method name="bindingToProvider" return="com.google.inject.internal.Errors"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="notASubtype" return="com.google.inject.internal.Errors"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="implementationType" type="java.lang.Class"/>
      <param name="type" type="java.lang.Class"/>
    </method>
    <method name="recursiveImplementationType" return="com.google.inject.internal.Errors"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="recursiveProviderType" return="com.google.inject.internal.Errors"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="missingRuntimeRetention" return="com.google.inject.internal.Errors"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="annotation" type="java.lang.Class"/>
    </method>
    <method name="missingScopeAnnotation" return="com.google.inject.internal.Errors"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="annotation" type="java.lang.Class"/>
    </method>
    <method name="optionalConstructor" return="com.google.inject.internal.Errors"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="constructor" type="java.lang.reflect.Constructor"/>
    </method>
    <method name="cannotBindToGuiceType" return="com.google.inject.internal.Errors"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="simpleName" type="java.lang.String"/>
    </method>
    <method name="scopeNotFound" return="com.google.inject.internal.Errors"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="scopeAnnotation" type="java.lang.Class"/>
    </method>
    <method name="scopeAnnotationOnAbstractType" return="com.google.inject.internal.Errors"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="scopeAnnotation" type="java.lang.Class"/>
      <param name="type" type="java.lang.Class"/>
      <param name="source" type="java.lang.Object"/>
    </method>
    <method name="misplacedBindingAnnotation" return="com.google.inject.internal.Errors"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="member" type="java.lang.reflect.Member"/>
      <param name="bindingAnnotation" type="java.lang.annotation.Annotation"/>
    </method>
    <method name="missingConstructor" return="com.google.inject.internal.Errors"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="com.google.inject.TypeLiteral"/>
    </method>
    <method name="tooManyConstructors" return="com.google.inject.internal.Errors"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="implementation" type="java.lang.Class"/>
    </method>
    <method name="constructorNotDefinedByType" return="com.google.inject.internal.Errors"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="constructor" type="java.lang.reflect.Constructor"/>
      <param name="type" type="com.google.inject.TypeLiteral"/>
    </method>
    <method name="duplicateMapKey" return="com.google.inject.internal.Errors"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="mapKey" type="com.google.inject.Key"/>
      <param name="duplicates" type="com.google.common.collect.Multimap"/>
    </method>
    <method name="duplicateScopes" return="com.google.inject.internal.Errors"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="existing" type="com.google.inject.spi.ScopeBinding"/>
      <param name="annotationType" type="java.lang.Class"/>
      <param name="scope" type="com.google.inject.Scope"/>
    </method>
    <method name="voidProviderMethod" return="com.google.inject.internal.Errors"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="missingConstantValues" return="com.google.inject.internal.Errors"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="cannotInjectInnerClass" return="com.google.inject.internal.Errors"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="java.lang.Class"/>
    </method>
    <method name="cannotInjectLocalClass" return="com.google.inject.internal.Errors"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="java.lang.Class"/>
    </method>
    <method name="duplicateBindingAnnotations" return="com.google.inject.internal.Errors"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="member" type="java.lang.reflect.Member"/>
      <param name="a" type="java.lang.Class"/>
      <param name="b" type="java.lang.Class"/>
    </method>
    <method name="staticInjectionOnInterface" return="com.google.inject.internal.Errors"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="clazz" type="java.lang.Class"/>
    </method>
    <method name="cannotInjectFinalField" return="com.google.inject.internal.Errors"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="field" type="java.lang.reflect.Field"/>
    </method>
    <method name="atTargetIsMissingParameter" return="com.google.inject.internal.Errors"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="bindingAnnotation" type="java.lang.annotation.Annotation"/>
      <param name="parameterName" type="java.lang.String"/>
      <param name="clazz" type="java.lang.Class"/>
    </method>
    <method name="cannotInjectAbstractMethod" return="com.google.inject.internal.Errors"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="method" type="java.lang.reflect.Method"/>
    </method>
    <method name="cannotInjectMethodWithTypeParameters" return="com.google.inject.internal.Errors"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="method" type="java.lang.reflect.Method"/>
    </method>
    <method name="duplicateScopeAnnotations" return="com.google.inject.internal.Errors"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="a" type="java.lang.Class"/>
      <param name="b" type="java.lang.Class"/>
    </method>
    <method name="recursiveBinding" return="com.google.inject.internal.Errors"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="com.google.inject.Key"/>
      <param name="linkedKey" type="com.google.inject.Key"/>
    </method>
    <method name="bindingAlreadySet" return="com.google.inject.internal.Errors"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="com.google.inject.Key"/>
      <param name="source" type="java.lang.Object"/>
    </method>
    <method name="jitBindingAlreadySet" return="com.google.inject.internal.Errors"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="com.google.inject.Key"/>
    </method>
    <method name="childBindingAlreadySet" return="com.google.inject.internal.Errors"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="com.google.inject.Key"/>
      <param name="sources" type="java.util.Set"/>
    </method>
    <method name="errorCheckingDuplicateBinding" return="com.google.inject.internal.Errors"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="com.google.inject.Key"/>
      <param name="source" type="java.lang.Object"/>
      <param name="t" type="java.lang.Throwable"/>
    </method>
    <method name="errorNotifyingTypeListener" return="com.google.inject.internal.Errors"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="listener" type="com.google.inject.spi.TypeListenerBinding"/>
      <param name="type" type="com.google.inject.TypeLiteral"/>
      <param name="cause" type="java.lang.Throwable"/>
    </method>
    <method name="exposedButNotBound" return="com.google.inject.internal.Errors"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="com.google.inject.Key"/>
    </method>
    <method name="keyNotFullySpecified" return="com.google.inject.internal.Errors"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="typeLiteral" type="com.google.inject.TypeLiteral"/>
    </method>
    <method name="errorEnhancingClass" return="com.google.inject.internal.Errors"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="clazz" type="java.lang.Class"/>
      <param name="cause" type="java.lang.Throwable"/>
    </method>
    <method name="getMessagesFromThrowable" return="java.util.Collection"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="throwable" type="java.lang.Throwable"/>
    </method>
    <method name="errorInUserCode" return="com.google.inject.internal.Errors"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="cause" type="java.lang.Throwable"/>
      <param name="messageFormat" type="java.lang.String"/>
      <param name="arguments" type="java.lang.Object[]"/>
    </method>
    <method name="cannotInjectRawProvider" return="com.google.inject.internal.Errors"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="cannotInjectRawMembersInjector" return="com.google.inject.internal.Errors"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="cannotInjectTypeLiteralOf" return="com.google.inject.internal.Errors"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="unsupportedType" type="java.lang.reflect.Type"/>
    </method>
    <method name="cannotInjectRawTypeLiteral" return="com.google.inject.internal.Errors"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="throwCreationExceptionIfErrorsExist"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="throwConfigurationExceptionIfErrorsExist"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="throwProvisionExceptionIfErrorsExist"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="merge" return="com.google.inject.internal.Errors"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="messages" type="java.util.Collection"/>
    </method>
    <method name="merge" return="com.google.inject.internal.Errors"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="moreErrors" type="com.google.inject.internal.Errors"/>
    </method>
    <method name="merge" return="com.google.inject.internal.Errors"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="ipe" type="com.google.inject.internal.InternalProvisionException"/>
    </method>
    <method name="throwIfNewErrors"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="expectedSize" type="int"/>
      <exception name="ErrorsException" type="com.google.inject.internal.ErrorsException"/>
    </method>
    <method name="toException" return="com.google.inject.internal.ErrorsException"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="hasErrors" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="addMessage" return="com.google.inject.internal.Errors"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="messageFormat" type="java.lang.String"/>
      <param name="arguments" type="java.lang.Object[]"/>
    </method>
    <method name="addMessage" return="com.google.inject.internal.Errors"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="errorId" type="com.google.inject.internal.ErrorId"/>
      <param name="messageFormat" type="java.lang.String"/>
      <param name="arguments" type="java.lang.Object[]"/>
    </method>
    <method name="addMessage" return="com.google.inject.internal.Errors"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="message" type="com.google.inject.spi.Message"/>
    </method>
    <method name="format" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="messageFormat" type="java.lang.String"/>
      <param name="arguments" type="java.lang.Object[]"/>
    </method>
    <method name="getMessages" return="java.util.List"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="size" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="convert" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="o" type="java.lang.Object"/>
    </method>
    <method name="convert" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="o" type="java.lang.Object"/>
      <param name="source" type="com.google.inject.spi.ElementSource"/>
    </method>
    <method name="formatSource"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="formatter" type="java.util.Formatter"/>
      <param name="source" type="java.lang.Object"/>
    </method>
    <doc>
    <![CDATA[A collection of error messages. If this type is passed as a method parameter, the method is
 considered to have executed successfully only if new errors were not added to this collection.

 <p>Errors can be chained to provide additional context. To add context, call {@link #withSource}
 to create a new Errors instance that contains additional context. All messages added to the
 returned instance will contain full context.

 <p>To avoid messages with redundant context, {@link #withSource} should be added sparingly. A
 good rule of thumb is to assume a method's caller has already specified enough context to
 identify that method. When calling a method that's defined in a different context, call that
 method with an errors object that includes its context.

 @author jessewilson@google.com (Jesse Wilson)]]>
    </doc>
  </class>
  <!-- end class com.google.inject.internal.Errors -->
  <!-- start class com.google.inject.internal.ErrorsException -->
  <class name="ErrorsException" extends="java.lang.Exception"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="ErrorsException" type="com.google.inject.internal.Errors"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getErrors" return="com.google.inject.internal.Errors"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Indicates that a result could not be returned while preparing or resolving a binding. The caller
 should {@link Errors#merge(Errors) merge} the errors from this exception with their existing
 errors.

 @author jessewilson@google.com (Jesse Wilson)]]>
    </doc>
  </class>
  <!-- end class com.google.inject.internal.ErrorsException -->
  <!-- start class com.google.inject.internal.ExposureBuilder -->
  <class name="ExposureBuilder" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.inject.binder.AnnotatedElementBuilder"/>
    <constructor name="ExposureBuilder" type="com.google.inject.Binder, java.lang.Object, com.google.inject.Key"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="checkNotAnnotated"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </method>
    <method name="annotatedWith"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="annotationType" type="java.lang.Class"/>
    </method>
    <method name="annotatedWith"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="annotation" type="java.lang.annotation.Annotation"/>
    </method>
    <method name="getKey" return="com.google.inject.Key"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getSource" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[For private binder's expose() method.]]>
    </doc>
  </class>
  <!-- end class com.google.inject.internal.ExposureBuilder -->
  <!-- start class com.google.inject.internal.FailableCache -->
  <class name="FailableCache" extends="java.lang.Object"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="FailableCache"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="create" return="java.lang.Object"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="key" type="java.lang.Object"/>
      <param name="errors" type="com.google.inject.internal.Errors"/>
      <exception name="ErrorsException" type="com.google.inject.internal.ErrorsException"/>
    </method>
    <method name="get" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.lang.Object"/>
      <param name="errors" type="com.google.inject.internal.Errors"/>
      <exception name="ErrorsException" type="com.google.inject.internal.ErrorsException"/>
    </method>
    <doc>
    <![CDATA[Lazily creates (and caches) values for keys. If creating the value fails (with errors), an
 exception is thrown on retrieval.

 @author jessewilson@google.com (Jesse Wilson)]]>
    </doc>
  </class>
  <!-- end class com.google.inject.internal.FailableCache -->
  <!-- start class com.google.inject.internal.GenericErrorDetail -->
  <class name="GenericErrorDetail" extends="com.google.inject.internal.InternalErrorDetail"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="java.io.Serializable"/>
    <constructor name="GenericErrorDetail" type="com.google.inject.internal.ErrorId, java.lang.String, java.util.List, java.lang.Throwable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="formatDetail"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="mergeableErrors" type="java.util.List"/>
      <param name="formatter" type="java.util.Formatter"/>
    </method>
    <method name="withSources" return="com.google.inject.internal.GenericErrorDetail"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="newSources" type="java.util.List"/>
    </method>
    <doc>
    <![CDATA[Generic error message representing a Guice internal error.]]>
    </doc>
  </class>
  <!-- end class com.google.inject.internal.GenericErrorDetail -->
  <!-- start class com.google.inject.internal.GuiceInternal -->
  <class name="GuiceInternal" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <doc>
    <![CDATA[Class used for restricting APIs in other packages to only be used by this package.

 <p>Other packages can reference this class but only this package can reference an instance of it,
 so adding this class as a method param ensures that only this package can call it (provided null
 is disallowed).]]>
    </doc>
  </class>
  <!-- end class com.google.inject.internal.GuiceInternal -->
  <!-- start class com.google.inject.internal.InternalFlags -->
  <class name="InternalFlags" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="getIncludeStackTraceOption" return="com.google.inject.internal.InternalFlags.IncludeStackTraceOption"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getCustomClassLoadingOption" return="com.google.inject.internal.InternalFlags.CustomClassLoadingOption"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getNullableProvidesOption" return="com.google.inject.internal.InternalFlags.NullableProvidesOption"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="isBytecodeGenEnabled" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="enableColorizeErrorMessages" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Contains flags for Guice.]]>
    </doc>
  </class>
  <!-- end class com.google.inject.internal.InternalFlags -->
  <!-- start class com.google.inject.internal.InternalFlags.BytecodeGenOption -->
  <class name="InternalFlags.BytecodeGenOption" extends="java.lang.Enum"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="values" return="com.google.inject.internal.InternalFlags.BytecodeGenOption[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="com.google.inject.internal.InternalFlags.BytecodeGenOption"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <field name="DISABLED" type="com.google.inject.internal.InternalFlags.BytecodeGenOption"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Bytecode generation is disabled and using features that require it such as method
 interception will throw errors at run time.]]>
      </doc>
    </field>
    <field name="ENABLED" type="com.google.inject.internal.InternalFlags.BytecodeGenOption"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Bytecode generation is enabled.]]>
      </doc>
    </field>
    <doc>
    <![CDATA[Options for controlling whether Guice uses bytecode generation at runtime. When bytecode
 generation is enabled, the following features will be enabled in Guice:

 <ul>
   <li>Runtime bytecode generation (instead of reflection) will be used when Guice need to
       invoke application code.
   <li>Method interception.
 </ul>

 <p>Bytecode generation is generally faster than using reflection when invoking application
 code, however, it can use more memory and slower in certain cases due to the time spent in
 generating the classes. If you prefer to use reflection over bytecode generation then set
 {@link BytecodeGenOption} to {@code DISABLED}.]]>
    </doc>
  </class>
  <!-- end class com.google.inject.internal.InternalFlags.BytecodeGenOption -->
  <!-- start class com.google.inject.internal.InternalFlags.ColorizeOption -->
  <class name="InternalFlags.ColorizeOption" extends="java.lang.Enum"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="values" return="com.google.inject.internal.InternalFlags.ColorizeOption[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="com.google.inject.internal.InternalFlags.ColorizeOption"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <field name="AUTO" type="com.google.inject.internal.InternalFlags.ColorizeOption"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="ON" type="com.google.inject.internal.InternalFlags.ColorizeOption"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="OFF" type="com.google.inject.internal.InternalFlags.ColorizeOption"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[Options for enable or disable using ansi color in error messages.]]>
    </doc>
  </class>
  <!-- end class com.google.inject.internal.InternalFlags.ColorizeOption -->
  <!-- start class com.google.inject.internal.InternalFlags.CustomClassLoadingOption -->
  <class name="InternalFlags.CustomClassLoadingOption" extends="java.lang.Enum"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="values" return="com.google.inject.internal.InternalFlags.CustomClassLoadingOption[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="com.google.inject.internal.InternalFlags.CustomClassLoadingOption"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <field name="OFF" type="com.google.inject.internal.InternalFlags.CustomClassLoadingOption"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Define fast/enhanced types in the same class loader as their original type, never creates
 class loaders. Uses {@link sun.misc.Unsafe} to gain access to existing class loaders.]]>
      </doc>
    </field>
    <field name="ANONYMOUS" type="com.google.inject.internal.InternalFlags.CustomClassLoadingOption"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Define fast/enhanced types anonymously as hidden nest-mates, never creates class loaders.
 This is faster than regular class loading and the resulting classes are easier to unload.

 <p>Note: with this option you cannot look up fast/enhanced types by name or mock/spy them.]]>
      </doc>
    </field>
    <field name="BRIDGE" type="com.google.inject.internal.InternalFlags.CustomClassLoadingOption"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Attempt to define fast/enhanced types in the same class loader as their original type.
 Otherwise creates a child class loader whose parent is the original class loader. (Default)]]>
      </doc>
    </field>
    <field name="CHILD" type="com.google.inject.internal.InternalFlags.CustomClassLoadingOption"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Define fast/enhanced types in a child class loader whose parent is the original class loader.

 <p>Note: with this option you cannot intercept package-private methods.]]>
      </doc>
    </field>
    <doc>
    <![CDATA[The options for Guice custom class loading.]]>
    </doc>
  </class>
  <!-- end class com.google.inject.internal.InternalFlags.CustomClassLoadingOption -->
  <!-- start class com.google.inject.internal.InternalFlags.IncludeStackTraceOption -->
  <class name="InternalFlags.IncludeStackTraceOption" extends="java.lang.Enum"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="values" return="com.google.inject.internal.InternalFlags.IncludeStackTraceOption[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="com.google.inject.internal.InternalFlags.IncludeStackTraceOption"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <field name="OFF" type="com.google.inject.internal.InternalFlags.IncludeStackTraceOption"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[No stack trace collection]]>
      </doc>
    </field>
    <field name="ONLY_FOR_DECLARING_SOURCE" type="com.google.inject.internal.InternalFlags.IncludeStackTraceOption"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Minimum stack trace collection (Default)]]>
      </doc>
    </field>
    <doc>
    <![CDATA[The options for Guice stack trace collection.]]>
    </doc>
  </class>
  <!-- end class com.google.inject.internal.InternalFlags.IncludeStackTraceOption -->
  <!-- start class com.google.inject.internal.InternalFlags.NullableProvidesOption -->
  <class name="InternalFlags.NullableProvidesOption" extends="java.lang.Enum"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="values" return="com.google.inject.internal.InternalFlags.NullableProvidesOption[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="com.google.inject.internal.InternalFlags.NullableProvidesOption"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <field name="IGNORE" type="com.google.inject.internal.InternalFlags.NullableProvidesOption"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Ignore null parameters to @Provides methods.]]>
      </doc>
    </field>
    <field name="WARN" type="com.google.inject.internal.InternalFlags.NullableProvidesOption"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Warn if null parameters are passed to non-@Nullable parameters of provides methods.]]>
      </doc>
    </field>
    <field name="ERROR" type="com.google.inject.internal.InternalFlags.NullableProvidesOption"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Error if null parameters are passed to non-@Nullable parameters of provides parameters]]>
      </doc>
    </field>
    <doc>
    <![CDATA[Options for handling nullable parameters used in provides methods.]]>
    </doc>
  </class>
  <!-- end class com.google.inject.internal.InternalFlags.NullableProvidesOption -->
  <!-- start class com.google.inject.internal.InternalInjectorCreator -->
  <class name="InternalInjectorCreator" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="InternalInjectorCreator"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="stage" return="com.google.inject.internal.InternalInjectorCreator"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="stage" type="com.google.inject.Stage"/>
    </method>
    <method name="parentInjector" return="com.google.inject.internal.InternalInjectorCreator"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="parent" type="com.google.inject.internal.InjectorImpl"/>
      <doc>
      <![CDATA[Sets the parent of the injector to-be-constructed. As a side effect, this sets this injector's
 stage to the stage of {@code parent} and sets {@link #requireExplicitBindings()} if the parent
 injector also required them.]]>
      </doc>
    </method>
    <method name="addModules" return="com.google.inject.internal.InternalInjectorCreator"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="modules" type="java.lang.Iterable"/>
    </method>
    <method name="build" return="com.google.inject.Injector"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Builds a tree of injectors. This is a primary injector, plus child injectors needed for each
 {@code Binder.newPrivateBinder() private environment}. The primary injector is not necessarily a
 top-level injector.

 <p>Injector construction happens in two phases.

 <ol>
   <li>Static building. In this phase, we interpret commands, create bindings, and inspect
       dependencies. During this phase, we hold a lock to ensure consistency with parent
       injectors. No user code is executed in this phase.
   <li>Dynamic injection. In this phase, we call user code. We inject members that requested
       injection. This may require user's objects be created and their providers be called. And we
       create eager singletons. In this phase, user code may have started other threads. This
       phase is not executed for injectors created using {@link Stage#TOOL the tool stage}
 </ol>

 @author crazybob@google.com (Bob Lee)
 @author jessewilson@google.com (Jesse Wilson)]]>
    </doc>
  </class>
  <!-- end class com.google.inject.internal.InternalInjectorCreator -->
  <!-- start class com.google.inject.internal.InternalProvisionException -->
  <class name="InternalProvisionException" extends="java.lang.Exception"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="circularDependenciesDisabled" return="com.google.inject.internal.InternalProvisionException"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="expectedType" type="java.lang.Class"/>
    </method>
    <method name="cannotProxyClass" return="com.google.inject.internal.InternalProvisionException"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="expectedType" type="java.lang.Class"/>
    </method>
    <method name="create" return="com.google.inject.internal.InternalProvisionException"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="errorId" type="com.google.inject.internal.ErrorId"/>
      <param name="format" type="java.lang.String"/>
      <param name="arguments" type="java.lang.Object[]"/>
    </method>
    <method name="errorInUserCode" return="com.google.inject.internal.InternalProvisionException"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="errorId" type="com.google.inject.internal.ErrorId"/>
      <param name="cause" type="java.lang.Throwable"/>
      <param name="messageFormat" type="java.lang.String"/>
      <param name="arguments" type="java.lang.Object[]"/>
    </method>
    <method name="subtypeNotProvided" return="com.google.inject.internal.InternalProvisionException"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="providerType" type="java.lang.Class"/>
      <param name="type" type="java.lang.Class"/>
    </method>
    <method name="errorInProvider" return="com.google.inject.internal.InternalProvisionException"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="cause" type="java.lang.Throwable"/>
    </method>
    <method name="errorInjectingMethod" return="com.google.inject.internal.InternalProvisionException"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="cause" type="java.lang.Throwable"/>
    </method>
    <method name="errorInjectingConstructor" return="com.google.inject.internal.InternalProvisionException"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="cause" type="java.lang.Throwable"/>
    </method>
    <method name="errorInUserInjector" return="com.google.inject.internal.InternalProvisionException"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="listener" type="com.google.inject.MembersInjector"/>
      <param name="type" type="com.google.inject.TypeLiteral"/>
      <param name="cause" type="java.lang.RuntimeException"/>
    </method>
    <method name="jitDisabled" return="com.google.inject.internal.InternalProvisionException"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="com.google.inject.Key"/>
    </method>
    <method name="errorNotifyingInjectionListener" return="com.google.inject.internal.InternalProvisionException"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="listener" type="com.google.inject.spi.InjectionListener"/>
      <param name="type" type="com.google.inject.TypeLiteral"/>
      <param name="cause" type="java.lang.RuntimeException"/>
    </method>
    <method name="toProvisionException" return="com.google.inject.ProvisionException"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns this exception convered to a ProvisionException.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A checked exception for provisioning errors.

 <p>This is the internal dual of {@link ProvisionException}, similar to the relationship between
 {@link com.google.inject.ConfigurationException} and {@link ErrorsException}. This is useful for
 several reasons:

 <ul>
   <li>Since it is a checked exception, we get some assistance from the java compiler in ensuring
       that we correctly handle it everywhere. ProvisionException is unchecked.
   <li>Since this is an internal package, we can add useful construction and mutation APIs that
       would be undesirable in a public supported API.
 </ul>

 <p>This exception will be thrown when errors are encountered during provisioning, ErrorsException
 will continue to be used for errors that are encountered during provisioning and both make use of
 the {@link Message} as the core model.

 <p>NOTE: this object stores a list of messages but in the most common case the cardinality will
 be 1. The only time that multiple errors might be reported via this mechanism is when {@link
 #errorInUserCode} is called with an exception that holds multiple errors (like
 ProvisionException).]]>
    </doc>
  </class>
  <!-- end class com.google.inject.internal.InternalProvisionException -->
  <!-- start class com.google.inject.internal.KotlinSupport -->
  <class name="KotlinSupport" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="getInstance" return="com.google.inject.internal.KotlinSupportInterface"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Class to conditionally load support for Kotlin features. These features are enabled based on
 whether {@code com.google.inject.KotlinSupportImpl} is in the class path.]]>
    </doc>
  </class>
  <!-- end class com.google.inject.internal.KotlinSupport -->
  <!-- start interface com.google.inject.internal.KotlinSupportInterface -->
  <interface name="KotlinSupportInterface"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="getAnnotations" return="java.lang.annotation.Annotation[]"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="field" type="java.lang.reflect.Field"/>
      <doc>
      <![CDATA[Returns an array of {@link Annotation}s on the field's Kotlin property (if applicable).]]>
      </doc>
    </method>
    <method name="isNullable" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="field" type="java.lang.reflect.Field"/>
      <doc>
      <![CDATA[Returns true if the field is declared as kotlin nullable type.]]>
      </doc>
    </method>
    <method name="getIsParameterKotlinNullablePredicate" return="java.util.function.Predicate"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="constructor" type="java.lang.reflect.Constructor"/>
      <doc>
      <![CDATA[Returns a {@link Predicate} that says whether the constructor's i-th parameter is
 Kotlin-nullable.]]>
      </doc>
    </method>
    <method name="getIsParameterKotlinNullablePredicate" return="java.util.function.Predicate"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="method" type="java.lang.reflect.Method"/>
      <doc>
      <![CDATA[Returns a {@link Predicate} that says whether the method's i-th parameter is Kotlin-nullable.]]>
      </doc>
    </method>
    <method name="checkConstructorParameterAnnotations"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="constructor" type="java.lang.reflect.Constructor"/>
      <param name="errors" type="com.google.inject.internal.Errors"/>
      <doc>
      <![CDATA[Checks for any errors on the constructor's parameters's annotations.]]>
      </doc>
    </method>
    <method name="isLocalClass" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="clazz" type="java.lang.Class"/>
      <doc>
      <![CDATA[Returns whether the {@code clazz} is a local Kotlin class.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Interface for accessing information about Kotlin code.]]>
    </doc>
  </interface>
  <!-- end interface com.google.inject.internal.KotlinSupportInterface -->
  <!-- start class com.google.inject.internal.Messages -->
  <class name="Messages" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="format" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="messageFormat" type="java.lang.String"/>
      <param name="arguments" type="java.lang.Object[]"/>
      <doc>
      <![CDATA[Calls {@link String#format} after converting the arguments using some standard guice formatting
 for {@link Key}, {@link Class} and {@link Member} objects.]]>
      </doc>
    </method>
    <method name="formatMessages" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="heading" type="java.lang.String"/>
      <param name="errorMessages" type="java.util.Collection"/>
      <doc>
      <![CDATA[Returns the formatted message for an exception with the specified messages.]]>
      </doc>
    </method>
    <method name="create" return="com.google.inject.spi.Message"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="errorId" type="com.google.inject.internal.ErrorId"/>
      <param name="messageFormat" type="java.lang.String"/>
      <param name="arguments" type="java.lang.Object[]"/>
      <doc>
      <![CDATA[Creates a new Message without a cause.

 @param errorId The enum id for the error
 @param messageFormat Format string
 @param arguments format string arguments]]>
      </doc>
    </method>
    <method name="create" return="com.google.inject.spi.Message"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="errorId" type="com.google.inject.internal.ErrorId"/>
      <param name="cause" type="java.lang.Throwable"/>
      <param name="messageFormat" type="java.lang.String"/>
      <param name="arguments" type="java.lang.Object[]"/>
      <doc>
      <![CDATA[Creates a new Message with the given cause.

 @param errorId The enum id for the error
 @param cause The exception that caused the error
 @param messageFormat Format string
 @param arguments format string arguments]]>
      </doc>
    </method>
    <method name="create" return="com.google.inject.spi.Message"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="errorId" type="com.google.inject.internal.ErrorId"/>
      <param name="cause" type="java.lang.Throwable"/>
      <param name="sources" type="java.util.List"/>
      <param name="messageFormat" type="java.lang.String"/>
      <param name="arguments" type="java.lang.Object[]"/>
      <doc>
      <![CDATA[Creates a new Message with the given cause and a binding source stack.

 @param errorId The enum id for the error
 @param cause The exception that caused the error
 @param sources The binding sources for the source stack
 @param messageFormat Format string
 @param arguments format string arguments]]>
      </doc>
    </method>
    <method name="getOnlyCause" return="java.lang.Throwable"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="messages" type="java.util.Collection"/>
      <doc>
      <![CDATA[Returns the cause throwable if there is exactly one cause in {@code messages}. If there are
 zero or multiple messages with causes, null is returned.]]>
      </doc>
    </method>
    <method name="bold" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="text" type="java.lang.String"/>
    </method>
    <method name="redBold" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="text" type="java.lang.String"/>
    </method>
    <method name="underline" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="text" type="java.lang.String"/>
    </method>
    <method name="faint" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="text" type="java.lang.String"/>
    </method>
    <doc>
    <![CDATA[Utility methods for {@link Message} objects]]>
    </doc>
  </class>
  <!-- end class com.google.inject.internal.Messages -->
  <!-- start class com.google.inject.internal.MoreTypes -->
  <class name="MoreTypes" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="canonicalizeKey" return="com.google.inject.Key"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="com.google.inject.Key"/>
      <doc>
      <![CDATA[Returns a key that doesn't hold any references to parent classes. This is necessary for
 anonymous keys, so ensure we don't hold a ref to the containing module (or class) forever.]]>
      </doc>
    </method>
    <method name="canonicalizeForKey" return="com.google.inject.TypeLiteral"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="typeLiteral" type="com.google.inject.TypeLiteral"/>
      <doc>
      <![CDATA[Returns an type that's appropriate for use in a key.

 <p>If the raw type of {@code typeLiteral} is a {@code javax.inject.Provider}, this returns a
 {@code com.google.inject.Provider} with the same type parameters.

 <p>If the type is a primitive, the corresponding wrapper type will be returned.

 @throws ConfigurationException if {@code type} contains a type variable]]>
      </doc>
    </method>
    <method name="canonicalize" return="java.lang.reflect.Type"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="java.lang.reflect.Type"/>
      <doc>
      <![CDATA[Returns a type that is functionally equal but not necessarily equal according to {@link
 Object#equals(Object) Object.equals()}. The returned type is {@link Serializable}.]]>
      </doc>
    </method>
    <method name="getRawType" return="java.lang.Class"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="java.lang.reflect.Type"/>
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="a" type="java.lang.reflect.Type"/>
      <param name="b" type="java.lang.reflect.Type"/>
      <doc>
      <![CDATA[Returns true if {@code a} and {@code b} are equal.]]>
      </doc>
    </method>
    <method name="typeToString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="java.lang.reflect.Type"/>
    </method>
    <method name="getGenericSupertype" return="java.lang.reflect.Type"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="java.lang.reflect.Type"/>
      <param name="rawType" type="java.lang.Class"/>
      <param name="toResolve" type="java.lang.Class"/>
      <doc>
      <![CDATA[Returns the generic supertype for {@code type}. For example, given a class {@code IntegerSet},
 the result for when supertype is {@code Set.class} is {@code Set<Integer>} and the result when
 the supertype is {@code Collection.class} is {@code Collection<Integer>}.]]>
      </doc>
    </method>
    <method name="resolveTypeVariable" return="java.lang.reflect.Type"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="java.lang.reflect.Type"/>
      <param name="rawType" type="java.lang.Class"/>
      <param name="unknown" type="java.lang.reflect.TypeVariable"/>
    </method>
    <field name="EMPTY_TYPE_ARRAY" type="java.lang.reflect.Type[]"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[Static methods for working with types that we aren't publishing in the public {@code Types} API.

 @author jessewilson@google.com (Jesse Wilson)]]>
    </doc>
  </class>
  <!-- end class com.google.inject.internal.MoreTypes -->
  <!-- start class com.google.inject.internal.MoreTypes.GenericArrayTypeImpl -->
  <class name="MoreTypes.GenericArrayTypeImpl" extends="java.lang.Object"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.lang.reflect.GenericArrayType"/>
    <implements name="java.io.Serializable"/>
    <implements name="com.google.inject.internal.MoreTypes.CompositeType"/>
    <constructor name="GenericArrayTypeImpl" type="java.lang.reflect.Type"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getGenericComponentType" return="java.lang.reflect.Type"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="isFullySpecified" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="o" type="java.lang.Object"/>
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
  </class>
  <!-- end class com.google.inject.internal.MoreTypes.GenericArrayTypeImpl -->
  <!-- start class com.google.inject.internal.MoreTypes.ParameterizedTypeImpl -->
  <class name="MoreTypes.ParameterizedTypeImpl" extends="java.lang.Object"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.lang.reflect.ParameterizedType"/>
    <implements name="java.io.Serializable"/>
    <implements name="com.google.inject.internal.MoreTypes.CompositeType"/>
    <constructor name="ParameterizedTypeImpl" type="java.lang.reflect.Type, java.lang.reflect.Type, java.lang.reflect.Type[]"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getActualTypeArguments" return="java.lang.reflect.Type[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getRawType" return="java.lang.reflect.Type"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getOwnerType" return="java.lang.reflect.Type"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="isFullySpecified" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="other" type="java.lang.Object"/>
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
  </class>
  <!-- end class com.google.inject.internal.MoreTypes.ParameterizedTypeImpl -->
  <!-- start class com.google.inject.internal.MoreTypes.WildcardTypeImpl -->
  <class name="MoreTypes.WildcardTypeImpl" extends="java.lang.Object"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.lang.reflect.WildcardType"/>
    <implements name="java.io.Serializable"/>
    <implements name="com.google.inject.internal.MoreTypes.CompositeType"/>
    <constructor name="WildcardTypeImpl" type="java.lang.reflect.Type[], java.lang.reflect.Type[]"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getUpperBounds" return="java.lang.reflect.Type[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getLowerBounds" return="java.lang.reflect.Type[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="isFullySpecified" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="other" type="java.lang.Object"/>
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[The WildcardType interface supports multiple upper bounds and multiple lower bounds. We only
 support what the Java 6 language needs - at most one bound. If a lower bound is set, the upper
 bound must be Object.class.]]>
    </doc>
  </class>
  <!-- end class com.google.inject.internal.MoreTypes.WildcardTypeImpl -->
  <!-- start class com.google.inject.internal.Nullability -->
  <class name="Nullability" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="hasNullableAnnotation" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="annotations" type="java.lang.annotation.Annotation[]"/>
      <doc>
      <![CDATA[Returns true if the given annotation array contains an annotation named {@code Nullable}.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Whether a member supports null values injected.

 <p>Support for {@code Nullable} annotations in Guice is loose. Any annotation type whose
 simplename is "Nullable" is sufficient to indicate support for null values injected.

 <p>This allows support for JSR-305's <a
 href="http://groups.google.com/group/jsr-305/web/proposed-annotations">
 javax.annotation.meta.Nullable</a> annotation and IntelliJ IDEA's <a
 href="http://www.jetbrains.com/idea/documentation/howto.html">
 org.jetbrains.annotations.Nullable</a>.

 @author jessewilson@google.com (Jesse Wilson)]]>
    </doc>
  </class>
  <!-- end class com.google.inject.internal.Nullability -->
  <!-- start class com.google.inject.internal.PrivateElementsImpl -->
  <class name="PrivateElementsImpl" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.inject.spi.PrivateElements"/>
    <constructor name="PrivateElementsImpl" type="java.lang.Object"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getSource" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getElements" return="java.util.List"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getInjector" return="com.google.inject.Injector"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="initInjector"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="injector" type="com.google.inject.Injector"/>
    </method>
    <method name="getExposedKeys" return="java.util.Set"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="acceptVisitor" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="visitor" type="com.google.inject.spi.ElementVisitor"/>
    </method>
    <method name="getElementsMutable" return="java.util.List"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="addExposureBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="exposureBuilder" type="com.google.inject.internal.ExposureBuilder"/>
    </method>
    <method name="applyTo"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="binder" type="com.google.inject.Binder"/>
    </method>
    <method name="getExposedSource" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="com.google.inject.Key"/>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[@author jessewilson@google.com (Jesse Wilson)]]>
    </doc>
  </class>
  <!-- end class com.google.inject.internal.PrivateElementsImpl -->
  <!-- start class com.google.inject.internal.ProviderMethod -->
  <class name="ProviderMethod" extends="com.google.inject.internal.InternalProviderInstanceBindingImpl.CyclicFactory"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.inject.spi.HasDependencies"/>
    <implements name="com.google.inject.spi.ProvidesMethodBinding"/>
    <implements name="com.google.inject.spi.ProviderWithExtensionVisitor"/>
    <method name="getKey" return="com.google.inject.Key"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getMethod" return="java.lang.reflect.Method"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getInstance" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getEnclosingInstance" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getAnnotation" return="java.lang.annotation.Annotation"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="configure"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="binder" type="com.google.inject.Binder"/>
    </method>
    <method name="doProvision" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="context" type="com.google.inject.internal.InternalContext"/>
      <param name="dependency" type="com.google.inject.spi.Dependency"/>
      <exception name="InternalProvisionException" type="com.google.inject.internal.InternalProvisionException"/>
    </method>
    <method name="getDependencies" return="java.util.Set"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="acceptExtensionVisitor" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="visitor" type="com.google.inject.spi.BindingTargetVisitor"/>
      <param name="binding" type="com.google.inject.spi.ProviderInstanceBinding"/>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="obj" type="java.lang.Object"/>
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <field name="instance" type="java.lang.Object"
      transient="false" volatile="false"
      static="false" final="true" visibility="protected"
      deprecated="not deprecated">
    </field>
    <field name="method" type="java.lang.reflect.Method"
      transient="false" volatile="false"
      static="false" final="true" visibility="protected"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[A provider that invokes a method and returns its result.

 @author jessewilson@google.com (Jesse Wilson)]]>
    </doc>
  </class>
  <!-- end class com.google.inject.internal.ProviderMethod -->
  <!-- start class com.google.inject.internal.ProviderMethodsModule -->
  <class name="ProviderMethodsModule" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.inject.Module"/>
    <method name="forModule" return="com.google.inject.Module"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="module" type="com.google.inject.Module"/>
      <doc>
      <![CDATA[Returns a module which creates bindings for provider methods from the given module.]]>
      </doc>
    </method>
    <method name="forModule" return="com.google.inject.Module"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="module" type="java.lang.Object"/>
      <param name="scanner" type="com.google.inject.spi.ModuleAnnotatedMethodScanner"/>
      <doc>
      <![CDATA[Returns a module which creates bindings methods in the module that match the scanner.]]>
      </doc>
    </method>
    <method name="forObject" return="com.google.inject.Module"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="object" type="java.lang.Object"/>
      <doc>
      <![CDATA[Returns a module which creates bindings for provider methods from the given object. This is
 useful notably for <a href="http://code.google.com/p/google-gin/">GIN</a>

 <p>This will skip bytecode generation for provider methods, since it is assumed that callers
 are only interested in Module metadata.]]>
      </doc>
    </method>
    <method name="getDelegateModuleClass" return="java.lang.Class"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="configure"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="binder" type="com.google.inject.Binder"/>
    </method>
    <method name="getProviderMethods" return="java.util.List"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="binder" type="com.google.inject.Binder"/>
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="o" type="java.lang.Object"/>
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="isScanningBuiltInProvidesMethods" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Is it scanning the built-in @Provides* methods.]]>
      </doc>
    </method>
    <method name="getScanner" return="com.google.inject.spi.ModuleAnnotatedMethodScanner"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Creates bindings to methods annotated with {@literal @}{@link Provides}. Use the scope and
 binding annotations on the provider method to configure the binding.

 @author crazybob@google.com (Bob Lee)
 @author jessewilson@google.com (Jesse Wilson)]]>
    </doc>
  </class>
  <!-- end class com.google.inject.internal.ProviderMethodsModule -->
  <!-- start class com.google.inject.internal.RealMapBinder -->
  <class name="RealMapBinder" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.inject.Module"/>
    <method name="newMapRealBinder" return="com.google.inject.internal.RealMapBinder"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="binder" type="com.google.inject.Binder"/>
      <param name="keyType" type="com.google.inject.TypeLiteral"/>
      <param name="valueType" type="com.google.inject.TypeLiteral"/>
      <doc>
      <![CDATA[Returns a new mapbinder that collects entries of {@code keyType}/{@code valueType} in a {@link
 Map} that is itself bound with no binding annotation.]]>
      </doc>
    </method>
    <method name="newRealMapBinder" return="com.google.inject.internal.RealMapBinder"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="binder" type="com.google.inject.Binder"/>
      <param name="keyType" type="com.google.inject.TypeLiteral"/>
      <param name="valueType" type="com.google.inject.TypeLiteral"/>
      <param name="annotation" type="java.lang.annotation.Annotation"/>
      <doc>
      <![CDATA[Returns a new mapbinder that collects entries of {@code keyType}/{@code valueType} in a {@link
 Map} that is itself bound with {@code annotation}.]]>
      </doc>
    </method>
    <method name="newRealMapBinder" return="com.google.inject.internal.RealMapBinder"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="binder" type="com.google.inject.Binder"/>
      <param name="keyType" type="com.google.inject.TypeLiteral"/>
      <param name="valueType" type="com.google.inject.TypeLiteral"/>
      <param name="annotationType" type="java.lang.Class"/>
      <doc>
      <![CDATA[Returns a new mapbinder that collects entries of {@code keyType}/{@code valueType} in a {@link
 Map} that is itself bound with {@code annotationType}.]]>
      </doc>
    </method>
    <method name="permitDuplicates"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="addBinding" return="com.google.inject.binder.LinkedBindingBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.lang.Object"/>
      <doc>
      <![CDATA[This creates two bindings. One for the {@code Map.Entry<K, Provider<V>>} and another for {@code
 V}.]]>
      </doc>
    </method>
    <method name="configure"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="binder" type="com.google.inject.Binder"/>
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="o" type="java.lang.Object"/>
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[The actual mapbinder plays several roles:

 <p>As a MapBinder, it acts as a factory for LinkedBindingBuilders for each of the map's values.
 It delegates to a {@link Multibinder} of entries (keys to value providers).

 <p>As a Module, it installs the binding to the map itself, as well as to a corresponding map
 whose values are providers.

 <p>As a module, this implements equals() and hashcode() in order to trick Guice into executing
 its configure() method only once. That makes it so that multiple mapbinders can be created for
 the same target map, but only one is bound. Since the list of bindings is retrieved from the
 injector itself (and not the mapbinder), each mapbinder has access to all contributions from all
 equivalent mapbinders.

 <p>Rather than binding a single Map.Entry&lt;K, V&gt;, the map binder binds keys and values
 independently. This allows the values to be properly scoped.]]>
    </doc>
  </class>
  <!-- end class com.google.inject.internal.RealMapBinder -->
  <!-- start class com.google.inject.internal.RealMultibinder -->
  <class name="RealMultibinder" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.inject.Module"/>
    <method name="newRealSetBinder" return="com.google.inject.internal.RealMultibinder"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="binder" type="com.google.inject.Binder"/>
      <param name="key" type="com.google.inject.Key"/>
      <doc>
      <![CDATA[Implementation of newSetBinder.]]>
      </doc>
    </method>
    <method name="configure"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="binder" type="com.google.inject.Binder"/>
    </method>
    <method name="permitDuplicates"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="addBinding" return="com.google.inject.binder.LinkedBindingBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="o" type="java.lang.Object"/>
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[The actual multibinder plays several roles:

 <p>As a Multibinder, it acts as a factory for LinkedBindingBuilders for each of the set's
 elements. Each binding is given an annotation that identifies it as a part of this set.

 <p>As a Module, it installs the binding to the set itself. As a module, this implements equals()
 and hashcode() in order to trick Guice into executing its configure() method only once. That
 makes it so that multiple multibinders can be created for the same target collection, but only
 one is bound. Since the list of bindings is retrieved from the injector itself (and not the
 multibinder), each multibinder has access to all contributions from all multibinders.

 <p>As a Provider, this constructs the set instances.

 <p>We use a subclass to hide 'implements Module, Provider' from the public API.]]>
    </doc>
  </class>
  <!-- end class com.google.inject.internal.RealMultibinder -->
  <!-- start class com.google.inject.internal.RealOptionalBinder -->
  <class name="RealOptionalBinder" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.inject.Module"/>
    <method name="newRealOptionalBinder" return="com.google.inject.internal.RealOptionalBinder"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="binder" type="com.google.inject.Binder"/>
      <param name="type" type="com.google.inject.Key"/>
    </method>
    <method name="setDefault" return="com.google.inject.binder.LinkedBindingBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setBinding" return="com.google.inject.binder.LinkedBindingBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="configure"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="binder" type="com.google.inject.Binder"/>
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="o" type="java.lang.Object"/>
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[The actual OptionalBinder plays several roles. It implements Module to hide that fact from the
 public API, and installs the various bindings that are exposed to the user.]]>
    </doc>
  </class>
  <!-- end class com.google.inject.internal.RealOptionalBinder -->
  <!-- start class com.google.inject.internal.Scoping -->
  <class name="Scoping" extends="java.lang.Object"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="forAnnotation" return="com.google.inject.internal.Scoping"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="scopingAnnotation" type="java.lang.Class"/>
    </method>
    <method name="forInstance" return="com.google.inject.internal.Scoping"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="scope" type="com.google.inject.Scope"/>
    </method>
    <method name="isExplicitlyScoped" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns true if this scope was explicitly applied. If no scope was explicitly applied then the
 scoping annotation will be used.]]>
      </doc>
    </method>
    <method name="isNoScope" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns true if this is the default scope. In this case a new instance will be provided for
 each injection.]]>
      </doc>
    </method>
    <method name="isEagerSingleton" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="stage" type="com.google.inject.Stage"/>
      <doc>
      <![CDATA[Returns true if this scope is a singleton that should be loaded eagerly in {@code stage}.]]>
      </doc>
    </method>
    <method name="getScopeInstance" return="com.google.inject.Scope"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the scope instance, or {@code null} if that isn't known for this instance.]]>
      </doc>
    </method>
    <method name="getScopeAnnotation" return="java.lang.Class"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the scope annotation, or {@code null} if that isn't known for this instance.]]>
      </doc>
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="obj" type="java.lang.Object"/>
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="acceptVisitor" return="java.lang.Object"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="visitor" type="com.google.inject.spi.BindingScopingVisitor"/>
    </method>
    <method name="applyTo"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="scopedBindingBuilder" type="com.google.inject.binder.ScopedBindingBuilder"/>
    </method>
    <field name="UNSCOPED" type="com.google.inject.internal.Scoping"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[No scoping annotation has been applied. Note that this is different from {@code
 in(Scopes.NO_SCOPE)}, where the 'NO_SCOPE' has been explicitly applied.]]>
      </doc>
    </field>
    <field name="SINGLETON_ANNOTATION" type="com.google.inject.internal.Scoping"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="SINGLETON_INSTANCE" type="com.google.inject.internal.Scoping"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="EAGER_SINGLETON" type="com.google.inject.internal.Scoping"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[References a scope, either directly (as a scope instance), or indirectly (as a scope annotation).
 The scope's eager or laziness is also exposed.

 @author jessewilson@google.com (Jesse Wilson)]]>
    </doc>
  </class>
  <!-- end class com.google.inject.internal.Scoping -->
  <!-- start class com.google.inject.internal.SingletonScope -->
  <class name="SingletonScope" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.inject.Scope"/>
    <constructor name="SingletonScope"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="scope" return="com.google.inject.Provider"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="com.google.inject.Key"/>
      <param name="creator" type="com.google.inject.Provider"/>
      <doc>
      <![CDATA[Provides singleton scope with the following properties:

 <ul>
   <li>creates no more than one instance per Key as a creator is used no more than once
   <li>result is cached and returned quickly on subsequent calls
   <li>exception in a creator is not treated as instance creation and is not cached
   <li>creates singletons in parallel whenever possible
   <li>waits for dependent singletons to be created even across threads and when dependencies
       are shared as long as no circular dependencies are detected
   <li>returns circular proxy only when circular dependencies are detected
   <li>aside from that, blocking synchronization is only used for proxy creation and
       initialization
 </ul>

 @see CycleDetectingLockFactory]]>
      </doc>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[One instance per {@link Injector}. Also see {@code @}{@link Singleton}.

 <p>Introduction from the author: Implementation of this class seems unreasonably complicated at
 the first sight. I fully agree with you, that the beast below is very complex and it's hard to
 reason on how does it work or not. Still I want to assure you that hundreds(?) of hours were
 thrown into making this code simple, while still maintaining Singleton contract.

 <p>Anyway, why is it so complex? Singleton scope does not seem to be that unique.

 <ol>
   <li>Guice has never truly expected to be used in multi threading environment with many
       Injectors working alongside each other. There is almost no code with Guice that propagates
       state between threads. And Singleton scope is The exception.
   <li>Guice supports circular dependencies and thus manages proxy objects. There is no interface
       that allows user defined Scopes to create proxies, it is expected to be done by Guice.
       Singleton scope needs to be able to detect circular dependencies spanning several threads,
       therefore Singleton scope needs to be able to create these proxies.
   <li>To make things worse, Guice has a very tricky definition for a binding resolution when
       Injectors are in in a parent/child relationship. And Scope does not have access to this
       information by design, the only real action that Scope can do is to call or not to call a
       creator.
   <li>There is no readily available code in Guice that can detect a potential deadlock, and no
       code for handling dependency cycles spanning several threads. This is significantly harder
       as all the dependencies in a thread at runtime can be represented with a list, where in a
       multi threaded environment we have more complex dependency trees.
   <li>Guice has a pretty strong contract regarding Garbage Collection, which often prevents us
       from linking objects directly. So simple domain specific code can not be written and
       intermediary id objects need to be managed.
   <li>Guice is relatively fast and we should not make things worse. We're trying our best to
       optimize synchronization for speed and memory. Happy path should be almost as fast as in a
       single threaded solution and should not take much more memory.
   <li>Error message generation in Guice was not meant to be used like this and to work around its
       APIs we need a lot of code. Additional complexity comes from inherent data races as message
       is only generated when failure occurs on proxy object generation. Things get ugly pretty
       fast.
 </ol>

 @see #scope(Key, Provider)
 @see CycleDetectingLock
 @author timofeyb (Timothy Basanov)]]>
    </doc>
  </class>
  <!-- end class com.google.inject.internal.SingletonScope -->
  <!-- start class com.google.inject.internal.UniqueAnnotations -->
  <class name="UniqueAnnotations" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="create" return="java.lang.annotation.Annotation"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns an annotation instance that is not equal to any other annotation instances, for use in
 creating distinct {@link com.google.inject.Key}s.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[@author jessewilson@google.com (Jesse Wilson)]]>
    </doc>
  </class>
  <!-- end class com.google.inject.internal.UniqueAnnotations -->
</package>
<package name="com.google.inject">
  <!-- start class com.google.inject.AbstractModule -->
  <class name="AbstractModule" extends="java.lang.Object"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.inject.Module"/>
    <constructor name="AbstractModule"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="configure"
      abstract="false" native="false" synchronized="true"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="builder" type="com.google.inject.Binder"/>
    </method>
    <method name="configure"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Configures a {@link Binder} via the exposed methods.]]>
      </doc>
    </method>
    <method name="binder" return="com.google.inject.Binder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets direct access to the underlying {@code Binder}.]]>
      </doc>
    </method>
    <method name="bindScope"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="scopeAnnotation" type="java.lang.Class"/>
      <param name="scope" type="com.google.inject.Scope"/>
      <doc>
      <![CDATA[@see Binder#bindScope(Class, Scope)]]>
      </doc>
    </method>
    <method name="bind" return="com.google.inject.binder.LinkedBindingBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="key" type="com.google.inject.Key"/>
      <doc>
      <![CDATA[@see Binder#bind(Key)]]>
      </doc>
    </method>
    <method name="bind" return="com.google.inject.binder.AnnotatedBindingBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="typeLiteral" type="com.google.inject.TypeLiteral"/>
      <doc>
      <![CDATA[See {@link Binder#bind(TypeLiteral)}.]]>
      </doc>
    </method>
    <method name="bind" return="com.google.inject.binder.AnnotatedBindingBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="clazz" type="java.lang.Class"/>
      <doc>
      <![CDATA[See {@link Binder#bind(Class)}.]]>
      </doc>
    </method>
    <method name="bindConstant" return="com.google.inject.binder.AnnotatedConstantBindingBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@see Binder#bindConstant()]]>
      </doc>
    </method>
    <method name="install"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="module" type="com.google.inject.Module"/>
      <doc>
      <![CDATA[@see Binder#install(Module)]]>
      </doc>
    </method>
    <method name="addError"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="message" type="java.lang.String"/>
      <param name="arguments" type="java.lang.Object[]"/>
      <doc>
      <![CDATA[@see Binder#addError(String, Object[])]]>
      </doc>
    </method>
    <method name="addError"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="t" type="java.lang.Throwable"/>
      <doc>
      <![CDATA[@see Binder#addError(Throwable)]]>
      </doc>
    </method>
    <method name="addError"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="message" type="com.google.inject.spi.Message"/>
      <doc>
      <![CDATA[@see Binder#addError(Message)
 @since 2.0]]>
      </doc>
    </method>
    <method name="requestInjection"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="instance" type="java.lang.Object"/>
      <doc>
      <![CDATA[@see Binder#requestInjection(Object)
 @since 2.0]]>
      </doc>
    </method>
    <method name="requestStaticInjection"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="types" type="java.lang.Class[]"/>
      <doc>
      <![CDATA[@see Binder#requestStaticInjection(Class[])]]>
      </doc>
    </method>
    <method name="bindInterceptor"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="classMatcher" type="com.google.inject.matcher.Matcher"/>
      <param name="methodMatcher" type="com.google.inject.matcher.Matcher"/>
      <param name="interceptors" type="org.aopalliance.intercept.MethodInterceptor[]"/>
      <doc>
      <![CDATA[@see Binder#bindInterceptor]]>
      </doc>
    </method>
    <method name="requireBinding"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="key" type="com.google.inject.Key"/>
      <doc>
      <![CDATA[Adds a dependency from this module to {@code key}. When the injector is created, Guice will
 report an error if {@code key} cannot be injected. Note that this requirement may be satisfied
 by implicit binding, such as a public no-arguments constructor.

 @since 2.0]]>
      </doc>
    </method>
    <method name="requireBinding"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="type" type="java.lang.Class"/>
      <doc>
      <![CDATA[Adds a dependency from this module to {@code type}. When the injector is created, Guice will
 report an error if {@code type} cannot be injected. Note that this requirement may be satisfied
 by implicit binding, such as a public no-arguments constructor.

 @since 2.0]]>
      </doc>
    </method>
    <method name="getProvider" return="com.google.inject.Provider"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="key" type="com.google.inject.Key"/>
      <doc>
      <![CDATA[@see Binder#getProvider(Key)
 @since 2.0]]>
      </doc>
    </method>
    <method name="getProvider" return="com.google.inject.Provider"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="type" type="java.lang.Class"/>
      <doc>
      <![CDATA[@see Binder#getProvider(Class)
 @since 2.0]]>
      </doc>
    </method>
    <method name="convertToTypes"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="typeMatcher" type="com.google.inject.matcher.Matcher"/>
      <param name="converter" type="com.google.inject.spi.TypeConverter"/>
      <doc>
      <![CDATA[@see Binder#convertToTypes
 @since 2.0]]>
      </doc>
    </method>
    <method name="currentStage" return="com.google.inject.Stage"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@see Binder#currentStage()
 @since 2.0]]>
      </doc>
    </method>
    <method name="getMembersInjector" return="com.google.inject.MembersInjector"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="type" type="java.lang.Class"/>
      <doc>
      <![CDATA[@see Binder#getMembersInjector(Class)
 @since 2.0]]>
      </doc>
    </method>
    <method name="getMembersInjector" return="com.google.inject.MembersInjector"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="type" type="com.google.inject.TypeLiteral"/>
      <doc>
      <![CDATA[@see Binder#getMembersInjector(TypeLiteral)
 @since 2.0]]>
      </doc>
    </method>
    <method name="bindListener"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="typeMatcher" type="com.google.inject.matcher.Matcher"/>
      <param name="listener" type="com.google.inject.spi.TypeListener"/>
      <doc>
      <![CDATA[@see Binder#bindListener(com.google.inject.matcher.Matcher, com.google.inject.spi.TypeListener)
 @since 2.0]]>
      </doc>
    </method>
    <method name="bindListener"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="bindingMatcher" type="com.google.inject.matcher.Matcher"/>
      <param name="listener" type="com.google.inject.spi.ProvisionListener[]"/>
      <doc>
      <![CDATA[@see Binder#bindListener(Matcher, ProvisionListener...)
 @since 4.0]]>
      </doc>
    </method>
    <doc>
    <![CDATA[AbstractModule is a helper class used to add bindings to the Guice injector.

 <p>Simply extend this class, then you can add bindings by either defining @Provides methods (see
 https://github.com/google/guice/wiki/ProvidesMethods) or implementing {@link #configure()}, and
 calling the inherited methods which mirror those found in {@link Binder}. For example:

 <pre>
 public class MyModule extends AbstractModule {
   protected void configure() {
     bind(Service.class).to(ServiceImpl.class).in(Singleton.class);
     bind(CreditCardPaymentService.class);
     bind(PaymentService.class).to(CreditCardPaymentService.class);
     bindConstant().annotatedWith(Names.named("port")).to(8080);
   }
 }
 </pre>

 @author crazybob@google.com (Bob Lee)]]>
    </doc>
  </class>
  <!-- end class com.google.inject.AbstractModule -->
  <!-- start interface com.google.inject.Binder -->
  <interface name="Binder"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="bindInterceptor"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="classMatcher" type="com.google.inject.matcher.Matcher"/>
      <param name="methodMatcher" type="com.google.inject.matcher.Matcher"/>
      <param name="interceptors" type="org.aopalliance.intercept.MethodInterceptor[]"/>
      <doc>
      <![CDATA[Binds method interceptor[s] to methods matched by class and method matchers. A method is
 eligible for interception if:

 <ul>
   <li>Guice created the instance the method is on
   <li>Neither the enclosing type nor the method is final
   <li>And the method is package-private, protected, or public
 </ul>

 <p>Note: this API only works if {@code guice_bytecode_gen_option} is set to {@code ENABLED}.

 @param classMatcher matches classes the interceptor should apply to. For example: {@code
     only(Runnable.class)}.
 @param methodMatcher matches methods the interceptor should apply to. For example: {@code
     annotatedWith(Transactional.class)}.
 @param interceptors to bind. The interceptors are called in the order they are given.]]>
      </doc>
    </method>
    <method name="bindScope"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="annotationType" type="java.lang.Class"/>
      <param name="scope" type="com.google.inject.Scope"/>
      <doc>
      <![CDATA[Binds a scope to an annotation.]]>
      </doc>
    </method>
    <method name="bind" return="com.google.inject.binder.LinkedBindingBuilder"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="com.google.inject.Key"/>
      <doc>
      <![CDATA[See the EDSL examples at {@link Binder}.]]>
      </doc>
    </method>
    <method name="bind" return="com.google.inject.binder.AnnotatedBindingBuilder"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="typeLiteral" type="com.google.inject.TypeLiteral"/>
      <doc>
      <![CDATA[See the EDSL examples at {@link Binder}.]]>
      </doc>
    </method>
    <method name="bind" return="com.google.inject.binder.AnnotatedBindingBuilder"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="java.lang.Class"/>
      <doc>
      <![CDATA[See the EDSL examples at {@link Binder}.]]>
      </doc>
    </method>
    <method name="bindConstant" return="com.google.inject.binder.AnnotatedConstantBindingBuilder"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[See the EDSL examples at {@link Binder}.]]>
      </doc>
    </method>
    <method name="requestInjection"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="com.google.inject.TypeLiteral"/>
      <param name="instance" type="java.lang.Object"/>
      <doc>
      <![CDATA[Upon successful creation, the {@link Injector} will inject instance fields and methods of the
 given object.

 @param type of instance
 @param instance for which members will be injected
 @since 2.0]]>
      </doc>
    </method>
    <method name="requestInjection"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="instance" type="java.lang.Object"/>
      <doc>
      <![CDATA[Upon successful creation, the {@link Injector} will inject instance fields and methods of the
 given object.

 @param instance for which members will be injected
 @since 2.0]]>
      </doc>
    </method>
    <method name="requestStaticInjection"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="types" type="java.lang.Class[]"/>
      <doc>
      <![CDATA[Upon successful creation, the {@link Injector} will inject static fields and methods in the
 given classes.

 @param types for which static members will be injected]]>
      </doc>
    </method>
    <method name="install"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="module" type="com.google.inject.Module"/>
      <doc>
      <![CDATA[Uses the given module to configure more bindings.]]>
      </doc>
    </method>
    <method name="currentStage" return="com.google.inject.Stage"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the current stage.]]>
      </doc>
    </method>
    <method name="addError"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="message" type="java.lang.String"/>
      <param name="arguments" type="java.lang.Object[]"/>
      <doc>
      <![CDATA[Records an error message which will be presented to the user at a later time. Unlike throwing
 an exception, this enable us to continue configuring the Injector and discover more errors.
 Uses {@link String#format(String, Object[])} to insert the arguments into the message.]]>
      </doc>
    </method>
    <method name="addError"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="t" type="java.lang.Throwable"/>
      <doc>
      <![CDATA[Records an exception, the full details of which will be logged, and the message of which will
 be presented to the user at a later time. If your Module calls something that you worry may
 fail, you should catch the exception and pass it into this.]]>
      </doc>
    </method>
    <method name="addError"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="message" type="com.google.inject.spi.Message"/>
      <doc>
      <![CDATA[Records an error message to be presented to the user at a later time.

 @since 2.0]]>
      </doc>
    </method>
    <method name="getProvider" return="com.google.inject.Provider"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="com.google.inject.Key"/>
      <doc>
      <![CDATA[Returns the provider used to obtain instances for the given injection key. The returned
 provider will not be valid until the {@link Injector} has been created. The provider will throw
 an {@code IllegalStateException} if you try to use it beforehand.

 @since 2.0]]>
      </doc>
    </method>
    <method name="getProvider" return="com.google.inject.Provider"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="dependency" type="com.google.inject.spi.Dependency"/>
      <doc>
      <![CDATA[Returns the provider used to obtain instances for the given injection key. The returned
 provider will be attached to the injection point and will follow the nullability specified in
 the dependency. Additionally, the returned provider will not be valid until the {@link
 Injector} has been created. The provider will throw an {@code IllegalStateException} if you try
 to use it beforehand.

 @since 4.0]]>
      </doc>
    </method>
    <method name="getProvider" return="com.google.inject.Provider"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="java.lang.Class"/>
      <doc>
      <![CDATA[Returns the provider used to obtain instances for the given injection type. The returned
 provider will not be valid until the {@link Injector} has been created. The provider will throw
 an {@code IllegalStateException} if you try to use it beforehand.

 @since 2.0]]>
      </doc>
    </method>
    <method name="getMembersInjector" return="com.google.inject.MembersInjector"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="typeLiteral" type="com.google.inject.TypeLiteral"/>
      <doc>
      <![CDATA[Returns the members injector used to inject dependencies into methods and fields on instances
 of the given type {@code T}. The returned members injector will not be valid until the main
 {@link Injector} has been created. The members injector will throw an {@code
 IllegalStateException} if you try to use it beforehand.

 @param typeLiteral type to get members injector for
 @since 2.0]]>
      </doc>
    </method>
    <method name="getMembersInjector" return="com.google.inject.MembersInjector"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="java.lang.Class"/>
      <doc>
      <![CDATA[Returns the members injector used to inject dependencies into methods and fields on instances
 of the given type {@code T}. The returned members injector will not be valid until the main
 {@link Injector} has been created. The members injector will throw an {@code
 IllegalStateException} if you try to use it beforehand.

 @param type type to get members injector for
 @since 2.0]]>
      </doc>
    </method>
    <method name="convertToTypes"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="typeMatcher" type="com.google.inject.matcher.Matcher"/>
      <param name="converter" type="com.google.inject.spi.TypeConverter"/>
      <doc>
      <![CDATA[Binds a type converter. The injector will use the given converter to convert string constants
 to matching types as needed.

 @param typeMatcher matches types the converter can handle
 @param converter converts values
 @since 2.0]]>
      </doc>
    </method>
    <method name="bindListener"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="typeMatcher" type="com.google.inject.matcher.Matcher"/>
      <param name="listener" type="com.google.inject.spi.TypeListener"/>
      <doc>
      <![CDATA[Registers a listener for injectable types. Guice will notify the listener when it encounters
 injectable types matched by the given type matcher.

 @param typeMatcher that matches injectable types the listener should be notified of
 @param listener for injectable types matched by typeMatcher
 @since 2.0]]>
      </doc>
    </method>
    <method name="bindListener"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="bindingMatcher" type="com.google.inject.matcher.Matcher"/>
      <param name="listeners" type="com.google.inject.spi.ProvisionListener[]"/>
      <doc>
      <![CDATA[Registers listeners for provisioned objects. Guice will notify the listeners just before and
 after the object is provisioned. Provisioned objects that are also injectable (everything
 except objects provided through Providers) can also be notified through TypeListeners
 registered in {@link #bindListener}.

 @param bindingMatcher that matches bindings of provisioned objects the listener should be
     notified of
 @param listeners for provisioned objects matched by bindingMatcher
 @since 4.0]]>
      </doc>
    </method>
    <method name="withSource" return="com.google.inject.Binder"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="source" type="java.lang.Object"/>
      <doc>
      <![CDATA[Returns a binder that uses {@code source} as the reference location for configuration errors.
 This is typically a {@link StackTraceElement} for {@code .java} source but it could any binding
 source, such as the path to a {@code .properties} file.

 @param source any object representing the source location and has a concise {@link
     Object#toString() toString()} value
 @return a binder that shares its configuration with this binder
 @since 2.0]]>
      </doc>
    </method>
    <method name="skipSources" return="com.google.inject.Binder"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="classesToSkip" type="java.lang.Class[]"/>
      <doc>
      <![CDATA[Returns a binder that skips {@code classesToSkip} when identify the calling code. The caller's
 {@link StackTraceElement} is used to locate the source of configuration errors.

 @param classesToSkip library classes that create bindings on behalf of their clients.
 @return a binder that shares its configuration with this binder.
 @since 2.0]]>
      </doc>
    </method>
    <method name="newPrivateBinder" return="com.google.inject.PrivateBinder"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a new private child environment for bindings and other configuration. The returned
 binder can be used to add and configuration information in this environment. See {@link
 PrivateModule} for details.

 @return a binder that inherits configuration from this binder. Only exposed configuration on
     the returned binder will be visible to this binder.
 @since 2.0]]>
      </doc>
    </method>
    <method name="requireExplicitBindings"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Instructs the Injector that bindings must be listed in a Module in order to be injected.
 Classes that are not explicitly bound in a module cannot be injected. Bindings created through
 a linked binding (<code>bind(Foo.class).to(FooImpl.class)</code>) are allowed, but the implicit
 binding (<code>FooImpl</code>) cannot be directly injected unless it is also explicitly bound (
 <code>bind(FooImpl.class)</code>).

 <p>Tools can still retrieve bindings for implicit bindings (bindings created through a linked
 binding) if explicit bindings are required, however {@link Binding#getProvider} will fail.

 <p>By default, explicit bindings are not required.

 <p>If a parent injector requires explicit bindings, then all child injectors (and private
 modules within that injector) also require explicit bindings. If a parent does not require
 explicit bindings, a child injector or private module may optionally declare itself as
 requiring explicit bindings. If it does, the behavior is limited only to that child or any
 grandchildren. No siblings of the child will require explicit bindings.

 <p>In the absence of an explicit binding for the target, linked bindings in child injectors
 create a binding for the target in the parent. Since this behavior can be surprising, it causes
 an error instead if explicit bindings are required. To avoid this error, add an explicit
 binding for the target, either in the child or the parent.

 @since 3.0]]>
      </doc>
    </method>
    <method name="disableCircularProxies"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Prevents Guice from injecting dependencies that form a cycle, unless broken by a {@link
 Provider}. By default, circular dependencies are not disabled.

 <p>If a parent injector disables circular dependencies, then all child injectors (and private
 modules within that injector) also disable circular dependencies. If a parent does not disable
 circular dependencies, a child injector or private module may optionally declare itself as
 disabling circular dependencies. If it does, the behavior is limited only to that child or any
 grandchildren. No siblings of the child will disable circular dependencies.

 @since 3.0]]>
      </doc>
    </method>
    <method name="requireAtInjectOnConstructors"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Requires that a {@literal @}{@link Inject} annotation exists on a constructor in order for
 Guice to consider it an eligible injectable class. By default, Guice will inject classes that
 have a no-args constructor if no {@literal @}{@link Inject} annotation exists on any
 constructor.

 <p>If the class is bound using {@link LinkedBindingBuilder#toConstructor}, Guice will still
 inject that constructor regardless of annotations.

 @since 4.0]]>
      </doc>
    </method>
    <method name="requireExactBindingAnnotations"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Requires that Guice finds an exactly matching binding annotation. This disables the error-prone
 feature in Guice where it can substitute a binding for <code>{@literal @}Named Foo</code> when
 attempting to inject <code>{@literal @}Named("foo") Foo</code>.

 @since 4.0]]>
      </doc>
    </method>
    <method name="scanModulesForAnnotatedMethods"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="scanner" type="com.google.inject.spi.ModuleAnnotatedMethodScanner"/>
      <doc>
      <![CDATA[Adds a scanner that will look in all installed modules for annotations the scanner can parse,
 and binds them like {@literal @}Provides methods. Scanners apply to all modules installed in
 the injector. Scanners installed in child injectors or private modules do not impact modules in
 siblings or parents, however scanners installed in parents do apply to all child injectors and
 private modules.

 @since 4.0]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Collects configuration information (primarily <i>bindings</i>) which will be used to create an
 {@link Injector}. Guice provides this object to your application's {@link Module} implementors so
 they may each contribute their own bindings and other registrations.

 <h3>The Guice Binding EDSL</h3>

 Guice uses an <i>embedded domain-specific language</i>, or EDSL, to help you create bindings
 simply and readably. This approach is great for overall usability, but it does come with a small
 cost: <b>it is difficult to learn how to use the Binding EDSL by reading method-level
 javadocs</b>. Instead, you should consult the series of examples below. To save space, these
 examples omit the opening {@code binder}, just as you will if your module extends {@link
 AbstractModule}.

 <pre>
     bind(ServiceImpl.class);</pre>

 This statement does essentially nothing; it "binds the {@code ServiceImpl} class to itself" and
 does not change Guice's default behavior. You may still want to use this if you prefer your
 {@link Module} class to serve as an explicit <i>manifest</i> for the services it provides. Also,
 in rare cases, Guice may be unable to validate a binding at injector creation time unless it is
 given explicitly.

 <pre>
     bind(Service.class).to(ServiceImpl.class);</pre>

 Specifies that a request for a {@code Service} instance with no binding annotations should be
 treated as if it were a request for a {@code ServiceImpl} instance. This <i>overrides</i> the
 function of any {@link ImplementedBy @ImplementedBy} or {@link ProvidedBy @ProvidedBy}
 annotations found on {@code Service}, since Guice will have already "moved on" to {@code
 ServiceImpl} before it reaches the point when it starts looking for these annotations.

 <pre>
     bind(Service.class).toProvider(ServiceProvider.class);</pre>

 In this example, {@code ServiceProvider} must extend or implement {@code Provider<Service>}. This
 binding specifies that Guice should resolve an unannotated injection request for {@code Service}
 by first resolving an instance of {@code ServiceProvider} in the regular way, then calling {@link
 Provider#get get()} on the resulting Provider instance to obtain the {@code Service} instance.

 <p>The {@link Provider} you use here does not have to be a "factory"; that is, a provider which
 always <i>creates</i> each instance it provides. However, this is generally a good practice to
 follow. You can then use Guice's concept of {@link Scope scopes} to guide when creation should
 happen -- "letting Guice work for you".

 <pre>
     bind(Service.class).annotatedWith(Red.class).to(ServiceImpl.class);</pre>

 Like the previous example, but only applies to injection requests that use the binding annotation
 {@code @Red}. If your module also includes bindings for particular <i>values</i> of the
 {@code @Red} annotation (see below), then this binding will serve as a "catch-all" for any values
 of {@code @Red} that have no exact match in the bindings.

 <pre>
     bind(ServiceImpl.class).in(Singleton.class);
     // or, alternatively
     bind(ServiceImpl.class).in(Scopes.SINGLETON);</pre>

 Either of these statements places the {@code ServiceImpl} class into singleton scope. Guice will
 create only one instance of {@code ServiceImpl} and will reuse it for all injection requests of
 this type. Note that it is still possible to bind another instance of {@code ServiceImpl} if the
 second binding is qualified by an annotation as in the previous example. Guice is not overly
 concerned with <i>preventing</i> you from creating multiple instances of your "singletons", only
 with <i>enabling</i> your application to share only one instance if that's all you tell Guice you
 need.

 <p><b>Note:</b> a scope specified in this way <i>overrides</i> any scope that was specified with
 an annotation on the {@code ServiceImpl} class.

 <p>Besides {@link Singleton}/{@link Scopes#SINGLETON}, there are servlet-specific scopes
 available in {@code com.google.inject.servlet.ServletScopes}, and your Modules can contribute
 their own custom scopes for use here as well.

 <pre>{@code
 bind(new TypeLiteral<PaymentService<CreditCard>>() {})
     .to(CreditCardPaymentService.class);
 }</pre>

 This admittedly odd construct is the way to bind a parameterized type. It tells Guice how to
 honor an injection request for an element of type {@code PaymentService<CreditCard>}. The class
 {@code CreditCardPaymentService} must implement the {@code PaymentService<CreditCard>} interface.
 Guice cannot currently bind or inject a generic type, such as {@code Set<E>}; all type parameters
 must be fully specified.

 <pre>
     bind(Service.class).toInstance(new ServiceImpl());
     // or, alternatively
     bind(Service.class).toInstance(SomeLegacyRegistry.getService());</pre>

 In this example, your module itself, <i>not Guice</i>, takes responsibility for obtaining a
 {@code ServiceImpl} instance, then asks Guice to always use this single instance to fulfill all
 {@code Service} injection requests. When the {@link Injector} is created, it will automatically
 perform field and method injection for this instance, but any injectable constructor on {@code
 ServiceImpl} is simply ignored. Note that using this approach results in "eager loading" behavior
 that you can't control.

 <pre>
     bindConstant().annotatedWith(ServerHost.class).to(args[0]);</pre>

 Sets up a constant binding. Constant injections must always be annotated. When a constant
 binding's value is a string, it is eligible for conversion to all primitive types, to {@link
 Enum#valueOf(Class, String) all enums}, and to {@link Class#forName class literals}. Conversions
 for other types can be configured using {@link #convertToTypes(Matcher, TypeConverter)
 convertToTypes()}.

 <pre>
   {@literal @}Color("red") Color red; // A member variable (field)
    . . .
     red = MyModule.class.getDeclaredField("red").getAnnotation(Color.class);
     bind(Service.class).annotatedWith(red).to(RedService.class);</pre>

 If your binding annotation has parameters you can apply different bindings to different specific
 values of your annotation. Getting your hands on the right instance of the annotation is a bit of
 a pain -- one approach, shown above, is to apply a prototype annotation to a field in your module
 class, so that you can read this annotation instance and give it to Guice.

 <pre>
     bind(Service.class)
         .annotatedWith(Names.named("blue"))
         .to(BlueService.class);</pre>

 Differentiating by names is a common enough use case that we provided a standard annotation,
 {@link com.google.inject.name.Named @Named}. Because of Guice's library support, binding by name
 is quite easier than in the arbitrary binding annotation case we just saw. However, remember that
 these names will live in a single flat namespace with all the other names used in your
 application.

 <pre>{@code
 Constructor<T> loneCtor = getLoneCtorFromServiceImplViaReflection();
 bind(ServiceImpl.class)
     .toConstructor(loneCtor);
 }</pre>

 In this example, we directly tell Guice which constructor to use in a concrete class
 implementation. It means that we do not need to place {@literal @}Inject on any of the
 constructors and that Guice treats the provided constructor as though it were annotated so. It is
 useful for cases where you cannot modify existing classes and is a bit simpler than using a
 {@link Provider}.

 <p>The above list of examples is far from exhaustive. If you can think of how the concepts of one
 example might coexist with the concepts from another, you can most likely weave the two together.
 If the two concepts make no sense with each other, you most likely won't be able to do it. In a
 few cases Guice will let something bogus slip by, and will then inform you of the problems at
 runtime, as soon as you try to create your Injector.

 <p>The other methods of Binder such as {@link #bindScope}, {@link #bindInterceptor}, {@link
 #install}, {@link #requestStaticInjection}, {@link #addError} and {@link #currentStage} are not
 part of the Binding EDSL; you can learn how to use these in the usual way, from the method
 documentation.

 @author crazybob@google.com (Bob Lee)
 @author jessewilson@google.com (Jesse Wilson)
 @author kevinb@google.com (Kevin Bourrillion)]]>
    </doc>
  </interface>
  <!-- end interface com.google.inject.Binder -->
  <!-- start interface com.google.inject.Binding -->
  <interface name="Binding"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.inject.spi.Element"/>
    <method name="getKey" return="com.google.inject.Key"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the key for this binding.]]>
      </doc>
    </method>
    <method name="getProvider" return="com.google.inject.Provider"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the scoped provider guice uses to fulfill requests for this binding.

 @throws UnsupportedOperationException when invoked on a {@link Binding} created via {@link
     com.google.inject.spi.Elements#getElements}. This method is only supported on {@link
     Binding}s returned from an injector.]]>
      </doc>
    </method>
    <method name="acceptTargetVisitor" return="java.lang.Object"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="visitor" type="com.google.inject.spi.BindingTargetVisitor"/>
      <doc>
      <![CDATA[Accepts a target visitor. Invokes the visitor method specific to this binding's target.

 @param visitor to call back on
 @since 2.0]]>
      </doc>
    </method>
    <method name="acceptScopingVisitor" return="java.lang.Object"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="visitor" type="com.google.inject.spi.BindingScopingVisitor"/>
      <doc>
      <![CDATA[Accepts a scoping visitor. Invokes the visitor method specific to this binding's scoping.

 @param visitor to call back on
 @since 2.0]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A mapping from a {@link Key} to the strategy for getting instances of the type. This interface is
 part of the introspection API and is intended primarily for use by tools.

 <p>Bindings are created in several ways:

 <ul>
   <li>Explicitly in a module, via {@code bind()} and {@code bindConstant()} statements:
       <pre>
     bind(Service.class).annotatedWith(Red.class).to(ServiceImpl.class);
     bindConstant().annotatedWith(ServerHost.class).to(args[0]);</pre>
   <li>Implicitly by the Injector by following a type's {@link ImplementedBy pointer} {@link
       ProvidedBy annotations} or by using its {@link Inject annotated} or default constructor.
   <li>By converting a bound instance to a different type.
   <li>For {@link Provider providers}, by delegating to the binding for the provided type.
 </ul>

 <p>They exist on both modules and on injectors, and their behaviour is different for each:

 <ul>
   <li><strong>Module bindings</strong> are incomplete and cannot be used to provide instances.
       This is because the applicable scopes and interceptors may not be known until an injector
       is created. From a tool's perspective, module bindings are like the injector's source code.
       They can be inspected or rewritten, but this analysis must be done statically.
   <li><strong>Injector bindings</strong> are complete and valid and can be used to provide
       instances. From a tools' perspective, injector bindings are like reflection for an
       injector. They have full runtime information, including the complete graph of injections
       necessary to satisfy a binding.
 </ul>

 @param <T> the bound type. The injected is always assignable to this type.
 @author crazybob@google.com (Bob Lee)
 @author jessewilson@google.com (Jesse Wilson)]]>
    </doc>
  </interface>
  <!-- end interface com.google.inject.Binding -->
  <!-- start interface com.google.inject.BindingAnnotation -->
  <interface name="BindingAnnotation"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.lang.annotation.Annotation"/>
    <doc>
    <![CDATA[Annotates annotations which are used for binding. Only one such annotation may apply to a single
 injection point. You must also annotate binder annotations with {@code @Retention(RUNTIME)}. For
 example:

 <pre>
   {@code @}Retention(RUNTIME)
   {@code @}Target({ FIELD, PARAMETER, METHOD })
   {@code @}BindingAnnotation
   public {@code @}interface Transactional {}
 </pre>

 @author crazybob@google.com (Bob Lee)]]>
    </doc>
  </interface>
  <!-- end interface com.google.inject.BindingAnnotation -->
  <!-- start class com.google.inject.ConfigurationException -->
  <class name="ConfigurationException" extends="java.lang.RuntimeException"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="ConfigurationException" type="java.lang.Iterable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a ConfigurationException containing {@code messages}.]]>
      </doc>
    </constructor>
    <method name="withPartialValue" return="com.google.inject.ConfigurationException"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="partialValue" type="java.lang.Object"/>
      <doc>
      <![CDATA[Returns a copy of this configuration exception with the specified partial value.]]>
      </doc>
    </method>
    <method name="getErrorMessages" return="java.util.Collection"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns messages for the errors that caused this exception.]]>
      </doc>
    </method>
    <method name="getPartialValue" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a value that was only partially computed due to this exception. The caller can use this
 while collecting additional configuration problems.

 @return the partial value, or {@code null} if none was set. The type of the partial value is
     specified by the throwing method.]]>
      </doc>
    </method>
    <method name="getMessage" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Thrown when a programming error such as a misplaced annotation, illegal binding, or unsupported
 scope is found. Clients should catch this exception, log it, and stop execution.

 @author jessewilson@google.com (Jesse Wilson)
 @since 2.0]]>
    </doc>
  </class>
  <!-- end class com.google.inject.ConfigurationException -->
  <!-- start class com.google.inject.CreationException -->
  <class name="CreationException" extends="java.lang.RuntimeException"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="CreationException" type="java.util.Collection"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a CreationException containing {@code messages}.]]>
      </doc>
    </constructor>
    <method name="getErrorMessages" return="java.util.Collection"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns messages for the errors that caused this exception.]]>
      </doc>
    </method>
    <method name="getMessage" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Thrown when errors occur while creating a {@link Injector}. Includes a list of encountered
 errors. Clients should catch this exception, log it, and stop execution.

 @author crazybob@google.com (Bob Lee)]]>
    </doc>
  </class>
  <!-- end class com.google.inject.CreationException -->
  <!-- start interface com.google.inject.Exposed -->
  <interface name="Exposed"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.lang.annotation.Annotation"/>
    <doc>
    <![CDATA[Acccompanies a {@literal @}{@link com.google.inject.Provides Provides} method annotation in a
 private module to indicate that the provided binding is exposed.

 @author jessewilson@google.com (Jesse Wilson)
 @since 2.0]]>
    </doc>
  </interface>
  <!-- end interface com.google.inject.Exposed -->
  <!-- start class com.google.inject.Guice -->
  <class name="Guice" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="createInjector" return="com.google.inject.Injector"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="modules" type="com.google.inject.Module[]"/>
      <doc>
      <![CDATA[Creates an injector for the given set of modules. This is equivalent to calling {@link
 #createInjector(Stage, Module...)} with Stage.DEVELOPMENT.

 @throws CreationException if one or more errors occur during injector construction]]>
      </doc>
    </method>
    <method name="createInjector" return="com.google.inject.Injector"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="modules" type="java.lang.Iterable"/>
      <doc>
      <![CDATA[Creates an injector for the given set of modules. This is equivalent to calling {@link
 #createInjector(Stage, Iterable)} with Stage.DEVELOPMENT.

 @throws CreationException if one or more errors occur during injector creation]]>
      </doc>
    </method>
    <method name="createInjector" return="com.google.inject.Injector"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="stage" type="com.google.inject.Stage"/>
      <param name="modules" type="com.google.inject.Module[]"/>
      <doc>
      <![CDATA[Creates an injector for the given set of modules, in a given development stage.

 @throws CreationException if one or more errors occur during injector creation.]]>
      </doc>
    </method>
    <method name="createInjector" return="com.google.inject.Injector"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="stage" type="com.google.inject.Stage"/>
      <param name="modules" type="java.lang.Iterable"/>
      <doc>
      <![CDATA[Creates an injector for the given set of modules, in a given development stage.

 @throws CreationException if one or more errors occur during injector construction]]>
      </doc>
    </method>
    <doc>
    <![CDATA[The entry point to the Guice framework. Creates {@link Injector}s from {@link Module}s.

 <p>Guice supports a model of development that draws clear boundaries between APIs,
 Implementations of these APIs, Modules which configure these implementations, and finally
 Applications which consist of a collection of Modules. It is the Application, which typically
 defines your {@code main()} method, that bootstraps the Guice Injector using the {@code Guice}
 class, as in this example:

 <pre>
     public class FooApplication {
       public static void main(String[] args) {
         Injector injector = Guice.createInjector(
             new ModuleA(),
             new ModuleB(),
             . . .
             new FooApplicationFlagsModule(args)
         );

         // Now just bootstrap the application and you're done
         FooStarter starter = injector.getInstance(FooStarter.class);
         starter.runApplication();
       }
     }
 </pre>]]>
    </doc>
  </class>
  <!-- end class com.google.inject.Guice -->
  <!-- start interface com.google.inject.ImplementedBy -->
  <interface name="ImplementedBy"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.lang.annotation.Annotation"/>
    <method name="value" return="java.lang.Class"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The implementation type.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A pointer to the default implementation of a type.

 @author crazybob@google.com (Bob Lee)]]>
    </doc>
  </interface>
  <!-- end interface com.google.inject.ImplementedBy -->
  <!-- start interface com.google.inject.Inject -->
  <interface name="Inject"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.lang.annotation.Annotation"/>
    <method name="optional" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[If true, and the appropriate binding is not found, the Injector will skip injection of this
 method or field rather than produce an error. When applied to a field, any default value
 already assigned to the field will remain (guice will not actively null out the field). When
 applied to a method, the method will only be invoked if bindings for <i>all</i> parameters are
 found. When applied to a constructor, an error will result upon Injector creation.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Annotates members of your implementation class (constructors, methods and fields) into which the
 {@link Injector} should inject values. The Injector fulfills injection requests for:

 <ul>
   <li>Every instance it constructs. The class being constructed must have exactly one of its
       constructors marked with {@code @Inject} or must have a constructor taking no parameters.
       The Injector then proceeds to perform field and method injections.
   <li>Pre-constructed instances passed to {@link Injector#injectMembers}, {@link
       com.google.inject.binder.LinkedBindingBuilder#toInstance(Object)} and {@link
       com.google.inject.binder.LinkedBindingBuilder#toProvider(javax.inject.Provider)}. In this
       case all constructors are, of course, ignored.
   <li>Static fields and methods of classes which any {@link Module} has specifically requested
       static injection for, using {@link Binder#requestStaticInjection}.
 </ul>

 In all cases, a member can be injected regardless of its Java access specifier (private, default,
 protected, public).

 @author crazybob@google.com (Bob Lee)]]>
    </doc>
  </interface>
  <!-- end interface com.google.inject.Inject -->
  <!-- start interface com.google.inject.Injector -->
  <interface name="Injector"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="injectMembers"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="instance" type="java.lang.Object"/>
      <doc>
      <![CDATA[Injects dependencies into the fields and methods of {@code instance}. Ignores the presence or
 absence of an injectable constructor.

 <p>Whenever Guice creates an instance, it performs this injection automatically (after first
 performing constructor injection), so if you're able to let Guice create all your objects for
 you, you'll never need to use this method.

 @param instance to inject members on
 @see Binder#getMembersInjector(Class) for a preferred alternative that supports checks before
     run time]]>
      </doc>
    </method>
    <method name="getMembersInjector" return="com.google.inject.MembersInjector"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="typeLiteral" type="com.google.inject.TypeLiteral"/>
      <doc>
      <![CDATA[Returns the members injector used to inject dependencies into methods and fields on instances
 of the given type {@code T}.

 @param typeLiteral type to get members injector for
 @see Binder#getMembersInjector(TypeLiteral) for an alternative that offers up front error
     detection
 @since 2.0]]>
      </doc>
    </method>
    <method name="getMembersInjector" return="com.google.inject.MembersInjector"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="java.lang.Class"/>
      <doc>
      <![CDATA[Returns the members injector used to inject dependencies into methods and fields on instances
 of the given type {@code T}. When feasible, use {@link Binder#getMembersInjector(TypeLiteral)}
 instead to get increased up front error detection.

 @param type type to get members injector for
 @see Binder#getMembersInjector(Class) for an alternative that offers up front error detection
 @since 2.0]]>
      </doc>
    </method>
    <method name="getBindings" return="java.util.Map"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns this injector's <strong>explicit</strong> bindings.

 <p>The returned map does not include bindings inherited from a {@link #getParent() parent
 injector}, should one exist. The returned map is guaranteed to iterate (for example, with its
 {@link Map#entrySet()} iterator) in the order of insertion. In other words, the order in which
 bindings appear in user Modules.

 <p>This method is part of the Guice SPI and is intended for use by tools and extensions.]]>
      </doc>
    </method>
    <method name="getAllBindings" return="java.util.Map"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a snapshot of this injector's bindings, <strong>both explicit and
 just-in-time</strong>. The returned map is immutable; it contains only the bindings that were
 present when {@code getAllBindings()} was invoked. Just-in-time bindings are only present if
 they have been requested at least once. Subsequent calls may return a map with additional
 just-in-time bindings.

 <p>The returned map does not include bindings inherited from a {@link #getParent() parent
 injector}, should one exist.

 <p>This method is part of the Guice SPI and is intended for use by tools and extensions.

 @since 3.0]]>
      </doc>
    </method>
    <method name="getBinding" return="com.google.inject.Binding"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="com.google.inject.Key"/>
      <doc>
      <![CDATA[Returns the binding for the given injection key. This will be an explicit bindings if the key
 was bound explicitly by a module, or an implicit binding otherwise. The implicit binding will
 be created if necessary.

 <p>This method is part of the Guice SPI and is intended for use by tools and extensions.

 @throws ConfigurationException if this injector cannot find or create the binding.]]>
      </doc>
    </method>
    <method name="getBinding" return="com.google.inject.Binding"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="java.lang.Class"/>
      <doc>
      <![CDATA[Returns the binding for the given type. This will be an explicit bindings if the injection key
 was bound explicitly by a module, or an implicit binding otherwise. The implicit binding will
 be created if necessary.

 <p>This method is part of the Guice SPI and is intended for use by tools and extensions.

 @throws ConfigurationException if this injector cannot find or create the binding.
 @since 2.0]]>
      </doc>
    </method>
    <method name="getExistingBinding" return="com.google.inject.Binding"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="com.google.inject.Key"/>
      <doc>
      <![CDATA[Returns the binding if it already exists, or null if does not exist. Unlike {@link
 #getBinding(Key)}, this does not attempt to create just-in-time bindings for keys that aren't
 bound.

 <p>This method is part of the Guice SPI and is intended for use by tools and extensions.

 @since 3.0]]>
      </doc>
    </method>
    <method name="findBindingsByType" return="java.util.List"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="com.google.inject.TypeLiteral"/>
      <doc>
      <![CDATA[Returns all explicit bindings for {@code type}.

 <p>This method is part of the Guice SPI and is intended for use by tools and extensions.]]>
      </doc>
    </method>
    <method name="getProvider" return="com.google.inject.Provider"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="com.google.inject.Key"/>
      <doc>
      <![CDATA[Returns the provider used to obtain instances for the given injection key. When feasible, avoid
 using this method, in favor of having Guice inject your dependencies ahead of time.

 @throws ConfigurationException if this injector cannot find or create the provider.
 @see Binder#getProvider(Key) for an alternative that offers up front error detection]]>
      </doc>
    </method>
    <method name="getProvider" return="com.google.inject.Provider"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="java.lang.Class"/>
      <doc>
      <![CDATA[Returns the provider used to obtain instances for the given type. When feasible, avoid using
 this method, in favor of having Guice inject your dependencies ahead of time.

 @throws ConfigurationException if this injector cannot find or create the provider.
 @see Binder#getProvider(Class) for an alternative that offers up front error detection]]>
      </doc>
    </method>
    <method name="getInstance" return="java.lang.Object"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="com.google.inject.Key"/>
      <doc>
      <![CDATA[Returns the appropriate instance for the given injection key; equivalent to {@code
 getProvider(key).get()}. When feasible, avoid using this method, in favor of having Guice
 inject your dependencies ahead of time.

 @throws ConfigurationException if this injector cannot find or create the provider.
 @throws ProvisionException if there was a runtime failure while providing an instance.]]>
      </doc>
    </method>
    <method name="getInstance" return="java.lang.Object"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="java.lang.Class"/>
      <doc>
      <![CDATA[Returns the appropriate instance for the given injection type; equivalent to {@code
 getProvider(type).get()}. When feasible, avoid using this method, in favor of having Guice
 inject your dependencies ahead of time.

 @throws ConfigurationException if this injector cannot find or create the provider.
 @throws ProvisionException if there was a runtime failure while providing an instance.]]>
      </doc>
    </method>
    <method name="getParent" return="com.google.inject.Injector"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns this injector's parent, or {@code null} if this is a top-level injector.

 @since 2.0]]>
      </doc>
    </method>
    <method name="createChildInjector" return="com.google.inject.Injector"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="modules" type="java.lang.Iterable"/>
      <doc>
      <![CDATA[Returns a new injector that inherits all state from this injector. All bindings, scopes,
 interceptors and type converters are inherited -- they are visible to the child injector.
 Elements of the child injector are not visible to its parent.

 <p>Just-in-time bindings created for child injectors will be created in an ancestor injector
 whenever possible. This allows for scoped instances to be shared between injectors. Use
 explicit bindings to prevent bindings from being shared with the parent injector. Optional
 injections in just-in-time bindings (created in the parent injector) may be silently ignored if
 the optional dependencies are from the child injector.

 <p>No key may be bound by both an injector and one of its ancestors. This includes just-in-time
 bindings. The lone exception is the key for {@code Injector.class}, which is bound by each
 injector to itself.

 @since 2.0]]>
      </doc>
    </method>
    <method name="createChildInjector" return="com.google.inject.Injector"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="modules" type="com.google.inject.Module[]"/>
      <doc>
      <![CDATA[Returns a new injector that inherits all state from this injector. All bindings, scopes,
 interceptors and type converters are inherited -- they are visible to the child injector.
 Elements of the child injector are not visible to its parent.

 <p>Just-in-time bindings created for child injectors will be created in an ancestor injector
 whenever possible. This allows for scoped instances to be shared between injectors. Use
 explicit bindings to prevent bindings from being shared with the parent injector.

 <p>No key may be bound by both an injector and one of its ancestors. This includes just-in-time
 bindings. The lone exception is the key for {@code Injector.class}, which is bound by each
 injector to itself.

 @since 2.0]]>
      </doc>
    </method>
    <method name="getScopeBindings" return="java.util.Map"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a map containing all scopes in the injector. The maps keys are scoping annotations like
 {@code Singleton.class}, and the values are scope instances, such as {@code Scopes.SINGLETON}.
 The returned map is immutable.

 <p>This method is part of the Guice SPI and is intended for use by tools and extensions.

 @since 3.0]]>
      </doc>
    </method>
    <method name="getTypeConverterBindings" return="java.util.Set"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a set containing all type converter bindings in the injector. The returned set is
 immutable.

 <p>This method is part of the Guice SPI and is intended for use by tools and extensions.

 @since 3.0]]>
      </doc>
    </method>
    <method name="getElements" return="java.util.List"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the elements that make up this injector. Note that not all kinds of elements are
 returned.

 <p>The returned list does not include elements inherited from a {@link #getParent() parent
 injector}, should one exist.

 <p>The returned list is immutable; it contains only the elements that were present when {@link
 #getElements} was invoked. Subsequent calls may return a list with additional elements.

 <p>The returned list does not include data inherited from a {@link #getParent() parent
 injector}, should one exist.

 <p>This method is part of the Guice SPI and is intended for use by tools and extensions.

 @since 4.2.3]]>
      </doc>
    </method>
    <method name="getAllMembersInjectorInjectionPoints" return="java.util.Map"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the injection points created for calls to {@link #getMembersInjector} (either directly
 or indirectly, e.g. through {@link #injectMembers}.

 <p>This excludes any injection points from elements (which are accessible from each element via
 the SPI), unless {@link #getMembersInjector} or {@link #injectMembers} were also called for the
 same key.

 <p>The returned multimap does not include data inherited from a {@link #getParent() parent
 injector}, should one exist.

 <p>This method is part of the Guice SPI and is intended for use by tools and extensions.

 @since 4.2.3]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Builds the graphs of objects that make up your application. The injector tracks the dependencies
 for each type and uses bindings to inject them. This is the core of Guice, although you rarely
 interact with it directly. This "behind-the-scenes" operation is what distinguishes dependency
 injection from its cousin, the service locator pattern.

 <p>Contains several default bindings:

 <ul>
   <li>This {@link Injector} instance itself
   <li>A {@code Provider<T>} for each binding of type {@code T}
   <li>The {@link java.util.logging.Logger} for the class being injected
   <li>The {@link Stage} in which the Injector was created
 </ul>

 Injectors are created using the facade class {@link Guice}.

 <p>An injector can also {@link #injectMembers(Object) inject the dependencies} of
 already-constructed instances. This can be used to interoperate with objects created by other
 frameworks or services.

 <p>Injectors can be {@link #createChildInjector(Iterable) hierarchical}. Child injectors inherit
 the configuration of their parent injectors, but the converse does not hold.

 <p>The injector's {@link #getBindings() internal bindings} are available for introspection. This
 enables tools and extensions to operate on an injector reflectively.

 @author crazybob@google.com (Bob Lee)
 @author jessewilson@google.com (Jesse Wilson)]]>
    </doc>
  </interface>
  <!-- end interface com.google.inject.Injector -->
  <!-- start class com.google.inject.Key -->
  <class name="Key" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="Key" type="java.lang.Class"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a new key. Derives the type from this class's type parameter.

 <p>Clients create an empty anonymous subclass. Doing so embeds the type parameter in the
 anonymous class's type hierarchy so we can reconstitute it at runtime despite erasure.

 <p>Example usage for a binding of type {@code Foo} annotated with {@code @Bar}:

 <p>{@code new Key<Foo>(Bar.class) {}}.]]>
      </doc>
    </constructor>
    <constructor name="Key" type="java.lang.annotation.Annotation"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a new key. Derives the type from this class's type parameter.

 <p>Clients create an empty anonymous subclass. Doing so embeds the type parameter in the
 anonymous class's type hierarchy so we can reconstitute it at runtime despite erasure.

 <p>Example usage for a binding of type {@code Foo} annotated with {@code @Bar}:

 <p>{@code new Key<Foo>(new Bar()) {}}.]]>
      </doc>
    </constructor>
    <constructor name="Key"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a new key. Derives the type from this class's type parameter.

 <p>Clients create an empty anonymous subclass. Doing so embeds the type parameter in the
 anonymous class's type hierarchy so we can reconstitute it at runtime despite erasure.

 <p>Example usage for a binding of type {@code Foo}:

 <p>{@code new Key<Foo>() {}}.]]>
      </doc>
    </constructor>
    <method name="getTypeLiteral" return="com.google.inject.TypeLiteral"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the key type.]]>
      </doc>
    </method>
    <method name="getAnnotationType" return="java.lang.Class"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the annotation type. Will be {@code null} if this key lacks an annotation.]]>
      </doc>
    </method>
    <method name="getAnnotation" return="java.lang.annotation.Annotation"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the annotation instance if available. Will be {@code null} if this key lacks an annotation
 <i>or</i> the key was constructed with a {@code Class<Annotation>}.

 <p><b>Warning:</b> this can return null even if this key is annotated. To check whether a
 {@code Key} has an annotation use {@link #hasAnnotationType} instead.]]>
      </doc>
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="o" type="java.lang.Object"/>
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="get" return="com.google.inject.Key"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="java.lang.Class"/>
      <doc>
      <![CDATA[Gets a key for an injection type.]]>
      </doc>
    </method>
    <method name="get" return="com.google.inject.Key"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="java.lang.Class"/>
      <param name="annotationType" type="java.lang.Class"/>
      <doc>
      <![CDATA[Gets a key for an injection type and an annotation type.]]>
      </doc>
    </method>
    <method name="get" return="com.google.inject.Key"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="java.lang.Class"/>
      <param name="annotation" type="java.lang.annotation.Annotation"/>
      <doc>
      <![CDATA[Gets a key for an injection type and an annotation.]]>
      </doc>
    </method>
    <method name="get" return="com.google.inject.Key"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="java.lang.reflect.Type"/>
      <doc>
      <![CDATA[Gets a key for an injection type.]]>
      </doc>
    </method>
    <method name="get" return="com.google.inject.Key"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="java.lang.reflect.Type"/>
      <param name="annotationType" type="java.lang.Class"/>
      <doc>
      <![CDATA[Gets a key for an injection type and an annotation type.]]>
      </doc>
    </method>
    <method name="get" return="com.google.inject.Key"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="java.lang.reflect.Type"/>
      <param name="annotation" type="java.lang.annotation.Annotation"/>
      <doc>
      <![CDATA[Gets a key for an injection type and an annotation.]]>
      </doc>
    </method>
    <method name="get" return="com.google.inject.Key"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="typeLiteral" type="com.google.inject.TypeLiteral"/>
      <doc>
      <![CDATA[Gets a key for an injection type.]]>
      </doc>
    </method>
    <method name="get" return="com.google.inject.Key"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="typeLiteral" type="com.google.inject.TypeLiteral"/>
      <param name="annotationType" type="java.lang.Class"/>
      <doc>
      <![CDATA[Gets a key for an injection type and an annotation type.]]>
      </doc>
    </method>
    <method name="get" return="com.google.inject.Key"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="typeLiteral" type="com.google.inject.TypeLiteral"/>
      <param name="annotation" type="java.lang.annotation.Annotation"/>
      <doc>
      <![CDATA[Gets a key for an injection type and an annotation.]]>
      </doc>
    </method>
    <method name="ofType" return="com.google.inject.Key"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="java.lang.Class"/>
      <doc>
      <![CDATA[Returns a new key of the specified type with the same annotation as this key.

 @since 3.0]]>
      </doc>
    </method>
    <method name="ofType" return="com.google.inject.Key"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="java.lang.reflect.Type"/>
      <doc>
      <![CDATA[Returns a new key of the specified type with the same annotation as this key.

 @since 3.0]]>
      </doc>
    </method>
    <method name="ofType" return="com.google.inject.Key"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="com.google.inject.TypeLiteral"/>
      <doc>
      <![CDATA[Returns a new key of the specified type with the same annotation as this key.

 @since 3.0]]>
      </doc>
    </method>
    <method name="withAnnotation" return="com.google.inject.Key"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="annotationType" type="java.lang.Class"/>
      <doc>
      <![CDATA[Returns a new key of the same type with the specified annotation.

 <p>This is equivalent to {@code Key.get(key.getTypeLiteral(), annotation)} but may be more
 convenient to use in certain cases.

 @since 5.0]]>
      </doc>
    </method>
    <method name="withAnnotation" return="com.google.inject.Key"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="annotation" type="java.lang.annotation.Annotation"/>
      <doc>
      <![CDATA[Returns a new key of the same type with the specified annotation.

 <p>This is equivalent to {@code Key.get(key.getTypeLiteral(), annotation)} but may be more
 convenient to use in certain cases.

 @since 5.0]]>
      </doc>
    </method>
    <method name="hasAttributes" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns true if this key has annotation attributes.

 @since 3.0]]>
      </doc>
    </method>
    <method name="withoutAttributes" return="com.google.inject.Key"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns this key without annotation attributes, i.e. with only the annotation type.

 @since 3.0]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Guice uses Key objects to identify a dependency that can be resolved by the Guice {@link
 Injector}. A Guice key consists of an injection type and an optional annotation.

 <p>For example, {@code Key.get(Service.class, Transactional.class)} will match:

 <pre>
   {@literal @}Inject
   public void setService({@literal @}Transactional Service service) {
     ...
   }
 </pre>

 <p>{@code Key} supports generic types via subclassing just like {@link TypeLiteral}.

 <p>Keys do not differentiate between primitive types (int, char, etc.) and their corresponding
 wrapper types (Integer, Character, etc.). Primitive types will be replaced with their wrapper
 types when keys are created.

 @author crazybob@google.com (Bob Lee)]]>
    </doc>
  </class>
  <!-- end class com.google.inject.Key -->
  <!-- start interface com.google.inject.MembersInjector -->
  <interface name="MembersInjector"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="injectMembers"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="instance" type="java.lang.Object"/>
      <doc>
      <![CDATA[Injects dependencies into the fields and methods of {@code instance}. Ignores the presence or
 absence of an injectable constructor.

 <p>Whenever Guice creates an instance, it performs this injection automatically (after first
 performing constructor injection), so if you're able to let Guice create all your objects for
 you, you'll never need to use this method.

 @param instance to inject members on. May be {@code null}.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Injects dependencies into the fields and methods on instances of type {@code T}. Ignores the
 presence or absence of an injectable constructor.

 @param <T> type to inject members of
 @author crazybob@google.com (Bob Lee)
 @author jessewilson@google.com (Jesse Wilson)
 @since 2.0]]>
    </doc>
  </interface>
  <!-- end interface com.google.inject.MembersInjector -->
  <!-- start interface com.google.inject.Module -->
  <interface name="Module"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="configure"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="binder" type="com.google.inject.Binder"/>
      <doc>
      <![CDATA[Contributes bindings and other configurations for this module to {@code binder}.

 <p><strong>Do not invoke this method directly</strong> to install submodules. Instead use
 {@link Binder#install(Module)}, which ensures that {@link Provides provider methods} are
 discovered.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A module contributes configuration information, typically interface bindings, which will be used
 to create an {@link Injector}. A Guice-based application is ultimately composed of little more
 than a set of {@code Module}s and some bootstrapping code.

 <p>Your Module classes can use a more streamlined syntax by extending {@link AbstractModule}
 rather than implementing this interface directly.

 <p>In addition to the bindings configured via {@link #configure}, bindings will be created for
 all methods annotated with {@literal @}{@link Provides}. Use scope and binding annotations on
 these methods to configure the bindings.]]>
    </doc>
  </interface>
  <!-- end interface com.google.inject.Module -->
  <!-- start class com.google.inject.OutOfScopeException -->
  <class name="OutOfScopeException" extends="java.lang.RuntimeException"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="OutOfScopeException" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="OutOfScopeException" type="java.lang.String, java.lang.Throwable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="OutOfScopeException" type="java.lang.Throwable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <doc>
    <![CDATA[Thrown from {@link Provider#get} when an attempt is made to access a scoped object while the
 scope in question is not currently active.

 @author kevinb@google.com (Kevin Bourrillion)
 @since 2.0]]>
    </doc>
  </class>
  <!-- end class com.google.inject.OutOfScopeException -->
  <!-- start interface com.google.inject.PrivateBinder -->
  <interface name="PrivateBinder"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.inject.Binder"/>
    <method name="expose"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="com.google.inject.Key"/>
      <doc>
      <![CDATA[Makes the binding for {@code key} available to the enclosing environment]]>
      </doc>
    </method>
    <method name="expose" return="com.google.inject.binder.AnnotatedElementBuilder"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="java.lang.Class"/>
      <doc>
      <![CDATA[Makes a binding for {@code type} available to the enclosing environment. Use {@link
 com.google.inject.binder.AnnotatedElementBuilder#annotatedWith(Class) annotatedWith()} to
 expose {@code type} with a binding annotation.]]>
      </doc>
    </method>
    <method name="expose" return="com.google.inject.binder.AnnotatedElementBuilder"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="com.google.inject.TypeLiteral"/>
      <doc>
      <![CDATA[Makes a binding for {@code type} available to the enclosing environment. Use {@link
 AnnotatedElementBuilder#annotatedWith(Class) annotatedWith()} to expose {@code type} with a
 binding annotation.]]>
      </doc>
    </method>
    <method name="withSource" return="com.google.inject.PrivateBinder"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="source" type="java.lang.Object"/>
    </method>
    <method name="skipSources" return="com.google.inject.PrivateBinder"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="classesToSkip" type="java.lang.Class[]"/>
    </method>
    <doc>
    <![CDATA[Returns a binder whose configuration information is hidden from its environment by default. See
 {@link com.google.inject.PrivateModule PrivateModule} for details.

 @author jessewilson@google.com (Jesse Wilson)
 @since 2.0]]>
    </doc>
  </interface>
  <!-- end interface com.google.inject.PrivateBinder -->
  <!-- start class com.google.inject.PrivateModule -->
  <class name="PrivateModule" extends="java.lang.Object"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.inject.Module"/>
    <constructor name="PrivateModule"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="configure"
      abstract="false" native="false" synchronized="true"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="binder" type="com.google.inject.Binder"/>
    </method>
    <method name="configure"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates bindings and other configurations private to this module. Use {@link #expose(Class)
 expose()} to make the bindings in this module available externally.]]>
      </doc>
    </method>
    <method name="expose"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="protected"
      deprecated="not deprecated">
      <param name="key" type="com.google.inject.Key"/>
      <doc>
      <![CDATA[Makes the binding for {@code key} available to other modules and the injector.]]>
      </doc>
    </method>
    <method name="expose" return="com.google.inject.binder.AnnotatedElementBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="protected"
      deprecated="not deprecated">
      <param name="type" type="java.lang.Class"/>
      <doc>
      <![CDATA[Makes a binding for {@code type} available to other modules and the injector. Use {@link
 AnnotatedElementBuilder#annotatedWith(Class) annotatedWith()} to expose {@code type} with a
 binding annotation.]]>
      </doc>
    </method>
    <method name="expose" return="com.google.inject.binder.AnnotatedElementBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="protected"
      deprecated="not deprecated">
      <param name="type" type="com.google.inject.TypeLiteral"/>
      <doc>
      <![CDATA[Makes a binding for {@code type} available to other modules and the injector. Use {@link
 AnnotatedElementBuilder#annotatedWith(Class) annotatedWith()} to expose {@code type} with a
 binding annotation.]]>
      </doc>
    </method>
    <method name="binder" return="com.google.inject.PrivateBinder"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the current binder.]]>
      </doc>
    </method>
    <method name="bindScope"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="protected"
      deprecated="not deprecated">
      <param name="scopeAnnotation" type="java.lang.Class"/>
      <param name="scope" type="com.google.inject.Scope"/>
      <doc>
      <![CDATA[@see Binder#bindScope(Class, Scope)]]>
      </doc>
    </method>
    <method name="bind" return="com.google.inject.binder.LinkedBindingBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="protected"
      deprecated="not deprecated">
      <param name="key" type="com.google.inject.Key"/>
      <doc>
      <![CDATA[@see Binder#bind(Key)]]>
      </doc>
    </method>
    <method name="bind" return="com.google.inject.binder.AnnotatedBindingBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="protected"
      deprecated="not deprecated">
      <param name="typeLiteral" type="com.google.inject.TypeLiteral"/>
      <doc>
      <![CDATA[@see Binder#bind(TypeLiteral)]]>
      </doc>
    </method>
    <method name="bind" return="com.google.inject.binder.AnnotatedBindingBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="protected"
      deprecated="not deprecated">
      <param name="clazz" type="java.lang.Class"/>
      <doc>
      <![CDATA[@see Binder#bind(Class)]]>
      </doc>
    </method>
    <method name="bindConstant" return="com.google.inject.binder.AnnotatedConstantBindingBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@see Binder#bindConstant()]]>
      </doc>
    </method>
    <method name="install"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="protected"
      deprecated="not deprecated">
      <param name="module" type="com.google.inject.Module"/>
      <doc>
      <![CDATA[@see Binder#install(Module)]]>
      </doc>
    </method>
    <method name="addError"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="protected"
      deprecated="not deprecated">
      <param name="message" type="java.lang.String"/>
      <param name="arguments" type="java.lang.Object[]"/>
      <doc>
      <![CDATA[@see Binder#addError(String, Object[])]]>
      </doc>
    </method>
    <method name="addError"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="protected"
      deprecated="not deprecated">
      <param name="t" type="java.lang.Throwable"/>
      <doc>
      <![CDATA[@see Binder#addError(Throwable)]]>
      </doc>
    </method>
    <method name="addError"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="protected"
      deprecated="not deprecated">
      <param name="message" type="com.google.inject.spi.Message"/>
      <doc>
      <![CDATA[@see Binder#addError(Message)]]>
      </doc>
    </method>
    <method name="requestInjection"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="protected"
      deprecated="not deprecated">
      <param name="instance" type="java.lang.Object"/>
      <doc>
      <![CDATA[@see Binder#requestInjection(Object)]]>
      </doc>
    </method>
    <method name="requestStaticInjection"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="protected"
      deprecated="not deprecated">
      <param name="types" type="java.lang.Class[]"/>
      <doc>
      <![CDATA[@see Binder#requestStaticInjection(Class[])]]>
      </doc>
    </method>
    <method name="bindInterceptor"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="protected"
      deprecated="not deprecated">
      <param name="classMatcher" type="com.google.inject.matcher.Matcher"/>
      <param name="methodMatcher" type="com.google.inject.matcher.Matcher"/>
      <param name="interceptors" type="org.aopalliance.intercept.MethodInterceptor[]"/>
      <doc>
      <![CDATA[@see Binder#bindInterceptor(com.google.inject.matcher.Matcher,
     com.google.inject.matcher.Matcher, org.aopalliance.intercept.MethodInterceptor[])]]>
      </doc>
    </method>
    <method name="requireBinding"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="protected"
      deprecated="not deprecated">
      <param name="key" type="com.google.inject.Key"/>
      <doc>
      <![CDATA[Instructs Guice to require a binding to the given key.]]>
      </doc>
    </method>
    <method name="requireBinding"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="protected"
      deprecated="not deprecated">
      <param name="type" type="java.lang.Class"/>
      <doc>
      <![CDATA[Instructs Guice to require a binding to the given type.]]>
      </doc>
    </method>
    <method name="getProvider" return="com.google.inject.Provider"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="protected"
      deprecated="not deprecated">
      <param name="key" type="com.google.inject.Key"/>
      <doc>
      <![CDATA[@see Binder#getProvider(Key)]]>
      </doc>
    </method>
    <method name="getProvider" return="com.google.inject.Provider"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="protected"
      deprecated="not deprecated">
      <param name="type" type="java.lang.Class"/>
      <doc>
      <![CDATA[@see Binder#getProvider(Class)]]>
      </doc>
    </method>
    <method name="convertToTypes"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="protected"
      deprecated="not deprecated">
      <param name="typeMatcher" type="com.google.inject.matcher.Matcher"/>
      <param name="converter" type="com.google.inject.spi.TypeConverter"/>
      <doc>
      <![CDATA[@see Binder#convertToTypes(com.google.inject.matcher.Matcher,
     com.google.inject.spi.TypeConverter)]]>
      </doc>
    </method>
    <method name="currentStage" return="com.google.inject.Stage"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@see Binder#currentStage()]]>
      </doc>
    </method>
    <method name="getMembersInjector" return="com.google.inject.MembersInjector"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="type" type="java.lang.Class"/>
      <doc>
      <![CDATA[@see Binder#getMembersInjector(Class)]]>
      </doc>
    </method>
    <method name="getMembersInjector" return="com.google.inject.MembersInjector"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="type" type="com.google.inject.TypeLiteral"/>
      <doc>
      <![CDATA[@see Binder#getMembersInjector(TypeLiteral)]]>
      </doc>
    </method>
    <method name="bindListener"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="typeMatcher" type="com.google.inject.matcher.Matcher"/>
      <param name="listener" type="com.google.inject.spi.TypeListener"/>
      <doc>
      <![CDATA[@see Binder#bindListener(com.google.inject.matcher.Matcher, com.google.inject.spi.TypeListener)]]>
      </doc>
    </method>
    <method name="bindListener"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="bindingMatcher" type="com.google.inject.matcher.Matcher"/>
      <param name="listeners" type="com.google.inject.spi.ProvisionListener[]"/>
      <doc>
      <![CDATA[@see Binder#bindListener(Matcher, ProvisionListener...)
 @since 4.0]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A module whose configuration information is hidden from its environment by default. Only bindings
 that are explicitly exposed will be available to other modules and to the users of the injector.
 This module may expose the bindings it creates and the bindings of the modules it installs.

 <p>A private module can be nested within a regular module or within another private module using
 {@link Binder#install install()}. Its bindings live in a new environment that inherits bindings,
 type converters, scopes, and interceptors from the surrounding ("parent") environment. When you
 nest multiple private modules, the result is a tree of environments where the injector's
 environment is the root.

 <p>Guice EDSL bindings can be exposed with {@link #expose(Class) expose()}. {@literal @}{@link
 com.google.inject.Provides Provides} bindings can be exposed with the {@literal @}{@link Exposed}
 annotation:

 <pre>
 public class FooBarBazModule extends PrivateModule {
   protected void configure() {
     bind(Foo.class).to(RealFoo.class);
     expose(Foo.class);

     install(new TransactionalBarModule());
     expose(Bar.class).annotatedWith(Transactional.class);

     bind(SomeImplementationDetail.class);
     install(new MoreImplementationDetailsModule());
   }

   {@literal @}Provides {@literal @}Exposed
   public Baz provideBaz() {
     return new SuperBaz();
   }
 }
 </pre>

 <p>Private modules are implemented using {@link Injector#createChildInjector(Module[]) parent
 injectors}. When it can satisfy their dependencies, just-in-time bindings will be created in the
 root environment. Such bindings are shared among all environments in the tree.

 <p>The scope of a binding is constrained to its environment. A singleton bound in a private
 module will be unique to its environment. But a binding for the same type in a different private
 module will yield a different instance.

 <p>A shared binding that injects the {@code Injector} gets the root injector, which only has
 access to bindings in the root environment. An explicit binding that injects the {@code Injector}
 gets access to all bindings in the child environment.

 <p>To promote a just-in-time binding to an explicit binding, bind it:

 <pre>
   bind(FooImpl.class);
 </pre>

 @author jessewilson@google.com (Jesse Wilson)
 @since 2.0]]>
    </doc>
  </class>
  <!-- end class com.google.inject.PrivateModule -->
  <!-- start interface com.google.inject.ProvidedBy -->
  <interface name="ProvidedBy"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.lang.annotation.Annotation"/>
    <method name="value" return="java.lang.Class"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The implementation type.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A pointer to the default provider type for a type.

 @author crazybob@google.com (Bob Lee)]]>
    </doc>
  </interface>
  <!-- end interface com.google.inject.ProvidedBy -->
  <!-- start interface com.google.inject.Provider -->
  <interface name="Provider"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="javax.inject.Provider"/>
    <method name="get" return="java.lang.Object"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Provides an instance of {@code T}.

 @throws OutOfScopeException when an attempt is made to access a scoped object while the scope
     in question is not currently active
 @throws ProvisionException if an instance cannot be provided. Such exceptions include messages
     and throwables to describe why provision failed.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[An object capable of providing instances of type {@code T}. Providers are used in numerous ways
 by Guice:

 <ul>
 <li>When the default means for obtaining instances (an injectable or parameterless constructor)
     is insufficient for a particular binding, the module can specify a custom {@code Provider}
     instead, to control exactly how Guice creates or obtains instances for the binding.
 <li>An implementation class may always choose to have a {@code Provider<T>} instance injected,
     rather than having a {@code T} injected directly. This may give you access to multiple
     instances, instances you wish to safely mutate and discard, instances which are out of scope
     (e.g. using a {@code @RequestScoped} object from within a {@code @SessionScoped} object), or
     instances that will be initialized lazily.
 <li>A custom {@link Scope} is implemented as a decorator of {@code Provider<T>}, which decides
     when to delegate to the backing provider and when to provide the instance some other way.
 <li>The {@link Injector} offers access to the {@code Provider<T>} it uses to fulfill requests for
     a given key, via the {@link Injector#getProvider} methods.
 </ul>

 @param <T> the type of object this provides
 @author crazybob@google.com (Bob Lee)]]>
    </doc>
  </interface>
  <!-- end interface com.google.inject.Provider -->
  <!-- start interface com.google.inject.Provides -->
  <interface name="Provides"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.lang.annotation.Annotation"/>
    <doc>
    <![CDATA[Annotates methods of a {@link Module} to create a provider method binding. The method's return
 type is bound to its returned value. Guice will pass dependencies to the method as parameters.

 @author crazybob@google.com (Bob Lee)
 @since 2.0]]>
    </doc>
  </interface>
  <!-- end interface com.google.inject.Provides -->
  <!-- start class com.google.inject.ProvisionException -->
  <class name="ProvisionException" extends="java.lang.RuntimeException"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="ProvisionException" type="java.lang.Iterable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a ProvisionException containing {@code messages}.]]>
      </doc>
    </constructor>
    <constructor name="ProvisionException" type="java.lang.String, java.lang.Throwable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="ProvisionException" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getErrorMessages" return="java.util.Collection"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns messages for the errors that caused this exception.]]>
      </doc>
    </method>
    <method name="getMessage" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Indicates that there was a runtime failure while providing an instance.

 @author kevinb@google.com (Kevin Bourrillion)
 @author jessewilson@google.com (Jesse Wilson)
 @since 2.0]]>
    </doc>
  </class>
  <!-- end class com.google.inject.ProvisionException -->
  <!-- start interface com.google.inject.RestrictedBindingSource -->
  <interface name="RestrictedBindingSource"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.lang.annotation.Annotation"/>
    <method name="explanation" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Explanation of why binding this target type is restricted.

 <p>Will appear as the error message if the target type is bound by non-allowed modules.]]>
      </doc>
    </method>
    <method name="permits" return="java.lang.Class[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[List of {@code Permit} annotations (must be non-empty), one of which has has to be present on a
 restricted binding's source (defined in top-level javadoc).]]>
      </doc>
    </method>
    <method name="exemptModules" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Exempt modules whose fully qualified class names match this regex.

 <p>If any module on the binding's module stack matches this regex, the binding is allowed (no
 permit necessary). No module is exempt by default (empty string).

 <p>Inteded to be used when retrofitting a binding with this restriction. When restricting an
 existing binding, it's often practical to first restrict with exemptions for existing
 violations (to prevent new violations), before updating the code in violation to use the
 permitted module(s).]]>
      </doc>
    </method>
    <method name="restrictionLevel" return="com.google.inject.RestrictedBindingSource.RestrictionLevel"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Annotation restricting the binding of the target type to permitted sources.

 <p>Bindings restricted by this annotation may only be created by sources annotated with a permit
 from {@link #permits} -- otherwise, an error message including the {@link #explanation} is
 issued.

 <p>There are two kinds of binding source:

 <ol>
   <li>Module: a module is the source of a binding if it creates it (either directly, or
       indirectly by installing another module). For example: if module A creates restricted
       binding X, and module C installs module B that installs A; then all 3 modules C,B,A are
       sources of X, and it's enough for any one of them to be annotated with a permit from X's
       restriction.
   <li>Method Scanner ({@code ModuleAnnotatedMethodScanner}): If a binding was created by a
       scanner, then that scanner is also a source of the binding (in addition to the module
       sources) and a permit may be given to the scanner by annotating its class.
 </ol>

 <p>Bindings with qualifier annotations are restricted solely by the annotation on their qualifier
 (restrictions on the type are ignored for qualified bindings). Unqualified bindings are
 restricted by the annotation on their type.

 <p>This allows libraries to prevent their clients from binding their keys, similar to how
 declaring a class final prevents subtyping. For example, a library may want to prevent users from
 creating mock bindings for tests, using the {@link #explanation} - included in the error message
 - to point them to a supported testing module.

 <p>Example usage:

 <pre>
 {@literal @}RestrictedBindingSource.Permit
 {@literal @}Retention(RetentionPolicy.RUNTIME)
 {@literal @}interface NetworkPermit {}

 {@literal @}RestrictedBindingSource(
   explanation = "Only NetworkModule can create network bindings.",
   permits = {NetworkPermit.class})
 {@literal @}Qualifier
 {@literal @}Retention(RetentionPolicy.RUNTIME)
 public {@literal @}interface GatewayIpAdress {}

 {@literal @}NetworkPermit
 public final class NetworkModule extends AbstractModule {
   // Allowed because the module is annotated with {@literal @}NetworkPermit.
   {@literal @}Provides
   {@literal @}GatewayIpAdress
   int provideGatewayIp() { ... }
 }
 </pre>

 @author vzm@google.com (Vladimir Makaric)
 @since 5.0]]>
    </doc>
  </interface>
  <!-- end interface com.google.inject.RestrictedBindingSource -->
  <!-- start interface com.google.inject.RestrictedBindingSource.Permit -->
  <interface name="RestrictedBindingSource.Permit"    abstract="true"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.lang.annotation.Annotation"/>
    <doc>
    <![CDATA[Meta-annotation indicating that the target annotation is a permit for binding restricted
 bindings. Annotating a binding source (defined in top-level javadoc) with a permit gives it
 permission to bind the restricted bindings guarded by the permit (see {@link #permits}).

 @since 5.0]]>
    </doc>
  </interface>
  <!-- end interface com.google.inject.RestrictedBindingSource.Permit -->
  <!-- start class com.google.inject.RestrictedBindingSource.RestrictionLevel -->
  <class name="RestrictedBindingSource.RestrictionLevel" extends="java.lang.Enum"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="values" return="com.google.inject.RestrictedBindingSource.RestrictionLevel[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="com.google.inject.RestrictedBindingSource.RestrictionLevel"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <field name="WARNING" type="com.google.inject.RestrictedBindingSource.RestrictionLevel"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="ERROR" type="com.google.inject.RestrictedBindingSource.RestrictionLevel"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[Level of restriction. Determines how violations are handled.

 @since 5.0]]>
    </doc>
  </class>
  <!-- end class com.google.inject.RestrictedBindingSource.RestrictionLevel -->
  <!-- start interface com.google.inject.Scope -->
  <interface name="Scope"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="scope" return="com.google.inject.Provider"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="com.google.inject.Key"/>
      <param name="unscoped" type="com.google.inject.Provider"/>
      <doc>
      <![CDATA[Scopes a provider. The returned provider returns objects from this scope. If an object does not
 exist in this scope, the provider can use the given unscoped provider to retrieve one.

 <p>Scope implementations are strongly encouraged to override {@link Object#toString} in the
 returned provider and include the backing provider's {@code toString()} output.

 @param key binding key
 @param unscoped locates an instance when one doesn't already exist in this scope.
 @return a new provider which only delegates to the given unscoped provider when an instance of
     the requested object doesn't already exist in this scope]]>
      </doc>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[A short but useful description of this scope. For comparison, the standard scopes that ship
 with guice use the descriptions {@code "Scopes.SINGLETON"}, {@code "ServletScopes.SESSION"} and
 {@code "ServletScopes.REQUEST"}.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A scope is a level of visibility that instances provided by Guice may have. By default, an
 instance created by the {@link Injector} has <i>no scope</i>, meaning it has no state from the
 framework's perspective -- the {@code Injector} creates it, injects it once into the class that
 required it, and then immediately forgets it. Associating a scope with a particular binding
 allows the created instance to be "remembered" and possibly used again for other injections.

 <p>An example of a scope is {@link Scopes#SINGLETON}.

 @author crazybob@google.com (Bob Lee)]]>
    </doc>
  </interface>
  <!-- end interface com.google.inject.Scope -->
  <!-- start interface com.google.inject.ScopeAnnotation -->
  <interface name="ScopeAnnotation"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.lang.annotation.Annotation"/>
    <doc>
    <![CDATA[Annotates annotations which are used for scoping. Only one such annotation may apply to a single
 implementation class. You must also annotate scope annotations with {@code @Retention(RUNTIME)}.
 For example:

 <pre>
   {@code @}Retention(RUNTIME)
   {@code @}Target(TYPE, METHOD)
   {@code @}ScopeAnnotation
   public {@code @}interface SessionScoped {}
 </pre>

 @author crazybob@google.com (Bob Lee)]]>
    </doc>
  </interface>
  <!-- end interface com.google.inject.ScopeAnnotation -->
  <!-- start class com.google.inject.Scopes -->
  <class name="Scopes" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="isSingleton" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="binding" type="com.google.inject.Binding"/>
      <doc>
      <![CDATA[Returns true if {@code binding} is singleton-scoped. If the binding is a {@link
 com.google.inject.spi.LinkedKeyBinding linked key binding} and belongs to an injector (ie. it
 was retrieved via {@link Injector#getBinding Injector.getBinding()}), then this method will
 also true if the target binding is singleton-scoped.

 @since 3.0]]>
      </doc>
    </method>
    <method name="isScoped" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="binding" type="com.google.inject.Binding"/>
      <param name="scope" type="com.google.inject.Scope"/>
      <param name="scopeAnnotation" type="java.lang.Class"/>
      <doc>
      <![CDATA[Returns true if {@code binding} has the given scope. If the binding is a {@link
 com.google.inject.spi.LinkedKeyBinding linked key binding} and belongs to an injector (ie. it
 was retrieved via {@link Injector#getBinding Injector.getBinding()}), then this method will
 also true if the target binding has the given scope.

 @param binding binding to check
 @param scope scope implementation instance
 @param scopeAnnotation scope annotation class
 @since 4.0]]>
      </doc>
    </method>
    <method name="isCircularProxy" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="object" type="java.lang.Object"/>
      <doc>
      <![CDATA[Returns true if the object is a proxy for a circular dependency, constructed by Guice because
 it encountered a circular dependency. Scope implementations should be careful to <b>not cache
 circular proxies</b>, because the proxies are not intended for general purpose use. (They are
 designed just to fulfill the immediate injection, not all injections. Caching them can lead to
 IllegalArgumentExceptions or ClassCastExceptions.)

 @since 4.0]]>
      </doc>
    </method>
    <field name="SINGLETON" type="com.google.inject.Scope"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[One instance per {@link Injector}. Also see {@code @}{@link Singleton}.]]>
      </doc>
    </field>
    <field name="NO_SCOPE" type="com.google.inject.Scope"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[No scope; the same as not applying any scope at all. Each time the Injector obtains an instance
 of an object with "no scope", it injects this instance then immediately forgets it. When the
 next request for the same binding arrives it will need to obtain the instance over again.

 <p>This exists only in case a class has been annotated with a scope annotation such as {@link
 Singleton @Singleton}, and you need to override this to "no scope" in your binding.

 @since 2.0]]>
      </doc>
    </field>
    <doc>
    <![CDATA[Built-in scope implementations.

 @author crazybob@google.com (Bob Lee)]]>
    </doc>
  </class>
  <!-- end class com.google.inject.Scopes -->
  <!-- start interface com.google.inject.Singleton -->
  <interface name="Singleton"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.lang.annotation.Annotation"/>
    <doc>
    <![CDATA[Apply this to implementation classes when you want only one instance (per {@link Injector}) to be
 reused for all injections for that binding.

 @author crazybob@google.com (Bob Lee)]]>
    </doc>
  </interface>
  <!-- end interface com.google.inject.Singleton -->
  <!-- start class com.google.inject.Stage -->
  <class name="Stage" extends="java.lang.Enum"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="values" return="com.google.inject.Stage[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="com.google.inject.Stage"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <field name="TOOL" type="com.google.inject.Stage"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[We're running in a tool (an IDE plugin for example). We need binding meta data but not a
 functioning Injector. Do not inject members of instances. Do not load eager singletons. Do as
 little as possible so our tools run nice and snappy. Injectors created in this stage cannot be
 used to satisfy injections.]]>
      </doc>
    </field>
    <field name="DEVELOPMENT" type="com.google.inject.Stage"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[We want fast startup times at the expense of runtime performance and some up front error
 checking.]]>
      </doc>
    </field>
    <field name="PRODUCTION" type="com.google.inject.Stage"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[We want to catch errors as early as possible and take performance hits up front.]]>
      </doc>
    </field>
    <doc>
    <![CDATA[The stage we're running in.

 @author crazybob@google.com (Bob Lee)]]>
    </doc>
  </class>
  <!-- end class com.google.inject.Stage -->
  <!-- start class com.google.inject.TypeLiteral -->
  <class name="TypeLiteral" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="TypeLiteral"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a new type literal. Derives represented class from type parameter.

 <p>Clients create an empty anonymous subclass. Doing so embeds the type parameter in the
 anonymous class's type hierarchy so we can reconstitute it at runtime despite erasure.]]>
      </doc>
    </constructor>
    <method name="getRawType" return="java.lang.Class"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the raw (non-generic) type for this type.

 @since 2.0]]>
      </doc>
    </method>
    <method name="getType" return="java.lang.reflect.Type"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets underlying {@code Type} instance.]]>
      </doc>
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="o" type="java.lang.Object"/>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="get" return="com.google.inject.TypeLiteral"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="java.lang.reflect.Type"/>
      <doc>
      <![CDATA[Gets type literal for the given {@code Type} instance.]]>
      </doc>
    </method>
    <method name="get" return="com.google.inject.TypeLiteral"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="java.lang.Class"/>
      <doc>
      <![CDATA[Gets type literal for the given {@code Class} instance.]]>
      </doc>
    </method>
    <method name="getSupertype" return="com.google.inject.TypeLiteral"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="supertype" type="java.lang.Class"/>
      <doc>
      <![CDATA[Returns the generic form of {@code supertype}. For example, if this is {@code
 ArrayList<String>}, this returns {@code Iterable<String>} given the input {@code
 Iterable.class}.

 @param supertype a superclass of, or interface implemented by, this.
 @since 2.0]]>
      </doc>
    </method>
    <method name="getFieldType" return="com.google.inject.TypeLiteral"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="field" type="java.lang.reflect.Field"/>
      <doc>
      <![CDATA[Returns the resolved generic type of {@code field}.

 @param field a field defined by this or any superclass.
 @since 2.0]]>
      </doc>
    </method>
    <method name="getParameterTypes" return="java.util.List"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="methodOrConstructor" type="java.lang.reflect.Member"/>
      <doc>
      <![CDATA[Returns the resolved generic parameter types of {@code methodOrConstructor}.

 @param methodOrConstructor a method or constructor defined by this or any supertype.
 @since 2.0]]>
      </doc>
    </method>
    <method name="getExceptionTypes" return="java.util.List"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="methodOrConstructor" type="java.lang.reflect.Member"/>
      <doc>
      <![CDATA[Returns the resolved generic exception types thrown by {@code constructor}.

 @param methodOrConstructor a method or constructor defined by this or any supertype.
 @since 2.0]]>
      </doc>
    </method>
    <method name="getReturnType" return="com.google.inject.TypeLiteral"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="method" type="java.lang.reflect.Method"/>
      <doc>
      <![CDATA[Returns the resolved generic return type of {@code method}.

 @param method a method defined by this or any supertype.
 @since 2.0]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Represents a generic type {@code T}. Java doesn't yet provide a way to represent generic types,
 so this class does. Forces clients to create a subclass of this class which enables retrieval of
 the type information even at runtime.

 <p>For example, to create a type literal for {@code List<String>}, you can create an empty
 anonymous inner class:

 <p>{@code TypeLiteral<List<String>> list = new TypeLiteral<List<String>>() {};}

 <p>Along with modeling generic types, this class can resolve type parameters. For example, to
 figure out what type {@code keySet()} returns on a {@code Map<Integer, String>}, use this code:

 <pre>{@code
 TypeLiteral<Map<Integer, String>> mapType
     = new TypeLiteral<Map<Integer, String>>() {};
 TypeLiteral<?> keySetType
     = mapType.getReturnType(Map.class.getMethod("keySet"));
 System.out.println(keySetType); // prints "Set<Integer>"
 }</pre>

 @author crazybob@google.com (Bob Lee)
 @author jessewilson@google.com (Jesse Wilson)]]>
    </doc>
  </class>
  <!-- end class com.google.inject.TypeLiteral -->
</package>
<package name="com.google.inject.binder">
  <!-- start interface com.google.inject.binder.AnnotatedBindingBuilder -->
  <interface name="AnnotatedBindingBuilder"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.inject.binder.LinkedBindingBuilder"/>
    <method name="annotatedWith" return="com.google.inject.binder.LinkedBindingBuilder"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="annotationType" type="java.lang.Class"/>
      <doc>
      <![CDATA[See the EDSL examples at {@link com.google.inject.Binder}.]]>
      </doc>
    </method>
    <method name="annotatedWith" return="com.google.inject.binder.LinkedBindingBuilder"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="annotation" type="java.lang.annotation.Annotation"/>
      <doc>
      <![CDATA[See the EDSL examples at {@link com.google.inject.Binder}.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[See the EDSL examples at {@link com.google.inject.Binder}.

 @author crazybob@google.com (Bob Lee)]]>
    </doc>
  </interface>
  <!-- end interface com.google.inject.binder.AnnotatedBindingBuilder -->
  <!-- start interface com.google.inject.binder.AnnotatedConstantBindingBuilder -->
  <interface name="AnnotatedConstantBindingBuilder"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="annotatedWith" return="com.google.inject.binder.ConstantBindingBuilder"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="annotationType" type="java.lang.Class"/>
      <doc>
      <![CDATA[See the EDSL examples at {@link com.google.inject.Binder}.]]>
      </doc>
    </method>
    <method name="annotatedWith" return="com.google.inject.binder.ConstantBindingBuilder"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="annotation" type="java.lang.annotation.Annotation"/>
      <doc>
      <![CDATA[See the EDSL examples at {@link com.google.inject.Binder}.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[See the EDSL examples at {@link com.google.inject.Binder}.

 @author crazybob@google.com (Bob Lee)]]>
    </doc>
  </interface>
  <!-- end interface com.google.inject.binder.AnnotatedConstantBindingBuilder -->
  <!-- start interface com.google.inject.binder.AnnotatedElementBuilder -->
  <interface name="AnnotatedElementBuilder"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="annotatedWith"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="annotationType" type="java.lang.Class"/>
      <doc>
      <![CDATA[See the EDSL examples at {@link com.google.inject.Binder}.]]>
      </doc>
    </method>
    <method name="annotatedWith"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="annotation" type="java.lang.annotation.Annotation"/>
      <doc>
      <![CDATA[See the EDSL examples at {@link com.google.inject.Binder}.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[See the EDSL examples at {@link com.google.inject.Binder}.

 @author jessewilson@google.com (Jesse Wilson)
 @since 2.0]]>
    </doc>
  </interface>
  <!-- end interface com.google.inject.binder.AnnotatedElementBuilder -->
  <!-- start interface com.google.inject.binder.ConstantBindingBuilder -->
  <interface name="ConstantBindingBuilder"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="to"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="java.lang.String"/>
      <doc>
      <![CDATA[Binds constant to the given value.]]>
      </doc>
    </method>
    <method name="to"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="int"/>
      <doc>
      <![CDATA[Binds constant to the given value.]]>
      </doc>
    </method>
    <method name="to"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="long"/>
      <doc>
      <![CDATA[Binds constant to the given value.]]>
      </doc>
    </method>
    <method name="to"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="boolean"/>
      <doc>
      <![CDATA[Binds constant to the given value.]]>
      </doc>
    </method>
    <method name="to"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="double"/>
      <doc>
      <![CDATA[Binds constant to the given value.]]>
      </doc>
    </method>
    <method name="to"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="float"/>
      <doc>
      <![CDATA[Binds constant to the given value.]]>
      </doc>
    </method>
    <method name="to"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="short"/>
      <doc>
      <![CDATA[Binds constant to the given value.]]>
      </doc>
    </method>
    <method name="to"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="char"/>
      <doc>
      <![CDATA[Binds constant to the given value.]]>
      </doc>
    </method>
    <method name="to"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="byte"/>
      <doc>
      <![CDATA[Binds constant to the given value.

 @since 3.0]]>
      </doc>
    </method>
    <method name="to"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="java.lang.Class"/>
      <doc>
      <![CDATA[Binds constant to the given value.]]>
      </doc>
    </method>
    <method name="to"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="java.lang.Enum"/>
      <doc>
      <![CDATA[Binds constant to the given value.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Binds to a constant value.]]>
    </doc>
  </interface>
  <!-- end interface com.google.inject.binder.ConstantBindingBuilder -->
  <!-- start interface com.google.inject.binder.LinkedBindingBuilder -->
  <interface name="LinkedBindingBuilder"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.inject.binder.ScopedBindingBuilder"/>
    <method name="to" return="com.google.inject.binder.ScopedBindingBuilder"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="implementation" type="java.lang.Class"/>
      <doc>
      <![CDATA[See the EDSL examples at {@link com.google.inject.Binder}.]]>
      </doc>
    </method>
    <method name="to" return="com.google.inject.binder.ScopedBindingBuilder"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="implementation" type="com.google.inject.TypeLiteral"/>
      <doc>
      <![CDATA[See the EDSL examples at {@link com.google.inject.Binder}.]]>
      </doc>
    </method>
    <method name="to" return="com.google.inject.binder.ScopedBindingBuilder"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="targetKey" type="com.google.inject.Key"/>
      <doc>
      <![CDATA[See the EDSL examples at {@link com.google.inject.Binder}.]]>
      </doc>
    </method>
    <method name="toInstance"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="instance" type="java.lang.Object"/>
      <doc>
      <![CDATA[See the EDSL examples at {@link com.google.inject.Binder}.

 @see com.google.inject.Injector#injectMembers]]>
      </doc>
    </method>
    <method name="toProvider" return="com.google.inject.binder.ScopedBindingBuilder"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="provider" type="com.google.inject.Provider"/>
      <doc>
      <![CDATA[See the EDSL examples at {@link com.google.inject.Binder}.

 @see com.google.inject.Injector#injectMembers]]>
      </doc>
    </method>
    <method name="toProvider" return="com.google.inject.binder.ScopedBindingBuilder"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="provider" type="javax.inject.Provider"/>
      <doc>
      <![CDATA[See the EDSL examples at {@link com.google.inject.Binder}.

 @see com.google.inject.Injector#injectMembers
 @since 4.0]]>
      </doc>
    </method>
    <method name="toProvider" return="com.google.inject.binder.ScopedBindingBuilder"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="providerType" type="java.lang.Class"/>
      <doc>
      <![CDATA[See the EDSL examples at {@link com.google.inject.Binder}.]]>
      </doc>
    </method>
    <method name="toProvider" return="com.google.inject.binder.ScopedBindingBuilder"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="providerType" type="com.google.inject.TypeLiteral"/>
      <doc>
      <![CDATA[See the EDSL examples at {@link com.google.inject.Binder}.]]>
      </doc>
    </method>
    <method name="toProvider" return="com.google.inject.binder.ScopedBindingBuilder"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="providerKey" type="com.google.inject.Key"/>
      <doc>
      <![CDATA[See the EDSL examples at {@link com.google.inject.Binder}.]]>
      </doc>
    </method>
    <method name="toConstructor" return="com.google.inject.binder.ScopedBindingBuilder"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="constructor" type="java.lang.reflect.Constructor"/>
      <doc>
      <![CDATA[See the EDSL examples at {@link com.google.inject.Binder}.

 @since 3.0]]>
      </doc>
    </method>
    <method name="toConstructor" return="com.google.inject.binder.ScopedBindingBuilder"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="constructor" type="java.lang.reflect.Constructor"/>
      <param name="type" type="com.google.inject.TypeLiteral"/>
      <doc>
      <![CDATA[See the EDSL examples at {@link com.google.inject.Binder}.

 @since 3.0]]>
      </doc>
    </method>
    <doc>
    <![CDATA[See the EDSL examples at {@link com.google.inject.Binder}.

 @author crazybob@google.com (Bob Lee)]]>
    </doc>
  </interface>
  <!-- end interface com.google.inject.binder.LinkedBindingBuilder -->
  <!-- start interface com.google.inject.binder.ScopedBindingBuilder -->
  <interface name="ScopedBindingBuilder"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="in"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="scopeAnnotation" type="java.lang.Class"/>
      <doc>
      <![CDATA[See the EDSL examples at {@link com.google.inject.Binder}.]]>
      </doc>
    </method>
    <method name="in"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="scope" type="com.google.inject.Scope"/>
      <doc>
      <![CDATA[See the EDSL examples at {@link com.google.inject.Binder}.]]>
      </doc>
    </method>
    <method name="asEagerSingleton"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Instructs the {@link com.google.inject.Injector} to eagerly initialize this singleton-scoped
 binding upon creation. Useful for application initialization logic. See the EDSL examples at
 {@link com.google.inject.Binder}.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[See the EDSL examples at {@link com.google.inject.Binder}.

 @author crazybob@google.com (Bob Lee)]]>
    </doc>
  </interface>
  <!-- end interface com.google.inject.binder.ScopedBindingBuilder -->
</package>
<package name="com.google.inject.internal.util">
  <!-- start class com.google.inject.internal.util.Classes -->
  <class name="Classes" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="Classes"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="isInnerClass" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="clazz" type="java.lang.Class"/>
    </method>
    <method name="isConcrete" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="clazz" type="java.lang.Class"/>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="member" type="java.lang.reflect.Member"/>
      <doc>
      <![CDATA[Formats a member as concise string, such as {@code java.util.ArrayList.size}, {@code
 java.util.ArrayList<init>()} or {@code java.util.List.remove()}.]]>
      </doc>
    </method>
    <method name="memberType" return="java.lang.Class"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="member" type="java.lang.reflect.Member"/>
      <doc>
      <![CDATA[Returns {@code Field.class}, {@code Method.class} or {@code Constructor.class}.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Class utilities.]]>
    </doc>
  </class>
  <!-- end class com.google.inject.internal.util.Classes -->
  <!-- start class com.google.inject.internal.util.ContinuousStopwatch -->
  <class name="ContinuousStopwatch" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="ContinuousStopwatch" type="com.google.common.base.Stopwatch"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a ContinuousStopwatch, which will start timing immediately after construction.

 @param stopwatch the internal stopwatch used by ContinuousStopwatch]]>
      </doc>
    </constructor>
    <method name="reset" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Resets and returns elapsed time in milliseconds.]]>
      </doc>
    </method>
    <method name="resetAndLog"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="label" type="java.lang.String"/>
      <doc>
      <![CDATA[Resets and logs elapsed time in milliseconds.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A continuously timing stopwatch that is used for simple performance monitoring.

 @author crazybob@google.com (Bob Lee)]]>
    </doc>
  </class>
  <!-- end class com.google.inject.internal.util.ContinuousStopwatch -->
  <!-- start class com.google.inject.internal.util.SourceProvider -->
  <class name="SourceProvider" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="plusSkippedClasses" return="com.google.inject.internal.util.SourceProvider"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="moreClassesToSkip" type="java.lang.Class[]"/>
      <doc>
      <![CDATA[Returns a new instance that also skips {@code moreClassesToSkip}.]]>
      </doc>
    </method>
    <method name="getCaller" return="java.lang.StackTraceElement"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the calling line of code. The selected line is the nearest to the top of the stack that
 is not skipped.]]>
      </doc>
    </method>
    <method name="getFromClassNames" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="moduleClassNames" type="java.util.List"/>
      <doc>
      <![CDATA[Returns the non-skipped module class name.]]>
      </doc>
    </method>
    <field name="UNKNOWN_SOURCE" type="java.lang.Object"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Indicates that the source is unknown.]]>
      </doc>
    </field>
    <field name="DEFAULT_INSTANCE" type="com.google.inject.internal.util.SourceProvider"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[Provides access to the calling line of code.

 @author crazybob@google.com (Bob Lee)]]>
    </doc>
  </class>
  <!-- end class com.google.inject.internal.util.SourceProvider -->
  <!-- start class com.google.inject.internal.util.StackTraceElements -->
  <class name="StackTraceElements" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="forMember" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="member" type="java.lang.reflect.Member"/>
    </method>
    <method name="forType" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="implementation" type="java.lang.Class"/>
    </method>
    <method name="clearCache"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Clears the internal cache for {@link StackTraceElement StackTraceElements}.]]>
      </doc>
    </method>
    <method name="convertToInMemoryStackTraceElement" return="com.google.inject.internal.util.StackTraceElements.InMemoryStackTraceElement[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="stackTraceElements" type="java.lang.StackTraceElement[]"/>
      <doc>
      <![CDATA[Returns encoded in-memory version of {@link StackTraceElement StackTraceElements}.]]>
      </doc>
    </method>
    <method name="convertToStackTraceElement" return="java.lang.StackTraceElement[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="inMemoryStackTraceElements" type="com.google.inject.internal.util.StackTraceElements.InMemoryStackTraceElement[]"/>
      <doc>
      <![CDATA[Decodes in-memory stack trace elements to regular {@link StackTraceElement StackTraceElements}.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Creates stack trace elements for members.

 @author crazybob@google.com (Bob Lee)]]>
    </doc>
  </class>
  <!-- end class com.google.inject.internal.util.StackTraceElements -->
  <!-- start class com.google.inject.internal.util.StackTraceElements.InMemoryStackTraceElement -->
  <class name="StackTraceElements.InMemoryStackTraceElement" extends="java.lang.Object"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="obj" type="java.lang.Object"/>
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[In-Memory version of {@link StackTraceElement} that does not store the file name.]]>
    </doc>
  </class>
  <!-- end class com.google.inject.internal.util.StackTraceElements.InMemoryStackTraceElement -->
</package>
<package name="com.google.inject.spi">
  <!-- start interface com.google.inject.spi.BindingScopingVisitor -->
  <interface name="BindingScopingVisitor"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="visitEagerSingleton" return="java.lang.Object"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Visit an eager singleton or single instance. This scope strategy is found on both module and
 injector bindings.]]>
      </doc>
    </method>
    <method name="visitScope" return="java.lang.Object"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="scope" type="com.google.inject.Scope"/>
      <doc>
      <![CDATA[Visit a scope instance. This scope strategy is found on both module and injector bindings.]]>
      </doc>
    </method>
    <method name="visitScopeAnnotation" return="java.lang.Object"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="scopeAnnotation" type="java.lang.Class"/>
      <doc>
      <![CDATA[Visit a scope annotation. This scope strategy is found only on module bindings. The instance
 that implements this scope is registered by {@link com.google.inject.Binder#bindScope(Class,
 Scope) Binder.bindScope()}.]]>
      </doc>
    </method>
    <method name="visitNoScoping" return="java.lang.Object"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Visit an unspecified or unscoped strategy. On a module, this strategy indicates that the
 injector should use scoping annotations to find a scope. On an injector, it indicates that no
 scope is applied to the binding. An unscoped binding will behave like a scoped one when it is
 linked to a scoped binding.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Visits each of the strategies used to scope an injection.

 @param <V> any type to be returned by the visit method. Use {@link Void} with {@code return null}
     if no return type is needed.
 @since 2.0]]>
    </doc>
  </interface>
  <!-- end interface com.google.inject.spi.BindingScopingVisitor -->
  <!-- start class com.google.inject.spi.BindingSourceRestriction -->
  <class name="BindingSourceRestriction" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="getMissingImplementationSuggestion" return="java.util.Optional"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="guiceInternal" type="com.google.inject.internal.GuiceInternal"/>
      <param name="key" type="com.google.inject.Key"/>
      <doc>
      <![CDATA[Returns a suggestion for how a restricted binding should be created in case it's missing.]]>
      </doc>
    </method>
    <method name="check" return="com.google.common.collect.ImmutableList"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="guiceInternal" type="com.google.inject.internal.GuiceInternal"/>
      <param name="elements" type="java.util.List"/>
      <doc>
      <![CDATA[Returns all the restriction violations found on the given Module Elements, as error messages.

 <p>Note: Intended to be used on Module Elements, not Injector Elements, ie. the result of
 {@link Elements#getElements} not {@code Injector.getElements}. The Module Elements this check
 cares about are:

 <ul>
   <li>Module Bindings, which are always explicit and always have an {@link ElementSource} (with
       a Module Stack), unlike Injector Bindings, which may be implicit and bereft of an
       ElementSource.
   <li>{@link PrivateElements}, which represent the recursive case of this check. They contain a
       list of elements that this check is recursively called on.
 </ul>]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Contains abstractions for enforcing {@link RestrictedBindingSource}.

 <p>Enforcement happens in two phases:

 <ol>
   <li>Data structures for enforcement are built during Binder configuration. {@link
       PermitMapConstruction} encapsulates this process, and the {@link PermitMap} is the end
       result.
   <li>Restrictions are enforced by checking each binding for violations with {@link #check},
       which uses the {@link PermitMap}(s) built during Binder configuration.
 </ol>

 <p>Note: None of this is thread-safe because it's only used while the Injector is being built,
 which happens on a single thread.

 @author vzm@google.com (Vladimir Makaric)
 @since 5.0]]>
    </doc>
  </class>
  <!-- end class com.google.inject.spi.BindingSourceRestriction -->
  <!-- start interface com.google.inject.spi.BindingTargetVisitor -->
  <interface name="BindingTargetVisitor"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="visit" return="java.lang.Object"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="binding" type="com.google.inject.spi.InstanceBinding"/>
      <doc>
      <![CDATA[Visit a instance binding. The same instance is returned for every injection. This target is
 found in both module and injector bindings.]]>
      </doc>
    </method>
    <method name="visit" return="java.lang.Object"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="binding" type="com.google.inject.spi.ProviderInstanceBinding"/>
      <doc>
      <![CDATA[Visit a provider instance binding. The provider's {@code get} method is invoked to resolve
 injections. This target is found in both module and injector bindings.]]>
      </doc>
    </method>
    <method name="visit" return="java.lang.Object"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="binding" type="com.google.inject.spi.ProviderKeyBinding"/>
      <doc>
      <![CDATA[Visit a provider key binding. To resolve injections, the provider key is first resolved, then
 that provider's {@code get} method is invoked. This target is found in both module and injector
 bindings.]]>
      </doc>
    </method>
    <method name="visit" return="java.lang.Object"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="binding" type="com.google.inject.spi.LinkedKeyBinding"/>
      <doc>
      <![CDATA[Visit a linked key binding. The other key's binding is used to resolve injections. This target
 is found in both module and injector bindings.]]>
      </doc>
    </method>
    <method name="visit" return="java.lang.Object"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="binding" type="com.google.inject.spi.ExposedBinding"/>
      <doc>
      <![CDATA[Visit a binding to a key exposed from an enclosed private environment. This target is only
 found in injector bindings.]]>
      </doc>
    </method>
    <method name="visit" return="java.lang.Object"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="binding" type="com.google.inject.spi.UntargettedBinding"/>
      <doc>
      <![CDATA[Visit an untargetted binding. This target is found only on module bindings. It indicates that
 the injector should use its implicit binding strategies to resolve injections.]]>
      </doc>
    </method>
    <method name="visit" return="java.lang.Object"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="binding" type="com.google.inject.spi.ConstructorBinding"/>
      <doc>
      <![CDATA[Visit a constructor binding. To resolve injections, an instance is instantiated by invoking
 {@code constructor}. This target is found only on injector bindings.]]>
      </doc>
    </method>
    <method name="visit" return="java.lang.Object"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="binding" type="com.google.inject.spi.ConvertedConstantBinding"/>
      <doc>
      <![CDATA[Visit a binding created from converting a bound instance to a new type. The source binding has
 the same binding annotation but a different type. This target is found only on injector
 bindings.]]>
      </doc>
    </method>
    <method name="visit" return="java.lang.Object"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="binding" type="com.google.inject.spi.ProviderBinding"/>
      <doc>
      <![CDATA[Visit a binding to a {@link com.google.inject.Provider} that delegates to the binding for the
 provided type. This target is found only on injector bindings.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Visits each of the strategies used to find an instance to satisfy an injection.

 @param <V> any type to be returned by the visit method. Use {@link Void} with {@code return null}
     if no return type is needed.
 @since 2.0]]>
    </doc>
  </interface>
  <!-- end interface com.google.inject.spi.BindingTargetVisitor -->
  <!-- start interface com.google.inject.spi.ConstructorBinding -->
  <interface name="ConstructorBinding"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.inject.Binding"/>
    <implements name="com.google.inject.spi.HasDependencies"/>
    <method name="getConstructor" return="com.google.inject.spi.InjectionPoint"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the constructor this binding injects.]]>
      </doc>
    </method>
    <method name="getInjectableMembers" return="java.util.Set"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns all instance method and field injection points on {@code type}.

 @return a possibly empty set of injection points. The set has a specified iteration order. All
     fields are returned and then all methods. Within the fields, supertype fields are returned
     before subtype fields. Similarly, supertype methods are returned before subtype methods.]]>
      </doc>
    </method>
    <method name="getMethodInterceptors" return="java.util.Map"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the interceptors applied to each method, in the order that they will be applied.

 @return a possibly empty map]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A binding to the constructor of a concrete clss. To resolve injections, an instance is
 instantiated by invoking the constructor.

 @author jessewilson@google.com (Jesse Wilson)
 @since 2.0]]>
    </doc>
  </interface>
  <!-- end interface com.google.inject.spi.ConstructorBinding -->
  <!-- start interface com.google.inject.spi.ConvertedConstantBinding -->
  <interface name="ConvertedConstantBinding"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.inject.Binding"/>
    <implements name="com.google.inject.spi.HasDependencies"/>
    <method name="getValue" return="java.lang.Object"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the converted value.]]>
      </doc>
    </method>
    <method name="getTypeConverterBinding" return="com.google.inject.spi.TypeConverterBinding"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the type converter binding used to convert the constant.

 @since 3.0]]>
      </doc>
    </method>
    <method name="getSourceKey" return="com.google.inject.Key"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the key for the source binding. That binding can be retrieved from an injector using
 {@link com.google.inject.Injector#getBinding(Key) Injector.getBinding(key)}.]]>
      </doc>
    </method>
    <method name="getDependencies" return="java.util.Set"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a singleton set containing only the converted key.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A binding created from converting a bound instance to a new type. The source binding has the same
 binding annotation but a different type.

 @author jessewilson@google.com (Jesse Wilson)
 @since 2.0]]>
    </doc>
  </interface>
  <!-- end interface com.google.inject.spi.ConvertedConstantBinding -->
  <!-- start class com.google.inject.spi.DefaultBindingScopingVisitor -->
  <class name="DefaultBindingScopingVisitor" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.inject.spi.BindingScopingVisitor"/>
    <constructor name="DefaultBindingScopingVisitor"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="visitOther" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Default visit implementation. Returns {@code null}.]]>
      </doc>
    </method>
    <method name="visitEagerSingleton" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="visitScope" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="scope" type="com.google.inject.Scope"/>
    </method>
    <method name="visitScopeAnnotation" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="scopeAnnotation" type="java.lang.Class"/>
    </method>
    <method name="visitNoScoping" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[No-op visitor for subclassing. All interface methods simply delegate to {@link #visitOther()},
 returning its result.

 @param <V> any type to be returned by the visit method. Use {@link Void} with {@code return null}
     if no return type is needed.
 @author jessewilson@google.com (Jesse Wilson)
 @since 2.0]]>
    </doc>
  </class>
  <!-- end class com.google.inject.spi.DefaultBindingScopingVisitor -->
  <!-- start class com.google.inject.spi.DefaultBindingTargetVisitor -->
  <class name="DefaultBindingTargetVisitor" extends="java.lang.Object"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.inject.spi.BindingTargetVisitor"/>
    <constructor name="DefaultBindingTargetVisitor"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="visitOther" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="binding" type="com.google.inject.Binding"/>
      <doc>
      <![CDATA[Default visit implementation. Returns {@code null}.]]>
      </doc>
    </method>
    <method name="visit" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="instanceBinding" type="com.google.inject.spi.InstanceBinding"/>
    </method>
    <method name="visit" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="providerInstanceBinding" type="com.google.inject.spi.ProviderInstanceBinding"/>
    </method>
    <method name="visit" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="providerKeyBinding" type="com.google.inject.spi.ProviderKeyBinding"/>
    </method>
    <method name="visit" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="linkedKeyBinding" type="com.google.inject.spi.LinkedKeyBinding"/>
    </method>
    <method name="visit" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="exposedBinding" type="com.google.inject.spi.ExposedBinding"/>
    </method>
    <method name="visit" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="untargettedBinding" type="com.google.inject.spi.UntargettedBinding"/>
    </method>
    <method name="visit" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="constructorBinding" type="com.google.inject.spi.ConstructorBinding"/>
    </method>
    <method name="visit" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="convertedConstantBinding" type="com.google.inject.spi.ConvertedConstantBinding"/>
    </method>
    <method name="visit" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="providerBinding" type="com.google.inject.spi.ProviderBinding"/>
    </method>
    <doc>
    <![CDATA[No-op visitor for subclassing. All interface methods simply delegate to {@link
 #visitOther(Binding)}, returning its result.

 @param <V> any type to be returned by the visit method. Use {@link Void} with {@code return null}
     if no return type is needed.
 @author jessewilson@google.com (Jesse Wilson)
 @since 2.0]]>
    </doc>
  </class>
  <!-- end class com.google.inject.spi.DefaultBindingTargetVisitor -->
  <!-- start class com.google.inject.spi.DefaultElementVisitor -->
  <class name="DefaultElementVisitor" extends="java.lang.Object"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.inject.spi.ElementVisitor"/>
    <constructor name="DefaultElementVisitor"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="visitOther" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="element" type="com.google.inject.spi.Element"/>
      <doc>
      <![CDATA[Default visit implementation. Returns {@code null}.]]>
      </doc>
    </method>
    <method name="visit" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="message" type="com.google.inject.spi.Message"/>
    </method>
    <method name="visit" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="binding" type="com.google.inject.Binding"/>
    </method>
    <method name="visit" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="interceptorBinding" type="com.google.inject.spi.InterceptorBinding"/>
    </method>
    <method name="visit" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="scopeBinding" type="com.google.inject.spi.ScopeBinding"/>
    </method>
    <method name="visit" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="typeConverterBinding" type="com.google.inject.spi.TypeConverterBinding"/>
    </method>
    <method name="visit" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="providerLookup" type="com.google.inject.spi.ProviderLookup"/>
    </method>
    <method name="visit" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="injectionRequest" type="com.google.inject.spi.InjectionRequest"/>
    </method>
    <method name="visit" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="staticInjectionRequest" type="com.google.inject.spi.StaticInjectionRequest"/>
    </method>
    <method name="visit" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="privateElements" type="com.google.inject.spi.PrivateElements"/>
    </method>
    <method name="visit" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="lookup" type="com.google.inject.spi.MembersInjectorLookup"/>
    </method>
    <method name="visit" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="binding" type="com.google.inject.spi.TypeListenerBinding"/>
    </method>
    <method name="visit" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="binding" type="com.google.inject.spi.ProvisionListenerBinding"/>
    </method>
    <method name="visit" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="option" type="com.google.inject.spi.DisableCircularProxiesOption"/>
    </method>
    <method name="visit" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="option" type="com.google.inject.spi.RequireExplicitBindingsOption"/>
    </method>
    <method name="visit" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="option" type="com.google.inject.spi.RequireAtInjectOnConstructorsOption"/>
    </method>
    <method name="visit" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="option" type="com.google.inject.spi.RequireExactBindingAnnotationsOption"/>
    </method>
    <method name="visit" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="binding" type="com.google.inject.spi.ModuleAnnotatedMethodScannerBinding"/>
    </method>
    <doc>
    <![CDATA[No-op visitor for subclassing. All interface methods simply delegate to {@link
 #visitOther(Element)}, returning its result.

 @param <V> any type to be returned by the visit method. Use {@link Void} with {@code return null}
     if no return type is needed.
 @author sberlin@gmail.com (Sam Berlin)
 @since 2.0]]>
    </doc>
  </class>
  <!-- end class com.google.inject.spi.DefaultElementVisitor -->
  <!-- start class com.google.inject.spi.Dependency -->
  <class name="Dependency" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="get" return="com.google.inject.spi.Dependency"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="com.google.inject.Key"/>
      <doc>
      <![CDATA[Returns a new dependency that is not attached to an injection point. The returned dependency is
 nullable.]]>
      </doc>
    </method>
    <method name="forInjectionPoints" return="java.util.Set"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="injectionPoints" type="java.util.Set"/>
      <doc>
      <![CDATA[Returns the dependencies from the given injection points.]]>
      </doc>
    </method>
    <method name="getKey" return="com.google.inject.Key"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the key to the binding that satisfies this dependency.]]>
      </doc>
    </method>
    <method name="isNullable" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns true if null is a legal value for this dependency.]]>
      </doc>
    </method>
    <method name="getInjectionPoint" return="com.google.inject.spi.InjectionPoint"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the injection point to which this dependency belongs, or null if this dependency isn't
 attached to a particular injection point.]]>
      </doc>
    </method>
    <method name="getParameterIndex" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the index of this dependency in the injection point's parameter list, or {@code -1} if
 this dependency does not belong to a parameter list. Only method and constuctor dependencies
 are elements in a parameter list.]]>
      </doc>
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="o" type="java.lang.Object"/>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[A variable that can be resolved by an injector.

 <p>Use {@link #get} to build a freestanding dependency, or {@link InjectionPoint} to build one
 that's attached to a constructor, method or field.

 @author crazybob@google.com (Bob Lee)
 @author jessewilson@google.com (Jesse Wilson)
 @since 2.0]]>
    </doc>
  </class>
  <!-- end class com.google.inject.spi.Dependency -->
  <!-- start class com.google.inject.spi.DisableCircularProxiesOption -->
  <class name="DisableCircularProxiesOption" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.inject.spi.Element"/>
    <method name="getSource" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="applyTo"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="binder" type="com.google.inject.Binder"/>
    </method>
    <method name="acceptVisitor" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="visitor" type="com.google.inject.spi.ElementVisitor"/>
    </method>
    <doc>
    <![CDATA[A request to disable circular proxies.

 @author sameb@google.com (Sam Berlin)
 @since 3.0]]>
    </doc>
  </class>
  <!-- end class com.google.inject.spi.DisableCircularProxiesOption -->
  <!-- start interface com.google.inject.spi.Element -->
  <interface name="Element"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="getSource" return="java.lang.Object"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns an arbitrary object containing information about the "place" where this element was
 configured. Used by Guice in the production of descriptive error messages.

 <p>Tools might specially handle types they know about; {@code StackTraceElement} is a good
 example. Tools should simply call {@code toString()} on the source object if the type is
 unfamiliar.]]>
      </doc>
    </method>
    <method name="acceptVisitor" return="java.lang.Object"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="visitor" type="com.google.inject.spi.ElementVisitor"/>
      <doc>
      <![CDATA[Accepts an element visitor. Invokes the visitor method specific to this element's type.

 @param visitor to call back on]]>
      </doc>
    </method>
    <method name="applyTo"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="binder" type="com.google.inject.Binder"/>
      <doc>
      <![CDATA[Writes this module element to the given binder (optional operation).

 @param binder to apply configuration element to
 @throws UnsupportedOperationException if the {@code applyTo} method is not supported by this
     element.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A core component of a module or injector.

 <p>The elements of a module can be inspected, validated and rewritten. Use {@link
 Elements#getElements(com.google.inject.Module[]) Elements.getElements()} to read the elements
 from a module, and {@link Elements#getModule(Iterable) Elements.getModule()} to rewrite them.
 This can be used for static analysis and generation of Guice modules.

 <p>The elements of an injector can be inspected and exercised. Use {@link
 com.google.inject.Injector#getBindings Injector.getBindings()} to reflect on Guice injectors.

 @author jessewilson@google.com (Jesse Wilson)
 @author crazybob@google.com (Bob Lee)
 @since 2.0]]>
    </doc>
  </interface>
  <!-- end interface com.google.inject.spi.Element -->
  <!-- start class com.google.inject.spi.Elements -->
  <class name="Elements" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="Elements"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getElements" return="java.util.List"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="modules" type="com.google.inject.Module[]"/>
      <doc>
      <![CDATA[Records the elements executed by {@code modules}.]]>
      </doc>
    </method>
    <method name="getElements" return="java.util.List"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="stage" type="com.google.inject.Stage"/>
      <param name="modules" type="com.google.inject.Module[]"/>
      <doc>
      <![CDATA[Records the elements executed by {@code modules}.]]>
      </doc>
    </method>
    <method name="getElements" return="java.util.List"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="modules" type="java.lang.Iterable"/>
      <doc>
      <![CDATA[Records the elements executed by {@code modules}.]]>
      </doc>
    </method>
    <method name="getElements" return="java.util.List"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="stage" type="com.google.inject.Stage"/>
      <param name="modules" type="java.lang.Iterable"/>
      <doc>
      <![CDATA[Records the elements executed by {@code modules}.]]>
      </doc>
    </method>
    <method name="withTrustedSource" return="com.google.inject.Binder"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="guiceInternal" type="com.google.inject.internal.GuiceInternal"/>
      <param name="binder" type="com.google.inject.Binder"/>
      <param name="source" type="java.lang.Object"/>
      <doc>
      <![CDATA[Internal version of Binder.withSource for establishing a trusted ElementSource chain for
 source-restricting bindings that are re-written using {@link Element#applyTo}.

 <p>Using Binder.withSource is not trustworthy because it's a public API that external users can
 use to spoof the original ElementSource of a binding by calling withSource(bogusElementSource).

 @since 5.0]]>
      </doc>
    </method>
    <method name="getModule" return="com.google.inject.Module"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="elements" type="java.lang.Iterable"/>
      <doc>
      <![CDATA[Returns the module composed of {@code elements}.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Exposes elements of a module so they can be inspected, validated or {@link
 Element#applyTo(Binder) rewritten}.

 @author jessewilson@google.com (Jesse Wilson)
 @since 2.0]]>
    </doc>
  </class>
  <!-- end class com.google.inject.spi.Elements -->
  <!-- start class com.google.inject.spi.ElementSource -->
  <class name="ElementSource" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="getOriginalElementSource" return="com.google.inject.spi.ElementSource"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the {@link ElementSource} of the element this was created or copied from. If this was
 not created or copied from another element, returns {@code null}.]]>
      </doc>
    </method>
    <method name="getDeclaringSource" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a single location in source code that defines the element. It can be any object such as
 {@link java.lang.reflect.Constructor}, {@link java.lang.reflect.Method}, {@link
 java.lang.reflect.Field}, {@link StackTraceElement}, etc. For example, if the element is
 created from a method annotated by {@literal @Provides}, the declaring source of element would
 be the method itself.]]>
      </doc>
    </method>
    <method name="getModuleClassNames" return="java.util.List"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the class names of modules involved in creating this {@link Element}. The first element
 (index 0) is the class name of module that defined the element, and the last element is the
 class name of root module.]]>
      </doc>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns {@code getDeclaringSource().toString()} value.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Contains information about where and how an {@link Element element} was bound.

 <p>The {@link #getDeclaringSource() declaring source} refers to a location in source code that
 defines the Guice {@link Element element}. For example, if the element is created from a method
 annotated by {@literal @Provides}, the declaring source of element would be the method itself.

 <p>The sequence of class names of {@link com.google.inject.Module modules} involved in the
 element creation can be retrieved by {@link #getModuleClassNames()}. The order of the module
 class names is reverse chronological. The first module (index 0) is the module that installs the
 {@link Element element}. The last module is the root module.

 <p>In order to support the cases where a Guice {@link Element element} is created from another
 Guice {@link Element element} (original) (e.g., by {@link Element#applyTo}), it also provides a
 reference to the original element source ({@link #getOriginalElementSource()}).

 @since 4.0]]>
    </doc>
  </class>
  <!-- end class com.google.inject.spi.ElementSource -->
  <!-- start interface com.google.inject.spi.ElementVisitor -->
  <interface name="ElementVisitor"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="visit" return="java.lang.Object"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="binding" type="com.google.inject.Binding"/>
      <doc>
      <![CDATA[Visit a mapping from a key (type and optional annotation) to the strategy for getting instances
 of the type.]]>
      </doc>
    </method>
    <method name="visit" return="java.lang.Object"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="binding" type="com.google.inject.spi.InterceptorBinding"/>
      <doc>
      <![CDATA[Visit a registration of interceptors for matching methods of matching classes.]]>
      </doc>
    </method>
    <method name="visit" return="java.lang.Object"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="binding" type="com.google.inject.spi.ScopeBinding"/>
      <doc>
      <![CDATA[Visit a registration of a scope annotation with the scope that implements it.]]>
      </doc>
    </method>
    <method name="visit" return="java.lang.Object"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="binding" type="com.google.inject.spi.TypeConverterBinding"/>
      <doc>
      <![CDATA[Visit a registration of type converters for matching target types.]]>
      </doc>
    </method>
    <method name="visit" return="java.lang.Object"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="request" type="com.google.inject.spi.InjectionRequest"/>
      <doc>
      <![CDATA[Visit a request to inject the instance fields and methods of an instance.]]>
      </doc>
    </method>
    <method name="visit" return="java.lang.Object"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="request" type="com.google.inject.spi.StaticInjectionRequest"/>
      <doc>
      <![CDATA[Visit a request to inject the static fields and methods of type.]]>
      </doc>
    </method>
    <method name="visit" return="java.lang.Object"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="lookup" type="com.google.inject.spi.ProviderLookup"/>
      <doc>
      <![CDATA[Visit a lookup of the provider for a type.]]>
      </doc>
    </method>
    <method name="visit" return="java.lang.Object"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="lookup" type="com.google.inject.spi.MembersInjectorLookup"/>
      <doc>
      <![CDATA[Visit a lookup of the members injector.]]>
      </doc>
    </method>
    <method name="visit" return="java.lang.Object"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="message" type="com.google.inject.spi.Message"/>
      <doc>
      <![CDATA[Visit an error message and the context in which it occured.]]>
      </doc>
    </method>
    <method name="visit" return="java.lang.Object"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="elements" type="com.google.inject.spi.PrivateElements"/>
      <doc>
      <![CDATA[Visit a collection of configuration elements for a {@linkplain com.google.inject.PrivateBinder
 private binder}.]]>
      </doc>
    </method>
    <method name="visit" return="java.lang.Object"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="binding" type="com.google.inject.spi.TypeListenerBinding"/>
      <doc>
      <![CDATA[Visit an injectable type listener binding.]]>
      </doc>
    </method>
    <method name="visit" return="java.lang.Object"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="binding" type="com.google.inject.spi.ProvisionListenerBinding"/>
      <doc>
      <![CDATA[Visit a provision listener binding.

 @since 4.0]]>
      </doc>
    </method>
    <method name="visit" return="java.lang.Object"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="option" type="com.google.inject.spi.RequireExplicitBindingsOption"/>
      <doc>
      <![CDATA[Visit a require explicit bindings command.

 @since 3.0]]>
      </doc>
    </method>
    <method name="visit" return="java.lang.Object"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="option" type="com.google.inject.spi.DisableCircularProxiesOption"/>
      <doc>
      <![CDATA[Visit a disable circular proxies command.

 @since 3.0]]>
      </doc>
    </method>
    <method name="visit" return="java.lang.Object"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="option" type="com.google.inject.spi.RequireAtInjectOnConstructorsOption"/>
      <doc>
      <![CDATA[Visit a require explicit {@literal @}{@link Inject} command.

 @since 4.0]]>
      </doc>
    </method>
    <method name="visit" return="java.lang.Object"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="option" type="com.google.inject.spi.RequireExactBindingAnnotationsOption"/>
      <doc>
      <![CDATA[Visit a require exact binding annotations command.

 @since 4.0]]>
      </doc>
    </method>
    <method name="visit" return="java.lang.Object"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="binding" type="com.google.inject.spi.ModuleAnnotatedMethodScannerBinding"/>
      <doc>
      <![CDATA[Visits a {@link Binder#scanModulesForAnnotatedMethods} command.

 @since 4.0]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Visit elements.

 @param <V> any type to be returned by the visit method. Use {@link Void} with {@code return null}
     if no return type is needed.
 @since 2.0]]>
    </doc>
  </interface>
  <!-- end interface com.google.inject.spi.ElementVisitor -->
  <!-- start class com.google.inject.spi.ErrorDetail -->
  <class name="ErrorDetail" extends="java.lang.Object"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.io.Serializable"/>
    <constructor name="ErrorDetail" type="java.lang.String, java.util.List, java.lang.Throwable"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </constructor>
    <method name="isMergeable" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="otherError" type="com.google.inject.spi.ErrorDetail"/>
      <doc>
      <![CDATA[Returns true if this error can be merged with the {@code otherError} and formatted together.

 <p>By default this return false and implementations that support merging with other errors
 should override this method.]]>
      </doc>
    </method>
    <method name="format"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="index" type="int"/>
      <param name="mergeableErrors" type="java.util.List"/>
      <param name="formatter" type="java.util.Formatter"/>
      <doc>
      <![CDATA[Formats this error along with other errors that are mergeable with this error.

 <p>{@code mergeableErrors} is a list that contains all other errors that are reported in the
 same exception that are considered to be mergable with this error base on result of calling
 {@link #isMergeable}. The list will be empty if non of the other errors are mergable with this
 error.

 <p>Formatted error has the following structure:

 <ul>
   <li>Summary of the error
   <li>Details about the error such as the source of the error
   <li>Hints for fixing the error if available
   <li>Link to the documentation on this error in greater detail
 </ul>

 @param index index for this error
 @param mergeableErrors list of errors that are mergeable with this error
 @param formatter for printing the error message]]>
      </doc>
    </method>
    <method name="formatDetail"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="mergeableErrors" type="java.util.List"/>
      <param name="formatter" type="java.util.Formatter"/>
      <doc>
      <![CDATA[Formats the detail of this error message along with other errors that are mergeable with this
 error. This is called from {@link #format}.

 <p>{@code mergeableErrors} is a list that contains all other errors that are reported in the
 same exception that are considered to be mergable with this error base on result of calling
 {@link #isMergeable}. The list will be empty if non of the other errors are mergable with this
 error.

 @param mergeableErrors list of errors that are mergeable with this error
 @param formatter for printing the error message]]>
      </doc>
    </method>
    <method name="getLearnMoreLink" return="java.util.Optional"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns an optional link to additional documentation about this error to be included in the
 formatted error message.]]>
      </doc>
    </method>
    <method name="getErrorIdentifier" return="java.util.Optional"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns an optional string identifier for this error.]]>
      </doc>
    </method>
    <method name="getMessage" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getSources" return="java.util.List"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getCause" return="java.lang.Throwable"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="o" type="java.lang.Object"/>
    </method>
    <method name="withSources" return="com.google.inject.spi.ErrorDetail"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="newSources" type="java.util.List"/>
      <doc>
      <![CDATA[Returns a new instance of the same {@link ErrorDetail} with updated sources.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Details about a single Guice error and supports formatting itself in the context of other Guice
 errors.

 <p>WARNING: The class and its APIs are still experimental and subject to change.

 @since 5.0]]>
    </doc>
  </class>
  <!-- end class com.google.inject.spi.ErrorDetail -->
  <!-- start interface com.google.inject.spi.ExposedBinding -->
  <interface name="ExposedBinding"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.inject.Binding"/>
    <implements name="com.google.inject.spi.HasDependencies"/>
    <method name="getPrivateElements" return="com.google.inject.spi.PrivateElements"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the enclosed environment that holds the original binding.]]>
      </doc>
    </method>
    <method name="applyTo"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="binder" type="com.google.inject.Binder"/>
      <doc>
      <![CDATA[Unsupported. Always throws {@link UnsupportedOperationException}.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A binding to a key exposed from an enclosed private environment.

 @author jessewilson@google.com (Jesse Wilson)
 @since 2.0]]>
    </doc>
  </interface>
  <!-- end interface com.google.inject.spi.ExposedBinding -->
  <!-- start interface com.google.inject.spi.HasDependencies -->
  <interface name="HasDependencies"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="getDependencies" return="java.util.Set"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the known dependencies for this type. If this has dependencies whose values are not
 known statically, a dependency for the {@link com.google.inject.Injector Injector} will be
 included in the returned set.

 @return a possibly empty set]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Implemented by {@link com.google.inject.Binding bindings}, {@link com.google.inject.Provider
 providers} and instances that expose their dependencies explicitly.

 @author jessewilson@google.com (Jesse Wilson)
 @since 2.0]]>
    </doc>
  </interface>
  <!-- end interface com.google.inject.spi.HasDependencies -->
  <!-- start interface com.google.inject.spi.InjectionListener -->
  <interface name="InjectionListener"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="afterInjection"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="injectee" type="java.lang.Object"/>
      <doc>
      <![CDATA[Invoked by Guice after it injects the fields and methods of instance.

 @param injectee instance that Guice injected dependencies into]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Listens for injections into instances of type {@code I}. Useful for performing further
 injections, post-injection initialization, and more.

 @author crazybob@google.com (Bob Lee)
 @author jessewilson@google.com (Jesse Wilson)
 @since 2.0]]>
    </doc>
  </interface>
  <!-- end interface com.google.inject.spi.InjectionListener -->
  <!-- start class com.google.inject.spi.InjectionPoint -->
  <class name="InjectionPoint" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="getMember" return="java.lang.reflect.Member"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the injected constructor, field, or method.]]>
      </doc>
    </method>
    <method name="getDependencies" return="java.util.List"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the dependencies for this injection point. If the injection point is for a method or
 constructor, the dependencies will correspond to that member's parameters. Field injection
 points always have a single dependency for the field itself.

 @return a possibly-empty list]]>
      </doc>
    </method>
    <method name="isOptional" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns true if this injection point shall be skipped if the injector cannot resolve bindings
 for all required dependencies. Both explicit bindings (as specified in a module), and implicit
 bindings ({@literal @}{@link com.google.inject.ImplementedBy ImplementedBy}, default
 constructors etc.) may be used to satisfy optional injection points.]]>
      </doc>
    </method>
    <method name="isToolable" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns true if the element is annotated with {@literal @}{@link Toolable}.

 @since 3.0]]>
      </doc>
    </method>
    <method name="getDeclaringType" return="com.google.inject.TypeLiteral"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the generic type that defines this injection point. If the member exists on a
 parameterized type, the result will include more type information than the member's {@link
 Member#getDeclaringClass() raw declaring class}.

 @since 3.0]]>
      </doc>
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="o" type="java.lang.Object"/>
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="forConstructor" return="com.google.inject.spi.InjectionPoint"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="constructor" type="java.lang.reflect.Constructor"/>
      <doc>
      <![CDATA[Returns a new injection point for the specified constructor. If the declaring type of {@code
 constructor} is parameterized (such as {@code List<T>}), prefer the overload that includes a
 type literal.

 @param constructor any single constructor present on {@code type}.
 @since 3.0]]>
      </doc>
    </method>
    <method name="forConstructor" return="com.google.inject.spi.InjectionPoint"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="constructor" type="java.lang.reflect.Constructor"/>
      <param name="type" type="com.google.inject.TypeLiteral"/>
      <doc>
      <![CDATA[Returns a new injection point for the specified constructor of {@code type}.

 @param constructor any single constructor present on {@code type}.
 @param type the concrete type that defines {@code constructor}.
 @since 3.0]]>
      </doc>
    </method>
    <method name="forConstructorOf" return="com.google.inject.spi.InjectionPoint"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="com.google.inject.TypeLiteral"/>
      <doc>
      <![CDATA[Returns a new injection point for the injectable constructor of {@code type}.

 <p>Either a {@code @Inject} annotated constructor or a non-private no arg constructor is
 required to be defined by the class corresponding to {@code type}.

 @param type a concrete type with exactly one constructor annotated {@literal @}{@link Inject},
     or a no-arguments constructor that is not private.
 @throws ConfigurationException if there is no injectable constructor, more than one injectable
     constructor, or if parameters of the injectable constructor are malformed, such as a
     parameter with multiple binding annotations.]]>
      </doc>
    </method>
    <method name="forConstructorOf" return="com.google.inject.spi.InjectionPoint"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="com.google.inject.TypeLiteral"/>
      <param name="atInjectRequired" type="boolean"/>
      <doc>
      <![CDATA[Returns a new injection point for the injectable constructor of {@code type}.

 <p>If {@code atInjectRequired} is true, the constructor must be annotated with {@code @Inject}.
 If {@code atInjectRequired} is false, either a {@code @Inject} annotated constructor or a
 non-private no arg constructor is required to be defined by the class corresponding to {@code
 type}.

 @param type a concrete type with exactly one constructor annotated {@code @Inject}, or a
     no-arguments constructor that is not private.
 @param atInjectRequired whether the constructor must be annotated with {@code Inject}.
 @throws ConfigurationException if there is no injectable constructor, more than one injectable
     constructor, or if parameters of the injectable constructor are malformed, such as a
     parameter with multiple binding annotations.
 @since 5.0]]>
      </doc>
    </method>
    <method name="forConstructorOf" return="com.google.inject.spi.InjectionPoint"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="java.lang.Class"/>
      <doc>
      <![CDATA[Returns a new injection point for the injectable constructor of {@code type}.

 @param type a concrete type with exactly one constructor annotated {@literal @}{@link Inject},
     or a no-arguments constructor that is not private.
 @throws ConfigurationException if there is no injectable constructor, more than one injectable
     constructor, or if parameters of the injectable constructor are malformed, such as a
     parameter with multiple binding annotations.]]>
      </doc>
    </method>
    <method name="forMethod" return="com.google.inject.spi.InjectionPoint"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="method" type="java.lang.reflect.Method"/>
      <param name="type" type="com.google.inject.TypeLiteral"/>
      <doc>
      <![CDATA[Returns a new injection point for the specified method of {@code type}. This is useful for
 extensions that need to build dependency graphs from arbitrary methods.

 @param method any single method present on {@code type}.
 @param type the concrete type that defines {@code method}.
 @since 4.0]]>
      </doc>
    </method>
    <method name="forStaticMethodsAndFields" return="java.util.Set"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="com.google.inject.TypeLiteral"/>
      <doc>
      <![CDATA[Returns all static method and field injection points on {@code type}.

 @return a possibly empty set of injection points. The set has a specified iteration order. All
     fields are returned and then all methods. Within the fields, supertype fields are returned
     before subtype fields. Similarly, supertype methods are returned before subtype methods.
 @throws ConfigurationException if there is a malformed injection point on {@code type}, such as
     a field with multiple binding annotations. The exception's {@link
     ConfigurationException#getPartialValue() partial value} is a {@code Set<InjectionPoint>} of
     the valid injection points.]]>
      </doc>
    </method>
    <method name="forStaticMethodsAndFields" return="java.util.Set"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="java.lang.Class"/>
      <doc>
      <![CDATA[Returns all static method and field injection points on {@code type}.

 @return a possibly empty set of injection points. The set has a specified iteration order. All
     fields are returned and then all methods. Within the fields, supertype fields are returned
     before subtype fields. Similarly, supertype methods are returned before subtype methods.
 @throws ConfigurationException if there is a malformed injection point on {@code type}, such as
     a field with multiple binding annotations. The exception's {@link
     ConfigurationException#getPartialValue() partial value} is a {@code Set<InjectionPoint>} of
     the valid injection points.]]>
      </doc>
    </method>
    <method name="forInstanceMethodsAndFields" return="java.util.Set"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="com.google.inject.TypeLiteral"/>
      <doc>
      <![CDATA[Returns all instance method and field injection points on {@code type}.

 @return a possibly empty set of injection points. The set has a specified iteration order. All
     fields are returned and then all methods. Within the fields, supertype fields are returned
     before subtype fields. Similarly, supertype methods are returned before subtype methods.
 @throws ConfigurationException if there is a malformed injection point on {@code type}, such as
     a field with multiple binding annotations. The exception's {@link
     ConfigurationException#getPartialValue() partial value} is a {@code Set<InjectionPoint>} of
     the valid injection points.]]>
      </doc>
    </method>
    <method name="forInstanceMethodsAndFields" return="java.util.Set"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="java.lang.Class"/>
      <doc>
      <![CDATA[Returns all instance method and field injection points on {@code type}.

 @return a possibly empty set of injection points. The set has a specified iteration order. All
     fields are returned and then all methods. Within the fields, supertype fields are returned
     before subtype fields. Similarly, supertype methods are returned before subtype methods.
 @throws ConfigurationException if there is a malformed injection point on {@code type}, such as
     a field with multiple binding annotations. The exception's {@link
     ConfigurationException#getPartialValue() partial value} is a {@code Set<InjectionPoint>} of
     the valid injection points.]]>
      </doc>
    </method>
    <method name="getAnnotations" return="java.lang.annotation.Annotation[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="field" type="java.lang.reflect.Field"/>
      <doc>
      <![CDATA[Returns all the annotations on a field. If Kotlin-support is enabled, the annotations will
 include annotations on the related Kotlin-property.

 @since 5.0]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A constructor, field or method that can receive injections. Typically this is a member with the
 {@literal @}{@link Inject} annotation. For non-private, no argument constructors, the member may
 omit the annotation.

 @author crazybob@google.com (Bob Lee)
 @since 2.0]]>
    </doc>
  </class>
  <!-- end class com.google.inject.spi.InjectionPoint -->
  <!-- start class com.google.inject.spi.InjectionRequest -->
  <class name="InjectionRequest" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.inject.spi.Element"/>
    <constructor name="InjectionRequest" type="java.lang.Object, com.google.inject.TypeLiteral, java.lang.Object"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getSource" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getInstance" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the instance that injection is being requested on. This may be null for injection
 requests returned from an Injector, to allow the injector to reclaim memory.]]>
      </doc>
    </method>
    <method name="getType" return="com.google.inject.TypeLiteral"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getInjectionPoints" return="java.util.Set"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="ConfigurationException" type="com.google.inject.ConfigurationException"/>
      <doc>
      <![CDATA[Returns the instance methods and fields of {@code instance} that will be injected to fulfill
 this request.

 @return a possibly empty set of injection points. The set has a specified iteration order. All
     fields are returned and then all methods. Within the fields, supertype fields are returned
     before subtype fields. Similarly, supertype methods are returned before subtype methods.
 @throws ConfigurationException if there is a malformed injection point on the class of {@code
     instance}, such as a field with multiple binding annotations. The exception's {@link
     ConfigurationException#getPartialValue() partial value} is a {@code Set<InjectionPoint>} of
     the valid injection points.]]>
      </doc>
    </method>
    <method name="acceptVisitor" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="visitor" type="com.google.inject.spi.ElementVisitor"/>
    </method>
    <method name="applyTo"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="binder" type="com.google.inject.Binder"/>
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="obj" type="java.lang.Object"/>
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[A request to inject the instance fields and methods of an instance. Requests are created
 explicitly in a module using {@link com.google.inject.Binder#requestInjection(Object)
 requestInjection()} statements:

 <pre>
     requestInjection(serviceInstance);</pre>

 @author mikeward@google.com (Mike Ward)
 @since 2.0]]>
    </doc>
  </class>
  <!-- end class com.google.inject.spi.InjectionRequest -->
  <!-- start interface com.google.inject.spi.InstanceBinding -->
  <interface name="InstanceBinding"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.inject.Binding"/>
    <implements name="com.google.inject.spi.HasDependencies"/>
    <method name="getInstance" return="java.lang.Object"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the user-supplied instance.]]>
      </doc>
    </method>
    <method name="getInjectionPoints" return="java.util.Set"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the field and method injection points of the instance, injected at injector-creation
 time only.

 @return a possibly empty set]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A binding to a single instance. The same instance is returned for every injection.

 @author jessewilson@google.com (Jesse Wilson)
 @since 2.0]]>
    </doc>
  </interface>
  <!-- end interface com.google.inject.spi.InstanceBinding -->
  <!-- start class com.google.inject.spi.InterceptorBinding -->
  <class name="InterceptorBinding" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.inject.spi.Element"/>
    <method name="getSource" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getClassMatcher" return="com.google.inject.matcher.Matcher"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getMethodMatcher" return="com.google.inject.matcher.Matcher"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getInterceptors" return="java.util.List"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="acceptVisitor" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="visitor" type="com.google.inject.spi.ElementVisitor"/>
    </method>
    <method name="applyTo"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="binder" type="com.google.inject.Binder"/>
    </method>
    <doc>
    <![CDATA[Registration of interceptors for matching methods of matching classes. Instances are created
 explicitly in a module using {@link com.google.inject.Binder#bindInterceptor( Matcher, Matcher,
 MethodInterceptor[]) bindInterceptor()} statements:

 <pre>
     bindInterceptor(Matchers.subclassesOf(MyAction.class),
         Matchers.annotatedWith(Transactional.class),
         new MyTransactionInterceptor());</pre>

 or from an injectable type listener using {@link TypeEncounter#bindInterceptor(Matcher,
 org.aopalliance.intercept.MethodInterceptor[]) TypeEncounter.bindInterceptor()}.

 @author jessewilson@google.com (Jesse Wilson)
 @since 2.0]]>
    </doc>
  </class>
  <!-- end class com.google.inject.spi.InterceptorBinding -->
  <!-- start interface com.google.inject.spi.LinkedKeyBinding -->
  <interface name="LinkedKeyBinding"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.inject.Binding"/>
    <method name="getLinkedKey" return="com.google.inject.Key"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the linked key used to resolve injections. That binding can be retrieved from an
 injector using {@link com.google.inject.Injector#getBinding(Key) Injector.getBinding(key)}.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A binding to a linked key. The other key's binding is used to resolve injections.

 @author jessewilson@google.com (Jesse Wilson)
 @since 2.0]]>
    </doc>
  </interface>
  <!-- end interface com.google.inject.spi.LinkedKeyBinding -->
  <!-- start class com.google.inject.spi.MembersInjectorLookup -->
  <class name="MembersInjectorLookup" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.inject.spi.Element"/>
    <constructor name="MembersInjectorLookup" type="java.lang.Object, com.google.inject.TypeLiteral"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getSource" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getType" return="com.google.inject.TypeLiteral"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the type containing the members to be injected.]]>
      </doc>
    </method>
    <method name="acceptVisitor" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="visitor" type="com.google.inject.spi.ElementVisitor"/>
    </method>
    <method name="initializeDelegate"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="delegate" type="com.google.inject.MembersInjector"/>
      <doc>
      <![CDATA[Sets the actual members injector.

 @throws IllegalStateException if the delegate is already set]]>
      </doc>
    </method>
    <method name="applyTo"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="binder" type="com.google.inject.Binder"/>
    </method>
    <method name="getDelegate" return="com.google.inject.MembersInjector"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the delegate members injector, or {@code null} if it has not yet been initialized. The
 delegate will be initialized when this element is processed, or otherwise used to create an
 injector.]]>
      </doc>
    </method>
    <method name="getInjectionPoints" return="java.util.Set"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="ConfigurationException" type="com.google.inject.ConfigurationException"/>
      <doc>
      <![CDATA[Returns the instance methods and fields that will be injected to fulfill this request.

 @since 4.2.3
 @return a possibly empty set of injection points. The set has a specified iteration order. All
     fields are returned and then all methods. Within the fields, supertype fields are returned
     before subtype fields. Similarly, supertype methods are returned before subtype methods.
 @throws ConfigurationException if there is a malformed injection point on the class of {@code
     instance}, such as a field with multiple binding annotations. The exception's {@link
     ConfigurationException#getPartialValue() partial value} is a {@code Set<InjectionPoint>} of
     the valid injection points.]]>
      </doc>
    </method>
    <method name="getMembersInjector" return="com.google.inject.MembersInjector"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the looked up members injector. The result is not valid until this lookup has been
 initialized, which usually happens when the injector is created. The members injector will
 throw an {@code IllegalStateException} if you try to use it beforehand.]]>
      </doc>
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="obj" type="java.lang.Object"/>
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[A lookup of the members injector for a type. Lookups are created explicitly in a module using
 {@link com.google.inject.Binder#getMembersInjector(Class) getMembersInjector()} statements:

 <pre>
     MembersInjector&lt;PaymentService&gt; membersInjector
         = getMembersInjector(PaymentService.class);</pre>

 @author crazybob@google.com (Bob Lee)
 @since 2.0]]>
    </doc>
  </class>
  <!-- end class com.google.inject.spi.MembersInjectorLookup -->
  <!-- start class com.google.inject.spi.Message -->
  <class name="Message" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="java.io.Serializable"/>
    <implements name="com.google.inject.spi.Element"/>
    <constructor name="Message" type="com.google.inject.internal.GuiceInternal, com.google.inject.internal.ErrorId, com.google.inject.spi.ErrorDetail"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@since 5.0]]>
      </doc>
    </constructor>
    <constructor name="Message" type="com.google.inject.internal.ErrorId, java.util.List, java.lang.String, java.lang.Throwable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@since 2.0]]>
      </doc>
    </constructor>
    <constructor name="Message" type="java.util.List, java.lang.String, java.lang.Throwable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@since 2.0]]>
      </doc>
    </constructor>
    <constructor name="Message" type="java.lang.String, java.lang.Throwable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@since 4.0]]>
      </doc>
    </constructor>
    <constructor name="Message" type="java.lang.Object, java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="Message" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getErrorDetail" return="com.google.inject.spi.ErrorDetail"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns details about this error message.

 @since 5.0]]>
      </doc>
    </method>
    <method name="getSource" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getSources" return="java.util.List"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@since 2.0]]>
      </doc>
    </method>
    <method name="getMessage" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the error message text.]]>
      </doc>
    </method>
    <method name="acceptVisitor" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="visitor" type="com.google.inject.spi.ElementVisitor"/>
      <doc>
      <![CDATA[@since 2.0]]>
      </doc>
    </method>
    <method name="getCause" return="java.lang.Throwable"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the throwable that caused this message, or {@code null} if this message was not caused
 by a throwable.

 @since 2.0]]>
      </doc>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="o" type="java.lang.Object"/>
    </method>
    <method name="applyTo"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="binder" type="com.google.inject.Binder"/>
      <doc>
      <![CDATA[@since 2.0]]>
      </doc>
    </method>
    <method name="withSource" return="com.google.inject.spi.Message"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="newSources" type="java.util.List"/>
      <doc>
      <![CDATA[Returns a copy of this {@link Message} with its sources replaced.

 @since 5.0]]>
      </doc>
    </method>
    <doc>
    <![CDATA[An error message and the context in which it occured. Messages are usually created internally by
 Guice and its extensions. Messages can be created explicitly in a module using {@link
 com.google.inject.Binder#addError(Throwable) addError()} statements:

 <pre>
     try {
       bindPropertiesFromFile();
     } catch (IOException e) {
       addError(e);
     }</pre>

 @author crazybob@google.com (Bob Lee)]]>
    </doc>
  </class>
  <!-- end class com.google.inject.spi.Message -->
  <!-- start class com.google.inject.spi.ModuleAnnotatedMethodScanner -->
  <class name="ModuleAnnotatedMethodScanner" extends="java.lang.Object"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="ModuleAnnotatedMethodScanner"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="annotationClasses" return="java.util.Set"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the annotations this should scan for. Every method in the module that has one of these
 annotations will create a Provider binding, with the return value of the binding being what's
 provided and the parameters of the method being dependencies of the provider.]]>
      </doc>
    </method>
    <method name="prepareMethod" return="com.google.inject.Key"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="binder" type="com.google.inject.Binder"/>
      <param name="annotation" type="java.lang.annotation.Annotation"/>
      <param name="key" type="com.google.inject.Key"/>
      <param name="injectionPoint" type="com.google.inject.spi.InjectionPoint"/>
      <doc>
      <![CDATA[Prepares a method for binding. This {@code key} parameter is the key discovered from looking at
 the binding annotation and return value of the method. Implementations can modify the key to
 instead bind to another key. For example, Multibinder may want to change
 {@code @ProvidesIntoSet String provideFoo()} to bind into a unique Key within the multibinder
 instead of binding {@code String}.

 <p>The injection point and annotation are provided in case the implementation wants to set the
 key based on the property of the annotation or if any additional preparation is needed for any
 of the dependencies. The annotation is guaranteed to be an instance of one the classes returned
 by {@link #annotationClasses}.

 <p>Returning null will cause Guice to skip this method, so that it is not bound to any key.

 <p>If {@code injectionPoint} represents an {@code abstract} method, {@code null} must be
 returned from this method. This scanner can use {@code binder} to bind alternative bindings in
 place of the abstract method.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Allows extensions to scan modules for annotated methods and bind those methods as providers,
 similar to {@code @Provides} methods.

 @since 4.0]]>
    </doc>
  </class>
  <!-- end class com.google.inject.spi.ModuleAnnotatedMethodScanner -->
  <!-- start class com.google.inject.spi.ModuleAnnotatedMethodScannerBinding -->
  <class name="ModuleAnnotatedMethodScannerBinding" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.inject.spi.Element"/>
    <constructor name="ModuleAnnotatedMethodScannerBinding" type="java.lang.Object, com.google.inject.spi.ModuleAnnotatedMethodScanner"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getSource" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getScanner" return="com.google.inject.spi.ModuleAnnotatedMethodScanner"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="acceptVisitor" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="visitor" type="com.google.inject.spi.ElementVisitor"/>
    </method>
    <method name="applyTo"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="binder" type="com.google.inject.Binder"/>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Represents a call to {@link Binder#scanModulesForAnnotatedMethods} in a module.

 @author sameb@google.com (Sam Berlin)
 @since 4.0]]>
    </doc>
  </class>
  <!-- end class com.google.inject.spi.ModuleAnnotatedMethodScannerBinding -->
  <!-- start interface com.google.inject.spi.PrivateElements -->
  <interface name="PrivateElements"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.inject.spi.Element"/>
    <method name="getElements" return="java.util.List"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the configuration information in this private environment.]]>
      </doc>
    </method>
    <method name="getInjector" return="com.google.inject.Injector"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the child injector that hosts these private elements, or null if the elements haven't
 been used to create an injector.]]>
      </doc>
    </method>
    <method name="getExposedKeys" return="java.util.Set"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the unique exposed keys for these private elements.]]>
      </doc>
    </method>
    <method name="getExposedSource" return="java.lang.Object"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="com.google.inject.Key"/>
      <doc>
      <![CDATA[Returns an arbitrary object containing information about the "place" where this key was
 exposed. Used by Guice in the production of descriptive error messages.

 <p>Tools might specially handle types they know about; {@code StackTraceElement} is a good
 example. Tools should simply call {@code toString()} on the source object if the type is
 unfamiliar.

 @param key one of the keys exposed by this module.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A private collection of elements that are hidden from the enclosing injector or module by
 default. See {@link com.google.inject.PrivateModule PrivateModule} for details.

 @author jessewilson@google.com (Jesse Wilson)
 @since 2.0]]>
    </doc>
  </interface>
  <!-- end interface com.google.inject.spi.PrivateElements -->
  <!-- start interface com.google.inject.spi.ProviderBinding -->
  <interface name="ProviderBinding"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.inject.Binding"/>
    <method name="getProvidedKey" return="com.google.inject.Key"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the key whose binding is used to {@link Provider#get provide instances}. That binding
 can be retrieved from an injector using {@link com.google.inject.Injector#getBinding(Key)
 Injector.getBinding(providedKey)}]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A binding to a {@link Provider} that delegates to the binding for the provided type. This binding
 is used whenever a {@code Provider<T>} is injected (as opposed to injecting {@code T} directly).

 @author jessewilson@google.com (Jesse Wilson)
 @since 2.0]]>
    </doc>
  </interface>
  <!-- end interface com.google.inject.spi.ProviderBinding -->
  <!-- start interface com.google.inject.spi.ProviderInstanceBinding -->
  <interface name="ProviderInstanceBinding"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.inject.Binding"/>
    <implements name="com.google.inject.spi.HasDependencies"/>
    <method name="getProviderInstance" return="com.google.inject.Provider"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="Use {@link #getUserSuppliedProvider} instead.">
      <doc>
      <![CDATA[If the user supplied a JSR330 binding, then this will wrap that one. To always return the
 user-supplied provider, use {@link #getUserSuppliedProvider}.

 @deprecated Use {@link #getUserSuppliedProvider} instead.]]>
      </doc>
    </method>
    <method name="getUserSuppliedProvider" return="javax.inject.Provider"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the user-supplied, unscoped provider.

 @since 4.0]]>
      </doc>
    </method>
    <method name="getInjectionPoints" return="java.util.Set"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the field and method injection points of the provider, injected at injector-creation
 time only.

 @return a possibly empty set]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A binding to a provider instance. The provider's {@code get} method is invoked to resolve
 injections.

 @author jessewilson@google.com (Jesse Wilson)
 @since 2.0]]>
    </doc>
  </interface>
  <!-- end interface com.google.inject.spi.ProviderInstanceBinding -->
  <!-- start interface com.google.inject.spi.ProviderKeyBinding -->
  <interface name="ProviderKeyBinding"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.inject.Binding"/>
    <method name="getProviderKey" return="com.google.inject.Key"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the key used to resolve the provider's binding. That binding can be retrieved from an
 injector using {@link com.google.inject.Injector#getBinding(Key)
 Injector.getBinding(providerKey)}]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A binding to a provider key. To resolve injections, the provider key is first resolved, then that
 provider's {@code get} method is invoked.

 @author jessewilson@google.com (Jesse Wilson)
 @since 2.0]]>
    </doc>
  </interface>
  <!-- end interface com.google.inject.spi.ProviderKeyBinding -->
  <!-- start class com.google.inject.spi.ProviderLookup -->
  <class name="ProviderLookup" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.inject.spi.Element"/>
    <constructor name="ProviderLookup" type="java.lang.Object, com.google.inject.Key"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="ProviderLookup" type="java.lang.Object, com.google.inject.spi.Dependency"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@since 4.0]]>
      </doc>
    </constructor>
    <method name="getSource" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getKey" return="com.google.inject.Key"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getDependency" return="com.google.inject.spi.Dependency"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@since 4.0]]>
      </doc>
    </method>
    <method name="acceptVisitor" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="visitor" type="com.google.inject.spi.ElementVisitor"/>
    </method>
    <method name="initializeDelegate"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="delegate" type="com.google.inject.Provider"/>
      <doc>
      <![CDATA[Sets the actual provider.

 @throws IllegalStateException if the delegate is already set]]>
      </doc>
    </method>
    <method name="applyTo"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="binder" type="com.google.inject.Binder"/>
    </method>
    <method name="getDelegate" return="com.google.inject.Provider"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the delegate provider, or {@code null} if it has not yet been initialized. The delegate
 will be initialized when this element is processed, or otherwise used to create an injector.]]>
      </doc>
    </method>
    <method name="getProvider" return="com.google.inject.Provider"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the looked up provider. The result is not valid until this lookup has been initialized,
 which usually happens when the injector is created. The provider will throw an {@code
 IllegalStateException} if you try to use it beforehand.]]>
      </doc>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="obj" type="java.lang.Object"/>
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[A lookup of the provider for a type. Lookups are created explicitly in a module using {@link
 com.google.inject.Binder#getProvider(Class) getProvider()} statements:

 <pre>
     Provider&lt;PaymentService&gt; paymentServiceProvider
         = getProvider(PaymentService.class);</pre>

 @author jessewilson@google.com (Jesse Wilson)
 @since 2.0]]>
    </doc>
  </class>
  <!-- end class com.google.inject.spi.ProviderLookup -->
  <!-- start interface com.google.inject.spi.ProviderWithDependencies -->
  <interface name="ProviderWithDependencies"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.inject.Provider"/>
    <implements name="com.google.inject.spi.HasDependencies"/>
    <doc>
    <![CDATA[A provider with dependencies on other injected types. If a {@link Provider} has dependencies that
 aren't specified in injections, this interface should be used to expose all dependencies.

 @since 2.0]]>
    </doc>
  </interface>
  <!-- end interface com.google.inject.spi.ProviderWithDependencies -->
  <!-- start interface com.google.inject.spi.ProviderWithExtensionVisitor -->
  <interface name="ProviderWithExtensionVisitor"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.inject.Provider"/>
    <method name="acceptExtensionVisitor" return="java.lang.Object"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="visitor" type="com.google.inject.spi.BindingTargetVisitor"/>
      <param name="binding" type="com.google.inject.spi.ProviderInstanceBinding"/>
      <doc>
      <![CDATA[Instructs the extension determine if the visitor is an instance of a custom extension visitor,
 and if so, visit it using that method. If the visitor is not an instance of the custom
 extension visitor, this method <b>MUST</b> call visitor.visit(binding).

 <p>Due to issues with generics, the type parameters of this method do not relate to the type of
 the provider. In practice, the 'B' type will always be a supertype of 'T'.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A Provider that is part of an extension which supports a custom BindingTargetVisitor.

 <p>When an extension binds a provider instance, the provider can implement this interface to
 allow users using the {@link Binding#acceptTargetVisitor(BindingTargetVisitor)} method to visit a
 custom visitor designed for that extension. A typical implementation within the extension would
 look like

 <pre>{@code
 <V, B> V acceptExtensionVisitor(
    BindingTargetVisitor<B, V> visitor, ProviderInstanceBinding<? extends B> binding) {
   if(visitor instanceof MyCustomExtensionVisitor) {
     return ((MyCustomExtensionVisitor<B, V>)visitor)
        .visitCustomExtension(customProperties, binding);
   } else {
     return visitor.visit(binding);
   }
 }
 }</pre>

 'MyCustomExtensionVisitor' in the example above would be an interface the extension provides that
 users can implement in order to be notified of custom extension information. These visitor
 interfaces must extend from BindingTargetVisitor.

 @since 3.0
 @author sameb@google.com (Sam Berlin)]]>
    </doc>
  </interface>
  <!-- end interface com.google.inject.spi.ProviderWithExtensionVisitor -->
  <!-- start interface com.google.inject.spi.ProvidesMethodBinding -->
  <interface name="ProvidesMethodBinding"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.inject.spi.HasDependencies"/>
    <method name="getMethod" return="java.lang.reflect.Method"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the method this binding uses.]]>
      </doc>
    </method>
    <method name="getEnclosingInstance" return="java.lang.Object"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the instance of the object the method is defined in.]]>
      </doc>
    </method>
    <method name="getKey" return="com.google.inject.Key"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the key of the binding.]]>
      </doc>
    </method>
    <method name="getAnnotation" return="java.lang.annotation.Annotation"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the annotation that caused this binding to be created. For {@code @Provides} methods,
 this is an instance of the {@code @Provides} annotation. For bindings from {@link
 ModuleAnnotatedMethodScanner}, this is the annotation that caused the scanner to produce the
 binding.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[An {@literal @}{@link Provides} binding or binding produced by a {@link
 ModuleAnnotatedMethodScanner}.

 @since 4.0
 @author sameb@google.com (Sam Berlin)]]>
    </doc>
  </interface>
  <!-- end interface com.google.inject.spi.ProvidesMethodBinding -->
  <!-- start interface com.google.inject.spi.ProvidesMethodTargetVisitor -->
  <interface name="ProvidesMethodTargetVisitor"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.inject.spi.BindingTargetVisitor"/>
    <method name="visit" return="java.lang.Object"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="providesMethodBinding" type="com.google.inject.spi.ProvidesMethodBinding"/>
      <doc>
      <![CDATA[Visits an {@link ProvidesMethodBinding} created with an {@literal @}{@link Provides} method.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A visitor for the {@literal @}{@link Provides} bindings.

 <p>If your {@link com.google.inject.spi.BindingTargetVisitor} implements this interface, bindings
 created by using {@code @Provides} will be visited through this interface.

 @since 4.0
 @author sameb@google.com (Sam Berlin)]]>
    </doc>
  </interface>
  <!-- end interface com.google.inject.spi.ProvidesMethodTargetVisitor -->
  <!-- start interface com.google.inject.spi.ProvisionListener -->
  <interface name="ProvisionListener"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="onProvision"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="provision" type="com.google.inject.spi.ProvisionListener.ProvisionInvocation"/>
      <doc>
      <![CDATA[Invoked by Guice when an object requires provisioning. Provisioning occurs when Guice locates
 and injects the dependencies for a binding. For types bound to a Provider, provisioning
 encapsulates the {@link Provider#get} method. For toInstance or constant bindings, provisioning
 encapsulates the injecting of {@literal @}{@code Inject}ed fields or methods. For other types,
 provisioning encapsulates the construction of the object. If a type is bound within a {@link
 Scope}, provisioning depends on the scope. Types bound in Singleton scope will only be
 provisioned once. Types bound in no scope will be provisioned every time they are injected.
 Other scopes define their own behavior for provisioning.

 <p>To perform the provision, call {@link ProvisionInvocation#provision()}. If you do not
 explicitly call provision, it will be automatically done after this method returns. It is an
 error to call provision more than once.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Listens for provisioning of objects. Useful for gathering timing information about provisioning,
 post-provision initialization, and more.

 @author sameb@google.com (Sam Berlin)
 @since 4.0]]>
    </doc>
  </interface>
  <!-- end interface com.google.inject.spi.ProvisionListener -->
  <!-- start class com.google.inject.spi.ProvisionListener.ProvisionInvocation -->
  <class name="ProvisionListener.ProvisionInvocation" extends="java.lang.Object"
    abstract="true"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="ProvisionInvocation"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getBinding" return="com.google.inject.Binding"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the Binding this is provisioning.

 <p>You must not call {@link Provider#get()} on the provider returned by {@link
 Binding#getProvider}, otherwise you will get confusing error messages.]]>
      </doc>
    </method>
    <method name="provision" return="java.lang.Object"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Performs the provision, returning the object provisioned.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Encapsulates a single act of provisioning.

 @since 4.0]]>
    </doc>
  </class>
  <!-- end class com.google.inject.spi.ProvisionListener.ProvisionInvocation -->
  <!-- start class com.google.inject.spi.ProvisionListenerBinding -->
  <class name="ProvisionListenerBinding" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.inject.spi.Element"/>
    <method name="getListeners" return="java.util.List"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the registered listeners.]]>
      </doc>
    </method>
    <method name="getBindingMatcher" return="com.google.inject.matcher.Matcher"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the binding matcher which chooses which bindings the listener should be notified of.]]>
      </doc>
    </method>
    <method name="getSource" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="acceptVisitor" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="visitor" type="com.google.inject.spi.ElementVisitor"/>
    </method>
    <method name="applyTo"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="binder" type="com.google.inject.Binder"/>
    </method>
    <doc>
    <![CDATA[Binds keys (picked using a Matcher) to a provision listener. Listeners are created explicitly in
 a module using {@link Binder#bindListener(Matcher, ProvisionListener...)} statements:

 @author sameb@google.com (Sam Berlin)
 @since 4.0]]>
    </doc>
  </class>
  <!-- end class com.google.inject.spi.ProvisionListenerBinding -->
  <!-- start class com.google.inject.spi.RequireAtInjectOnConstructorsOption -->
  <class name="RequireAtInjectOnConstructorsOption" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.inject.spi.Element"/>
    <method name="getSource" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="applyTo"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="binder" type="com.google.inject.Binder"/>
    </method>
    <method name="acceptVisitor" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="visitor" type="com.google.inject.spi.ElementVisitor"/>
    </method>
    <doc>
    <![CDATA[A request to require explicit {@literal @}{@link Inject} annotations on constructors.

 @author sameb@google.com (Sam Berlin)
 @since 4.0]]>
    </doc>
  </class>
  <!-- end class com.google.inject.spi.RequireAtInjectOnConstructorsOption -->
  <!-- start class com.google.inject.spi.RequireExactBindingAnnotationsOption -->
  <class name="RequireExactBindingAnnotationsOption" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.inject.spi.Element"/>
    <method name="getSource" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="applyTo"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="binder" type="com.google.inject.Binder"/>
    </method>
    <method name="acceptVisitor" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="visitor" type="com.google.inject.spi.ElementVisitor"/>
    </method>
    <doc>
    <![CDATA[A request to require exact binding annotations.

 @author sameb@google.com (Sam Berlin)
 @since 4.0]]>
    </doc>
  </class>
  <!-- end class com.google.inject.spi.RequireExactBindingAnnotationsOption -->
  <!-- start class com.google.inject.spi.RequireExplicitBindingsOption -->
  <class name="RequireExplicitBindingsOption" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.inject.spi.Element"/>
    <method name="getSource" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="applyTo"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="binder" type="com.google.inject.Binder"/>
    </method>
    <method name="acceptVisitor" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="visitor" type="com.google.inject.spi.ElementVisitor"/>
    </method>
    <doc>
    <![CDATA[A request to require explicit bindings.

 @author sameb@google.com (Sam Berlin)
 @since 3.0]]>
    </doc>
  </class>
  <!-- end class com.google.inject.spi.RequireExplicitBindingsOption -->
  <!-- start class com.google.inject.spi.ScopeBinding -->
  <class name="ScopeBinding" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.inject.spi.Element"/>
    <method name="getSource" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getAnnotationType" return="java.lang.Class"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getScope" return="com.google.inject.Scope"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="acceptVisitor" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="visitor" type="com.google.inject.spi.ElementVisitor"/>
    </method>
    <method name="applyTo"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="binder" type="com.google.inject.Binder"/>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Registration of a scope annotation with the scope that implements it. Instances are created
 explicitly in a module using {@link com.google.inject.Binder#bindScope(Class, Scope) bindScope()}
 statements:

 <pre>
     Scope recordScope = new RecordScope();
     bindScope(RecordScoped.class, new RecordScope());</pre>

 @author jessewilson@google.com (Jesse Wilson)
 @since 2.0]]>
    </doc>
  </class>
  <!-- end class com.google.inject.spi.ScopeBinding -->
  <!-- start class com.google.inject.spi.StaticInjectionRequest -->
  <class name="StaticInjectionRequest" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.inject.spi.Element"/>
    <method name="getSource" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getType" return="java.lang.Class"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getInjectionPoints" return="java.util.Set"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="ConfigurationException" type="com.google.inject.ConfigurationException"/>
      <doc>
      <![CDATA[Returns the static methods and fields of {@code type} that will be injected to fulfill this
 request.

 @return a possibly empty set of injection points. The set has a specified iteration order. All
     fields are returned and then all methods. Within the fields, supertype fields are returned
     before subtype fields. Similarly, supertype methods are returned before subtype methods.
 @throws ConfigurationException if there is a malformed injection point on {@code type}, such as
     a field with multiple binding annotations. The exception's {@link
     ConfigurationException#getPartialValue() partial value} is a {@code Set<InjectionPoint>} of
     the valid injection points.]]>
      </doc>
    </method>
    <method name="applyTo"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="binder" type="com.google.inject.Binder"/>
    </method>
    <method name="acceptVisitor" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="visitor" type="com.google.inject.spi.ElementVisitor"/>
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="obj" type="java.lang.Object"/>
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[A request to inject the static fields and methods of a type. Requests are created explicitly in a
 module using {@link com.google.inject.Binder#requestStaticInjection(Class[])
 requestStaticInjection()} statements:

 <pre>
     requestStaticInjection(MyLegacyService.class);</pre>

 @author jessewilson@google.com (Jesse Wilson)
 @since 2.0]]>
    </doc>
  </class>
  <!-- end class com.google.inject.spi.StaticInjectionRequest -->
  <!-- start interface com.google.inject.spi.Toolable -->
  <interface name="Toolable"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.lang.annotation.Annotation"/>
    <doc>
    <![CDATA[Instructs an {@link Injector} running in {@link Stage#TOOL} that a method should be injected.
 This is typically useful for for extensions to Guice that perform additional validation in an
 injected method or field. This only applies to objects that are already constructed when bindings
 are created (ie., something bound using {@link
 com.google.inject.binder.LinkedBindingBuilder#toProvider toProvider}, {@link
 com.google.inject.binder.LinkedBindingBuilder#toInstance toInstance}, or {@link
 com.google.inject.Binder#requestInjection requestInjection}.

 @author sberlin@gmail.com (Sam Berlin)
 @since 3.0]]>
    </doc>
  </interface>
  <!-- end interface com.google.inject.spi.Toolable -->
  <!-- start interface com.google.inject.spi.TypeConverter -->
  <interface name="TypeConverter"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="convert" return="java.lang.Object"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="java.lang.String"/>
      <param name="toType" type="com.google.inject.TypeLiteral"/>
      <doc>
      <![CDATA[Converts a string value. Throws an exception if a conversion error occurs.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Converts constant string values to a different type.

 @author crazybob@google.com (Bob Lee)
 @since 2.0]]>
    </doc>
  </interface>
  <!-- end interface com.google.inject.spi.TypeConverter -->
  <!-- start class com.google.inject.spi.TypeConverterBinding -->
  <class name="TypeConverterBinding" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.inject.spi.Element"/>
    <constructor name="TypeConverterBinding" type="java.lang.Object, com.google.inject.matcher.Matcher, com.google.inject.spi.TypeConverter"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@since 3.0]]>
      </doc>
    </constructor>
    <method name="getSource" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getTypeMatcher" return="com.google.inject.matcher.Matcher"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getTypeConverter" return="com.google.inject.spi.TypeConverter"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="acceptVisitor" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="visitor" type="com.google.inject.spi.ElementVisitor"/>
    </method>
    <method name="applyTo"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="binder" type="com.google.inject.Binder"/>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Registration of type converters for matching target types. Instances are created explicitly in a
 module using {@link com.google.inject.Binder#convertToTypes(Matcher, TypeConverter)
 convertToTypes()} statements:

 <pre>
     convertToTypes(Matchers.only(TypeLiteral.get(DateTime.class)), new DateTimeConverter());
 </pre>

 @author jessewilson@google.com (Jesse Wilson)
 @since 2.0]]>
    </doc>
  </class>
  <!-- end class com.google.inject.spi.TypeConverterBinding -->
  <!-- start interface com.google.inject.spi.TypeEncounter -->
  <interface name="TypeEncounter"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="addError"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="message" type="java.lang.String"/>
      <param name="arguments" type="java.lang.Object[]"/>
      <doc>
      <![CDATA[Records an error message for type {@code I} which will be presented to the user at a later
 time. Unlike throwing an exception, this enable us to continue configuring the Injector and
 discover more errors. Uses {@link String#format(String, Object[])} to insert the arguments into
 the message.]]>
      </doc>
    </method>
    <method name="addError"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="t" type="java.lang.Throwable"/>
      <doc>
      <![CDATA[Records an exception for type {@code I}, the full details of which will be logged, and the
 message of which will be presented to the user at a later time. If your type listener calls
 something that you worry may fail, you should catch the exception and pass it to this method.]]>
      </doc>
    </method>
    <method name="addError"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="message" type="com.google.inject.spi.Message"/>
      <doc>
      <![CDATA[Records an error message to be presented to the user at a later time.]]>
      </doc>
    </method>
    <method name="getProvider" return="com.google.inject.Provider"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="com.google.inject.Key"/>
      <doc>
      <![CDATA[Returns the provider used to obtain instances for the given injection key. The returned
 provider will not be valid until the injector has been created. The provider will throw an
 {@code IllegalStateException} if you try to use it beforehand.]]>
      </doc>
    </method>
    <method name="getProvider" return="com.google.inject.Provider"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="java.lang.Class"/>
      <doc>
      <![CDATA[Returns the provider used to obtain instances for the given injection type. The returned
 provider will not be valid until the injector has been created. The provider will throw an
 {@code IllegalStateException} if you try to use it beforehand.]]>
      </doc>
    </method>
    <method name="getMembersInjector" return="com.google.inject.MembersInjector"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="typeLiteral" type="com.google.inject.TypeLiteral"/>
      <doc>
      <![CDATA[Returns the members injector used to inject dependencies into methods and fields on instances
 of the given type {@code T}. The returned members injector will not be valid until the main
 injector has been created. The members injector will throw an {@code IllegalStateException} if
 you try to use it beforehand.

 @param typeLiteral type to get members injector for]]>
      </doc>
    </method>
    <method name="getMembersInjector" return="com.google.inject.MembersInjector"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="java.lang.Class"/>
      <doc>
      <![CDATA[Returns the members injector used to inject dependencies into methods and fields on instances
 of the given type {@code T}. The returned members injector will not be valid until the main
 injector has been created. The members injector will throw an {@code IllegalStateException} if
 you try to use it beforehand.

 @param type type to get members injector for]]>
      </doc>
    </method>
    <method name="register"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="membersInjector" type="com.google.inject.MembersInjector"/>
      <doc>
      <![CDATA[Registers a members injector for type {@code I}. Guice will use the members injector after its
 performed its own injections on an instance of {@code I}.]]>
      </doc>
    </method>
    <method name="register"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="listener" type="com.google.inject.spi.InjectionListener"/>
      <doc>
      <![CDATA[Registers an injection listener for type {@code I}. Guice will notify the listener after all
 injections have been performed on an instance of {@code I}.]]>
      </doc>
    </method>
    <method name="bindInterceptor"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="methodMatcher" type="com.google.inject.matcher.Matcher"/>
      <param name="interceptors" type="org.aopalliance.intercept.MethodInterceptor[]"/>
      <doc>
      <![CDATA[Binds method interceptor[s] to methods matched in type {@code I} and its supertypes. A method
 is eligible for interception if:

 <ul>
   <li>Guice created the instance the method is on
   <li>Neither the enclosing type nor the method is final
   <li>And the method is package-private or more accessible
 </ul>

 @param methodMatcher matches methods the interceptor should apply to. For example: {@code
     annotatedWith(Transactional.class)}.
 @param interceptors to bind]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Context of an injectable type encounter. Enables reporting errors, registering injection
 listeners and binding method interceptors for injectable type {@code I}. It is an error to use an
 encounter after the {@link TypeListener#hear(TypeLiteral, TypeEncounter) hear()} method has
 returned.

 @param <I> the injectable type encountered
 @since 2.0]]>
    </doc>
  </interface>
  <!-- end interface com.google.inject.spi.TypeEncounter -->
  <!-- start interface com.google.inject.spi.TypeListener -->
  <interface name="TypeListener"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="hear"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="com.google.inject.TypeLiteral"/>
      <param name="encounter" type="com.google.inject.spi.TypeEncounter"/>
      <doc>
      <![CDATA[Invoked when Guice encounters a new type eligible for constructor or members injection. Called
 during injector creation (or afterwards if Guice encounters a type at run time and creates a
 JIT binding).

 @param type encountered by Guice
 @param encounter context of this encounter, enables reporting errors, registering injection
     listeners and binding method interceptors for {@code type}.
 @param <I> the injectable type]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Listens for Guice to encounter injectable types. If a given type has its constructor injected in
 one situation but only its methods and fields injected in another, Guice will notify this
 listener once.

 <p>Useful for extra type checking, {@linkplain TypeEncounter#register(InjectionListener)
 registering injection listeners}, and {@linkplain TypeEncounter#bindInterceptor(
 com.google.inject.matcher.Matcher, org.aopalliance.intercept.MethodInterceptor[]) binding method
 interceptors}.

 @since 2.0]]>
    </doc>
  </interface>
  <!-- end interface com.google.inject.spi.TypeListener -->
  <!-- start class com.google.inject.spi.TypeListenerBinding -->
  <class name="TypeListenerBinding" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.inject.spi.Element"/>
    <method name="getListener" return="com.google.inject.spi.TypeListener"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the registered listener.]]>
      </doc>
    </method>
    <method name="getTypeMatcher" return="com.google.inject.matcher.Matcher"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the type matcher which chooses which types the listener should be notified of.]]>
      </doc>
    </method>
    <method name="getSource" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="acceptVisitor" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="visitor" type="com.google.inject.spi.ElementVisitor"/>
    </method>
    <method name="applyTo"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="binder" type="com.google.inject.Binder"/>
    </method>
    <doc>
    <![CDATA[Binds types (picked using a Matcher) to an type listener. Registrations are created explicitly in
 a module using {@link com.google.inject.Binder#bindListener(Matcher, TypeListener)} statements:

 <pre>{@code
 register(only(new TypeLiteral<PaymentService<CreditCard>>() {}), listener);
 }</pre>

 @author jessewilson@google.com (Jesse Wilson)
 @since 2.0]]>
    </doc>
  </class>
  <!-- end class com.google.inject.spi.TypeListenerBinding -->
  <!-- start interface com.google.inject.spi.UntargettedBinding -->
  <interface name="UntargettedBinding"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.inject.Binding"/>
    <doc>
    <![CDATA[An untargetted binding. This binding indicates that the injector should use its implicit binding
 strategies to resolve injections.

 @author jessewilson@google.com (Jesse Wilson)
 @since 2.0]]>
    </doc>
  </interface>
  <!-- end interface com.google.inject.spi.UntargettedBinding -->
</package>
<package name="com.google.inject.util">
  <!-- start class com.google.inject.util.Modules -->
  <class name="Modules" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="override" return="com.google.inject.util.Modules.OverriddenModuleBuilder"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="modules" type="com.google.inject.Module[]"/>
      <doc>
      <![CDATA[Returns a builder that creates a module that overlays override modules over the given modules.
 If a key is bound in both sets of modules, only the binding from the override modules is kept.
 If a single {@link PrivateModule} is supplied or all elements are from a single {@link
 PrivateBinder}, then this will overwrite the private bindings. Otherwise, private bindings will
 not be overwritten unless they are exposed. This can be used to replace the bindings of a
 production module with test bindings:

 <pre>
 Module functionalTestModule
     = Modules.override(new ProductionModule()).with(new TestModule());
 </pre>

 <p>Prefer to write smaller modules that can be reused and tested without overrides.

 @param modules the modules whose bindings are open to be overridden]]>
      </doc>
    </method>
    <method name="override" return="com.google.inject.util.Modules.OverriddenModuleBuilder"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="there's no reason to use {@code Modules.override()} without any arguments.">
      <doc>
      <![CDATA[@deprecated there's no reason to use {@code Modules.override()} without any arguments.]]>
      </doc>
    </method>
    <method name="override" return="com.google.inject.util.Modules.OverriddenModuleBuilder"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="modules" type="java.lang.Iterable"/>
      <doc>
      <![CDATA[Returns a builder that creates a module that overlays override modules over the given modules.
 If a key is bound in both sets of modules, only the binding from the override modules is kept.
 If a single {@link PrivateModule} is supplied or all elements are from a single {@link
 PrivateBinder}, then this will overwrite the private bindings. Otherwise, private bindings will
 not be overwritten unless they are exposed. This can be used to replace the bindings of a
 production module with test bindings:

 <pre>
 Module functionalTestModule
     = Modules.override(getProductionModules()).with(getTestModules());
 </pre>

 <p>Prefer to write smaller modules that can be reused and tested without overrides.

 @param modules the modules whose bindings are open to be overridden]]>
      </doc>
    </method>
    <method name="combine" return="com.google.inject.Module"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="modules" type="com.google.inject.Module[]"/>
      <doc>
      <![CDATA[Returns a new module that installs all of {@code modules}.

 <p>Although sometimes helpful, this method is rarely necessary. Most Guice APIs accept multiple
 arguments or (like {@code install()}) can be called repeatedly. Where possible, external APIs
 that require a single module should similarly be adapted to permit multiple modules.]]>
      </doc>
    </method>
    <method name="combine" return="com.google.inject.Module"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="there's no need to quote_cHaRcombinequote_cHaR one module; just install it directly.">
      <param name="module" type="com.google.inject.Module"/>
      <doc>
      <![CDATA[@deprecated there's no need to "combine" one module; just install it directly.]]>
      </doc>
    </method>
    <method name="combine" return="com.google.inject.Module"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="this method call is effectively a no-op, just remove it.">
      <doc>
      <![CDATA[@deprecated this method call is effectively a no-op, just remove it.]]>
      </doc>
    </method>
    <method name="combine" return="com.google.inject.Module"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="modules" type="java.lang.Iterable"/>
      <doc>
      <![CDATA[Returns a new module that installs all of {@code modules}.

 <p>Although sometimes helpful, this method is rarely necessary. Most Guice APIs accept multiple
 arguments or (like {@code install()}) can be called repeatedly. Where possible, external APIs
 that require a single module should similarly be adapted to permit multiple modules.]]>
      </doc>
    </method>
    <method name="requireExplicitBindingsModule" return="com.google.inject.Module"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a module that will configure the injector to require explicit bindings.

 @since 4.2.3]]>
      </doc>
    </method>
    <method name="requireAtInjectOnConstructorsModule" return="com.google.inject.Module"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a module that will configure the injector to require {@literal @}{@link Inject} on
 constructors.

 @since 4.2.3
 @see Binder#requireAtInjectOnConstructors]]>
      </doc>
    </method>
    <method name="requireExactBindingAnnotationsModule" return="com.google.inject.Module"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a module that will configure the injector to require an exactly matching binding
 annotation.

 @since 4.2.3
 @see Binder#requireExactBindingAnnotations]]>
      </doc>
    </method>
    <method name="disableCircularProxiesModule" return="com.google.inject.Module"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a module that will configure the injector to disable circular proxies.

 @since 4.2.3]]>
      </doc>
    </method>
    <field name="EMPTY_MODULE" type="com.google.inject.Module"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[Static utility methods for creating and working with instances of {@link Module}.

 @author jessewilson@google.com (Jesse Wilson)
 @since 2.0]]>
    </doc>
  </class>
  <!-- end class com.google.inject.util.Modules -->
  <!-- start interface com.google.inject.util.Modules.OverriddenModuleBuilder -->
  <interface name="Modules.OverriddenModuleBuilder"    abstract="true"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="with" return="com.google.inject.Module"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="overrides" type="com.google.inject.Module[]"/>
      <doc>
      <![CDATA[See the EDSL example at {@link Modules#override(Module[]) override()}.]]>
      </doc>
    </method>
    <method name="with" return="com.google.inject.Module"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="there's no reason to use {@code .with()} without any arguments.">
      <doc>
      <![CDATA[@deprecated there's no reason to use {@code .with()} without any arguments.]]>
      </doc>
    </method>
    <method name="with" return="com.google.inject.Module"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="overrides" type="java.lang.Iterable"/>
      <doc>
      <![CDATA[See the EDSL example at {@link Modules#override(Module[]) override()}.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[See the EDSL example at {@link Modules#override(Module[]) override()}.]]>
    </doc>
  </interface>
  <!-- end interface com.google.inject.util.Modules.OverriddenModuleBuilder -->
  <!-- start class com.google.inject.util.Providers -->
  <class name="Providers" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="of" return="com.google.inject.Provider"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="instance" type="java.lang.Object"/>
      <doc>
      <![CDATA[Returns a provider which always provides {@code instance}. This should not be necessary to use
 in your application, but is helpful for several types of unit tests.

 @param instance the instance that should always be provided. This is also permitted to be null,
     to enable aggressive testing, although in real life a Guice-supplied Provider will never
     return null.]]>
      </doc>
    </method>
    <method name="guicify" return="com.google.inject.Provider"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="provider" type="javax.inject.Provider"/>
      <doc>
      <![CDATA[Returns a Guice-friendly {@code com.google.inject.Provider} for the given JSR-330 {@code
 javax.inject.Provider}. The converse method is unnecessary, since Guice providers directly
 implement the JSR-330 interface.

 @since 3.0]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Static utility methods for creating and working with instances of {@link Provider}.

 @author Kevin Bourrillion (kevinb9n@gmail.com)
 @since 2.0]]>
    </doc>
  </class>
  <!-- end class com.google.inject.util.Providers -->
  <!-- start class com.google.inject.util.Types -->
  <class name="Types" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="newParameterizedType" return="java.lang.reflect.ParameterizedType"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="rawType" type="java.lang.reflect.Type"/>
      <param name="typeArguments" type="java.lang.reflect.Type[]"/>
      <doc>
      <![CDATA[Returns a new parameterized type, applying {@code typeArguments} to {@code rawType}. The
 returned type does not have an owner type.

 @return a {@link java.io.Serializable serializable} parameterized type.]]>
      </doc>
    </method>
    <method name="newParameterizedTypeWithOwner" return="java.lang.reflect.ParameterizedType"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="ownerType" type="java.lang.reflect.Type"/>
      <param name="rawType" type="java.lang.reflect.Type"/>
      <param name="typeArguments" type="java.lang.reflect.Type[]"/>
      <doc>
      <![CDATA[Returns a new parameterized type, applying {@code typeArguments} to {@code rawType} and
 enclosed by {@code ownerType}.

 @return a {@link java.io.Serializable serializable} parameterized type.]]>
      </doc>
    </method>
    <method name="arrayOf" return="java.lang.reflect.GenericArrayType"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="componentType" type="java.lang.reflect.Type"/>
      <doc>
      <![CDATA[Returns an array type whose elements are all instances of {@code componentType}.

 @return a {@link java.io.Serializable serializable} generic array type.]]>
      </doc>
    </method>
    <method name="subtypeOf" return="java.lang.reflect.WildcardType"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="bound" type="java.lang.reflect.Type"/>
      <doc>
      <![CDATA[Returns a type that represents an unknown type that extends {@code bound}. For example, if
 {@code bound} is {@code CharSequence.class}, this returns {@code ? extends CharSequence}. If
 {@code bound} is {@code Object.class}, this returns {@code ?}, which is shorthand for {@code ?
 extends Object}.]]>
      </doc>
    </method>
    <method name="supertypeOf" return="java.lang.reflect.WildcardType"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="bound" type="java.lang.reflect.Type"/>
      <doc>
      <![CDATA[Returns a type that represents an unknown supertype of {@code bound}. For example, if {@code
 bound} is {@code String.class}, this returns {@code ? super String}.]]>
      </doc>
    </method>
    <method name="listOf" return="java.lang.reflect.ParameterizedType"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="elementType" type="java.lang.reflect.Type"/>
      <doc>
      <![CDATA[Returns a type modelling a {@link List} whose elements are of type {@code elementType}.

 @return a {@link java.io.Serializable serializable} parameterized type.]]>
      </doc>
    </method>
    <method name="collectionOf" return="java.lang.reflect.ParameterizedType"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="elementType" type="java.lang.reflect.Type"/>
      <doc>
      <![CDATA[Returns a type modelling a {@link Collection} whose elements are of type {@code elementType}.

 @return a {@link java.io.Serializable serializable} parameterized type.]]>
      </doc>
    </method>
    <method name="setOf" return="java.lang.reflect.ParameterizedType"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="elementType" type="java.lang.reflect.Type"/>
      <doc>
      <![CDATA[Returns a type modelling a {@link Set} whose elements are of type {@code elementType}.

 @return a {@link java.io.Serializable serializable} parameterized type.]]>
      </doc>
    </method>
    <method name="mapOf" return="java.lang.reflect.ParameterizedType"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="keyType" type="java.lang.reflect.Type"/>
      <param name="valueType" type="java.lang.reflect.Type"/>
      <doc>
      <![CDATA[Returns a type modelling a {@link Map} whose keys are of type {@code keyType} and whose values
 are of type {@code valueType}.

 @return a {@link java.io.Serializable serializable} parameterized type.]]>
      </doc>
    </method>
    <method name="providerOf" return="java.lang.reflect.ParameterizedType"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="providedType" type="java.lang.reflect.Type"/>
      <doc>
      <![CDATA[Returns a type modelling a {@link Provider} that provides elements of type {@code elementType}.

 @return a {@link java.io.Serializable serializable} parameterized type.]]>
      </doc>
    </method>
    <method name="javaxProviderOf" return="java.lang.reflect.Type"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="java.lang.reflect.Type"/>
      <doc>
      <![CDATA[Returns a type modelling a {@link javax.inject.Provider} that provides elements of type {@code
 elementType}.

 @return a {@link java.io.Serializable serializable} parameterized type.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Static methods for working with types.

 @author crazybob@google.com (Bob Lee)
 @since 2.0]]>
    </doc>
  </class>
  <!-- end class com.google.inject.util.Types -->
</package>
<package name="com.google.inject.name">
  <!-- start interface com.google.inject.name.Named -->
  <interface name="Named"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.lang.annotation.Annotation"/>
    <method name="value" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Annotates named things.

 @author crazybob@google.com (Bob Lee)]]>
    </doc>
  </interface>
  <!-- end interface com.google.inject.name.Named -->
  <!-- start class com.google.inject.name.Names -->
  <class name="Names" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="named" return="com.google.inject.name.Named"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <doc>
      <![CDATA[Creates a {@link Named} annotation with {@code name} as the value.]]>
      </doc>
    </method>
    <method name="bindProperties"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="binder" type="com.google.inject.Binder"/>
      <param name="properties" type="java.util.Map"/>
      <doc>
      <![CDATA[Creates a constant binding to {@code @Named(key)} for each entry in {@code properties}.]]>
      </doc>
    </method>
    <method name="bindProperties"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="binder" type="com.google.inject.Binder"/>
      <param name="properties" type="java.util.Properties"/>
      <doc>
      <![CDATA[Creates a constant binding to {@code @Named(key)} for each property. This method binds all
 properties including those inherited from {@link Properties#defaults defaults}.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Utility methods for use with {@code @}{@link Named}.

 @author crazybob@google.com (Bob Lee)]]>
    </doc>
  </class>
  <!-- end class com.google.inject.name.Names -->
</package>
<package name="com.google.inject.internal.aop">
  <!-- start class com.google.inject.internal.aop.ClassBuilding -->
  <class name="ClassBuilding" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="signature" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="constructor" type="java.lang.reflect.Constructor"/>
      <doc>
      <![CDATA[Minimum signature needed to disambiguate constructors from the same host class.]]>
      </doc>
    </method>
    <method name="signature" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="method" type="java.lang.reflect.Method"/>
      <doc>
      <![CDATA[Minimum signature needed to disambiguate methods from the same host class.]]>
      </doc>
    </method>
    <method name="canEnhance" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="member" type="java.lang.reflect.Executable"/>
      <doc>
      <![CDATA[Returns true if the given member can be enhanced using bytecode.]]>
      </doc>
    </method>
    <method name="buildEnhancerBuilder" return="com.google.inject.internal.BytecodeGen.EnhancerBuilder"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="hostClass" type="java.lang.Class"/>
      <doc>
      <![CDATA[Builder of enhancers that provide method interception via bytecode generation.]]>
      </doc>
    </method>
    <method name="canFastInvoke" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="member" type="java.lang.reflect.Executable"/>
      <doc>
      <![CDATA[Returns true if the given member can be fast-invoked.]]>
      </doc>
    </method>
    <method name="buildFastClass" return="java.util.function.Function"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="hostClass" type="java.lang.Class"/>
      <doc>
      <![CDATA[Builds a 'fast-class' invoker that uses bytecode generation in place of reflection.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Entry-point for building enhanced classes and 'fast-class' invocation.

 @author mcculls@gmail.com (Stuart McCulloch)]]>
    </doc>
  </class>
  <!-- end class com.google.inject.internal.aop.ClassBuilding -->
  <!-- start class com.google.inject.internal.aop.ClassDefining -->
  <class name="ClassDefining" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="define" return="java.lang.Class"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="hostClass" type="java.lang.Class"/>
      <param name="bytecode" type="byte[]"/>
      <exception name="Exception" type="java.lang.Exception"/>
      <doc>
      <![CDATA[Defines a new class relative to the host.]]>
      </doc>
    </method>
    <method name="hasPackageAccess" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns true if the current class definer allows access to package-private members.]]>
      </doc>
    </method>
    <method name="canLoadProxyByName" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="hostClass" type="java.lang.Class"/>
      <doc>
      <![CDATA[Returns true if it's possible to load by name proxies defined from the given host.]]>
      </doc>
    </method>
    <method name="canDowncastToProxy" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="hostClass" type="java.lang.Class"/>
      <doc>
      <![CDATA[Returns true if it's possible to downcast to proxies defined from the given host.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Entry-point for defining dynamically generated classes.

 @author mcculls@gmail.com (Stuart McCulloch)]]>
    </doc>
  </class>
  <!-- end class com.google.inject.internal.aop.ClassDefining -->
</package>

</api>
