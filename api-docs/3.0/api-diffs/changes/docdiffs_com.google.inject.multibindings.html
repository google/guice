<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Frameset//EN""http://www.w3.org/TR/REC-html40/frameset.dtd">
<HTML>
<HEAD>
<meta name="generator" content="JDiff v1.1.1">
<!-- Generated by the JDiff Javadoc doclet -->
<!-- (http://www.jdiff.org) -->
<meta name="description" content="JDiff is a Javadoc doclet which generates an HTML report of all the packages, classes, constructors, methods, and fields which have been removed, added or changed in any way, including their documentation, when two APIs are compared.">
<meta name="keywords" content="diff, jdiff, javadiff, java diff, java difference, API difference, difference between two APIs, API diff, Javadoc, doclet">
<LINK REL="stylesheet" TYPE="text/css" HREF="../stylesheet-jdiff.css" TITLE="Style">
<TITLE>
com.google.inject.multibindings Documentation Differences
</TITLE>
</HEAD>
<BODY>
<!-- Start of nav bar -->
<TABLE summary="Navigation bar" BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
  <TABLE summary="Navigation bar" BORDER="0" CELLPADDING="0" CELLSPACING="3">
    <TR ALIGN="center" VALIGN="top">
      <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1"> <A HREF="http://google-guice.googlecode.com/svn/trunk/latest-api-diffs/3.0/javadoc/com/google/inject/multibindings/package-summary.html" target="_top"><FONT CLASS="NavBarFont1"><B><tt>3.0</tt></B></FONT></A>&nbsp;</TD>
      <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1"> <A HREF="changes-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
      <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1"> &nbsp;<FONT CLASS="NavBarFont1">Package</FONT>&nbsp;</TD>
      <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1"> &nbsp;<FONT CLASS="NavBarFont1">Class</FONT>&nbsp;</TD>
      <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1"> <A HREF="docdiffs_index.html"><FONT CLASS="NavBarFont1"><B>Text Changes</B></FONT></A>&nbsp;</TD>
      <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1"> <A HREF="jdiff_statistics.html"><FONT CLASS="NavBarFont1"><B>Statistics</B></FONT></A>&nbsp;</TD>
      <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1"> <A HREF="jdiff_help.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
    </TR>
  </TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM><b>Generated by<br><a href="http://www.jdiff.org" class="staysblack" target="_top">JDiff</a></b></EM></TD>
</TR>
<TR>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="docdiffs_com.google.inject.assistedinject.html"><B>PREV PACKAGE</B></A>  &nbsp;
  &nbsp;<A HREF="docdiffs_com.google.inject.servlet.html"><B>NEXT PACKAGE</B></A>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  <A HREF="../changes.html" TARGET="_top"><B>FRAMES</B></A>  &nbsp;
  &nbsp;<A HREF="docdiffs_com.google.inject.multibindings.html" TARGET="_top"><B>NO FRAMES</B></A></FONT></TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell2">&nbsp;</TD>
</TR>
</TABLE>
<HR>
<!-- End of nav bar -->
<h2>
com.google.inject.multibindings Documentation Differences
</h2>

<blockquote>
This file contains all the changes in documentation in the package <code>com.google.inject.multibindings</code> as colored differences.
Deletions are shown <strike>like this</strike>, and
additions are shown <span style="background: #FFFF00">like this</span>.
</blockquote>
<blockquote>
If no deletions or additions are shown in an entry, the HTML tags will be what has changed. The <i>new</i> HTML tags are shown in the differences. 
If no documentation existed, and then some was added in a later version, this change is noted in the appropriate class pages of differences, but the change is not shown on this page. Only changes in existing text are shown here. 
Similarly, documentation which was inherited from another class or interface is not shown here.
</blockquote>
<blockquote>
 Note that an HTML error in the new documentation may cause the display of other documentation changes to be presented incorrectly. For instance, failure to close a &lt;code&gt; tag will cause all subsequent paragraphs to be displayed differently.
</blockquote>
<hr>

<A NAME="com.google.inject.multibindings.MapBinder!class"></A><a href="com.google.inject.multibindings.MapBinder.html" class="hiddenlink">Class <b>MapBinder</b></a><br><br><blockquote>An API to bind multiple map entries separately, only to later inject them as
 a complete map. MapBinder is intended for use in your application's module:
 <pre><code>
 public class SnacksModule extends AbstractModule {
   protected void configure() {
     MapBinder&lt;String, Snack&gt; mapbinder
         = MapBinder.newMapBinder(binder(), String.class, Snack.class);
     mapbinder.addBinding("twix").toInstance(new Twix());
     mapbinder.addBinding("snickers").toProvider(SnickersProvider.class);
     mapbinder.addBinding("skittles").to(Skittles.class);
   }
 }</code></pre>

 <p>With this binding, a <A HREF="http://google-guice.googlecode.com/svn/trunk/latest-api-diffs/3.0/javadoc/com/google/inject/multibindings/MapBinder/Map.html"><TT>Map</TT></A>{@code <String, Snack>} can now <strike>be 
</strike><span style="background: #FFFF00">be
</span> injected:
 <pre><code>
 class SnackMachine {
   {@literal @}Inject
   public SnackMachine(Map&lt;String, Snack&gt; snacks) { ... }
 }</code></pre><strike>
 
</strike><span style="background: #FFFF00">

</span> <p>In addition to binding {@code Map<K, V>}, a mapbinder will also bind
 {@code Map<K, Provider<V>>} for lazy value provision:
 <pre><code>
 class SnackMachine {
   {@literal @}Inject
   public SnackMachine(Map&lt;String, Provider&lt;Snack&gt;&gt; snackProviders) { ... }
 }</code></pre>

 <p><strike>Creating</strike><span style="background: #FFFF00">Contributing</span> mapbindings from different modules is supported. For example,<span style="background: #FFFF00">
</span> <strike>it
</strike><span style="background: #FFFF00">it</span> is okay to have both {@code CandyModule} and {@code ChipsModule} both
 create their own {@code MapBinder<String, Snack>}, and to each <strike>contribute</strike><span style="background: #FFFF00">contribute
</span> <strike>
 </strike>bindings to the snacks map. When that map is injected, it will <strike>contain 
</strike><span style="background: #FFFF00">contain
</span> entries from both modules.

 <p><span style="background: #FFFF00">The map's iteration order is consistent with the binding order. This is
 convenient when multiple elements are contributed by the same module because
 that module can order its bindings appropriately. Avoid relying on the
 iteration order of elements contributed by different modules, since there is
 no equivalent mechanism to order modules.
 
 <p>The map is unmodifiable.  Elements can only be added to the map by
 configuring the MapBinder.  Elements can never be removed from the map.

 <p></span>Values are resolved at map injection time. If a value is bound to a
 provider, that provider's get method will be called each time the map is
 injected (unless the binding is also scoped, or a map of providers is injected).

 <p>Annotations are used to create different maps of the same key/value
 type. Each distinct annotation gets its own independent map.

 <p><strong>Keys must be distinct.</strong> If the same key is bound more than
 once, map injection will fail.<span style="background: #FFFF00"> However, use <A HREF="http://google-guice.googlecode.com/svn/trunk/latest-api-diffs/3.0/javadoc/com/google/inject/multibindings/MapBinder/.html#permitDuplicates()"><TT>.permitDuplicates()</TT></A> in
 order to allow duplicate keys; extra bindings to {@code Map<K, Set<V>>} and
 {@code Map<K, Set<Provider<V>>} will be added.</span>

 <p><strong>Keys must be non-null.</strong> {@code addBinding(null)} <strike>will 
</strike><span style="background: #FFFF00">will
</span> throw an unchecked exception.

 <p><strong>Values must be non-null to use map injection.</strong> If any
 value is null, map injection will fail (although injecting a map of providers
 will not).

 @author dpb@google.com (David P. Baker)</blockquote>
<hr align="left" width="100%">
<A NAME="com.google.inject.multibindings.Multibinder!class"></A><a href="com.google.inject.multibindings.Multibinder.html" class="hiddenlink">Class <b>Multibinder</b></a><br><br><blockquote>An API to bind multiple values separately, only to later inject them as a
 complete collection. Multibinder is intended for use in your application's
 module:
 <pre><code>
 public class SnacksModule extends AbstractModule {
   protected void configure() {
     Multibinder&lt;Snack&gt; multibinder
         = Multibinder.newSetBinder(binder(), Snack.class);
     multibinder.addBinding().toInstance(new Twix());
     multibinder.addBinding().toProvider(SnickersProvider.class);
     multibinder.addBinding().to(Skittles.class);
   }
 }</code></pre>

 <p>With this binding, a <A HREF="http://google-guice.googlecode.com/svn/trunk/latest-api-diffs/3.0/javadoc/com/google/inject/multibindings/Multibinder/Set.html"><TT>Set</TT></A>{@code <Snack>} can now be injected:
 <pre><code>
 class SnackMachine {
   {@literal @}Inject
   public SnackMachine(Set&lt;Snack&gt; snacks) { ... }
 }</code></pre>

 <p><strike>Create</strike><span style="background: #FFFF00">Contributing</span> multibindings from different modules is supported. <strike>For</strike><span style="background: #FFFF00">For
</span> example, <strike>it
</strike><span style="background: #FFFF00">it</span> is okay to have both {@code CandyModule} and {@code ChipsModule}<span style="background: #FFFF00">
</span> to <strike>both
</strike><span style="background: #FFFF00">both</span> create their own {@code Multibinder<Snack>}, and to each <strike>contribute</strike><span style="background: #FFFF00">contribute
</span> <strike>bindings
</strike><span style="background: #FFFF00">bindings</span> to the set of snacks. When that set is injected, it will <strike>contain</strike><span style="background: #FFFF00">contain
</span> <strike>elements
</strike><span style="background: #FFFF00">elements</span> from both modules.<span style="background: #FFFF00">
 
 <p>The set's iteration order is consistent with the binding order. This is
 convenient when multiple elements are contributed by the same module because
 that module can order its bindings appropriately. Avoid relying on the
 iteration order of elements contributed by different modules, since there is
 no equivalent mechanism to order modules.
 
 <p>The set is unmodifiable.  Elements can only be added to the set by
 configuring the multibinder.  Elements can never be removed from the set.</span>

 <p>Elements are resolved at set injection time. If an element is bound to a
 provider, that provider's get method will be called each time the set is
 injected (unless the binding is also scoped).

 <p>Annotations are be used to create different sets of the same element
 type. Each distinct annotation gets its own independent collection of
 elements.

 <p><strong>Elements must be distinct.</strong> If multiple bound elements
 have the same value, set injection will fail.

 <p><strong>Elements must be non-null.</strong> If any set element is null,
 set injection will fail.

 @author jessewilson@google.com (Jesse Wilson)</blockquote>
<hr align="left" width="100%">

</BODY>
</HTML>
